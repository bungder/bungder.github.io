<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[阿里Druid连接池监控]]></title>
    <url>%2F2017%2F08%2F27%2Fdruid-monitor%2F</url>
    <content type="text"><![CDATA[1. 普通的web监控阿里开源的连接池Druid自带了web监控的功能，具体的操作在其github的wiki上可以找到：配置StatFilter · alibaba/driud wiki 其实主要就是配置一个Servlet，但是github wiki上的做法只能在druid所在的项目中启用web服务的做法，在如今盛行的微服务架构中，很多时候druid所在的服务里并不提供web服务，这就需要额外的配置。其实druid本身也提供了这种功能，只是wiki里没有说。 druid本身可以通过启用JMX端口来将监控数据传输到远端进行处理，具体做法是： 在启动服务的时候加上JVM启动参数（下文说） 在远端启用web服务，配置StatViewServlet，在initParam中指定JMX地址 1.1 JVM启动参数： -Djava.net.preferIPv4Stack=true-Dcom.sun.management.jmxremote-Djava.rmi.server.hostname=192.168.199.123-Dcom.sun.management.jmxremote.port=9876-Dcom.sun.management.jmxremote.authenticate=false-Dcom.sun.management.jmxremote.ssl=false 其中，-Djava.rmi.server.hostname一项指定了服务所在的IP地址，-Dcom.sun.management.jmxremote.port一项指定了JMX端口。 1.2 远程web工程Servlet配置在web.xml里添加如下配置： 123456789101112131415161718192021&lt;servlet&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt; &lt;!-- 远程访问JavaSE项目使用jmx连接 --&gt; &lt;init-param&gt; &lt;param-name&gt;jmxUrl&lt;/param-name&gt; &lt;param-value&gt;service:jmx:rmi:///jndi/rmi://192.168.199.123:9876/jmxrmi&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;loginUsername&lt;/param-name&gt; &lt;param-value&gt;admin&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;loginPassword&lt;/param-name&gt; &lt;param-value&gt;admin&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 如果想快速打包启动，不依赖外部web容器，可以采用SpringBoot，用嵌入式的web容器启动，原理也是一样。具体做法是： 创建Servlet： DruidStatViewServlet.java123456789101112131415161718192021package com.tansc.test.springboot.config.druid; import com.alibaba.druid.support.http.StatViewServlet; import javax.servlet.annotation.WebInitParam;import javax.servlet.annotation.WebServlet; /** * StatViewServlet */@SuppressWarnings("serial")@WebServlet(urlPatterns = "/druid/*", initParams=&#123; @WebInitParam(name="loginUsername",value="admin"),// 用户名 @WebInitParam(name="loginPassword",value="admin"),// 密码 @WebInitParam(name="jmxUrl",value="service:jmx:rmi:///jndi/rmi://192.168.199.123:9876/jmxrmi"), @WebInitParam(name="resetEnable",value="false")// 禁用HTML页面上的“Reset All”功能 &#125;)public class DruidStatViewServlet extends StatViewServlet &#123;&#125; 在启动类上加上注解@ServletComponentScan(&quot;com.tansc.test.springboot&quot;)以扫描Servlet。 1.3 查看监控数据上面的都配置好之后，启动服务，等服务启动成功之后，启动远端的web服务，然后访问web服务的/druid目录（与上面配置的匹配即可），例如在我本地起的：http://127.0.0.1:8080/druid 1.4 缺陷 这种做法是一对一的，也就是一个druid连接池实例必须对应一个StatViewServlet，一个StatViewServlet也只能队一行一个druid实例。 切换环境不方便 JMX重连不会成功 虽然远端会有重连机制，但是在服务重启之后，重连总是报Connection refused，只能将远端的web服务重启才能成功连上 1.5 改进对于上面提到的两点缺陷，可以用以下两个思路去改进： 动态创建servlet，模仿分布式服务的注册中心的形式来改造 Servlet本身不提供这样的API，但是应该是可以做到的，具体要继续探索。 使用配置文件 web.xml里面本身不能读取配置文件的值，但是可以通过继承StatViewServlet来实现。 需要分析源码（TODO） 1.6 性能损耗当远程的web服务启动并且在浏览器里访问统计页面之后，该服务的内存变化如下： 2. 持久化/自定义传输监控记录可以通过定制StatLogger实现，具体见其github的wiki：怎么保存Druid的监控记录 · alibaba/driud wiki 参考资料 配置StatFilter · alibaba/driud wikihttps://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatFilter 非web项目如何配置Druid监控 - 若鱼的专栏 - CSDN博客http://blog.csdn.net/goldenfish1919/article/details/68941237 Spring Boot 使用 Druid 和监控配置 - 小单的博客专栏 - CSDN博客http://blog.csdn.net/catoop/article/details/50925337 怎么保存Druid的监控记录 · alibaba/driud wikihttps://github.com/alibaba/druid/wiki/%E6%80%8E%E4%B9%88%E4%BF%9D%E5%AD%98Druid%E7%9A%84%E7%9B%91%E6%8E%A7%E8%AE%B0%E5%BD%95]]></content>
      <tags>
        <tag>druid</tag>
        <tag>连接池</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持续集成简述]]></title>
    <url>%2F2017%2F07%2F24%2FCI%2F</url>
    <content type="text"><![CDATA[1 概述互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration, CI）。持续集成也被认为是敏捷开发的最重要实践之一。 本文主要介绍持续集成的概念以及一些工具与实践。 2 概念图2.1 持续集成概念示意图之一 上图来源于谈谈持续集成，持续交付，持续部署之间的区别，这图很直观地描述了持续集成相关的概念之间的关系，与持续集成密切相关的概念还有持续交付、持续部署，因此在下文将会就这三个概念进行阐述。 2.1 持续集成维基百科的定义（Continuous integration - Wikipedia）： 在软件工程里，持续集成（Continuous Integration, CI）是指这样的一种实践：在一天里多次将所有开发人员的代码合并到一个共享的主干里，每次合并都会触发持续集成服务器进行自动构建，这个过程包括了编译、单元测试、集成测试、质量分析等步骤，结果只有两个：成功或者失败。如果得到失败的结果，说明有人提交了不合格的代码，这就能及时发现问题。 在瀑布模型中，软件的开发过程被分为以下几个阶段： 需求分析 系统设计 编码实现 测试 集成 部署 维护 而一般在实际的开发中，基本也就遵循这些步骤进行开发，大部分情况下，不会完全按照瀑布流的方式执行，但是这些步骤都是有的，无非就是在文档的落实、步骤的次序与侧重有所变化。其中，所谓的集成，在平时的开发过程中很少直接提到这个名词，其含义是（见：System integration - Wikipedia）： 将子系统的组件整合到一个系统中并且确保子系统的功能可以组合为一个系统的过程。 所以，所谓的『集成』就是在存在多个系统协作的情况下，将子系统集成为一个大系统的过程，这个概念与『集成测试』中的『集成』是同一个概念。但是有些文章在解释『持续集成』这个概念的时候，将其解释为『将代码集成到主干分支』，目前也没见到有人说这是错的。 如果只有一个系统，那么就不存在『系统集成』这一个步骤，但是『持续集成』这个做法还是可以应用其中的，因为『持续集成』的精髓不在于『集成』，而在于『持续』，而我所理解的『持续』，就是将一些重复的操作自动化，然后频繁地触发这个自动化过程。 所以，结合上面提到的瀑布模型的几个阶段，以及『持续集成』这个名字，图2.1应该改为这样： 图2.2 持续集成概念示意图之二 从上图中看来，持续集成应该至少包括以下几部分: 自动化构建 自动化测试 自动发布 图2.3 持续集成阶段示意图 每一次的构建与测试，都应该得到一个结果：通过或者不通过，开发人员应该都能看到每一次构建与测试的结果，得到不通过的结果时应该能马上修复相关的缺陷，这就需要有一种合适的反馈渠道。 2.1.1 自动化构建自动化构建包括以下过程： 将源码编译成为二进制码 打包二进制码 运行自动化测试 生成文档 生成分发媒体（例如：Debian DEB、Red Hat RPM或者Windows MSI文件） 自动化构建可以通过两类工具实现： 构建自动化软件（Build automation utility） 例如Make、Ant、Maven、Gradle，目的是通过编译等活动来生成构建产物（build artifact）。 构建自动化服务器（Build automation servers） 一般是基于web的工具，通过计划任务或者是事件触发的方式调用构建自动化软件。一个CI服务器就是一类构建自动化服务器。 2.1.2 自动化测试自动化测试是持续集成必不可少的一部分，基本上，没有自动化测试的持续集成，都很难称之为真正的持续集成。我们希望持续集成能够尽早的暴露问题，但这远非配置一个 Hudson/Jenkins服务器那么简单，只有真正用心编写了较为完整的测试用例，并一直维护它们，持续集成才能孜孜不倦地运行测试并第一时间报告问题。 测试自动化是使用特定的软件（独立于被测试的软件）来控制测试的执行以及比较实际输出与预期输出。测试自动化可以将某些重复但必要的任务自动化，或者执行某些难以手动执行的额外测试。 自动化测试还包括单元测试、集成测试、系统测试、验收测试、性能测试等，在不同的场景下，它们都能为软件开发带来极大的价值。 2.1.2.1 单元测试单元测试（Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。 通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到预期的工作目标，没有程序错误。 2.1.2.2 集成测试集成测试（Integration Testing，有时也叫Integration and Testing, I&amp;T）即对独立的软件模块组装起来看成是一个整体进行测试。集成测试一般在单元测试之后、系统测试之前进行。实践表明，有时模块虽然可以单独工作，但是并不能保证组装起来也可以同时工作。 集成与单元测试最大的区别是它需要尽可能的测试整个功能及相关环境，对于测试Web应用而言，通常有这么几步： 启动Web容器 部署待测试Web应用 以Web客户端的角色运行测试用例 停止Web容器 通常有三种手段实现集成测试： 大爆炸（Big Bang）将所有单元组合到一起一次性测试一遍。 自上而下（Top Down）先测试高层次的单元，然后逐渐测试低层次的单元。 自下而上（Bottom Up）先测试低层次的单元，然后逐渐测试高层次的单元。 2.2 持续交付图2.4 持续交付示意图 持续交付（Continuous Delivery, CD）是一种软件工程的手段，让软件在短周期内产出，确保软件随时可以被可靠地发布。其目的在于更快、更频繁地构建、测试以及发布软件。通过加强对生产环境的应用进行渐进式更新，这种手段可以降低交付变更的成本与风险。一个简单直观的与可重复的部署过程对于持续交付来说是很重要的。 2.2.1 与DevOps的关系持续交付与DevOps的含义很相似，所以经常被混淆。但是它们是不同的两个概念。DevOps的范围更广，它以文化变迁为中心，特别是软件交付过程所涉及的多个团队之间的合作（开发、运维、QA、管理部门等），并且将软件交付的过程自动化。另一方面，持续交付是一种自动化交付的手段，关注点在于将不同的过程集中起来，并且更快、更频繁地执行这些过程。因此，DevOps可以是持续交付的一个产物，持续交付直接汇入DevOps。 2.2.2 与持续部署的关系有时候，持续交付也与持续部署混淆。持续部署意味着所有的变更都会被自动部署到生产环境中。持续交付意味着所有的变更都可以被部署到生产环境中，但是出于业务考虑，可以选择不部署。如果要实施持续部署，必须先实施持续交付。 2.2.3 原则图2.5 持续交付流水线示意图 持续交付将部署流水线（deployment pipeline）这个老生常谈的概念看作一种简单的防错方法：一系列的确认。通过这些确认，一款软件必须遵循特定的路径来发布。每当有变更被提交到源码控制仓库中时，代码要首先进行编译（有必要的话），然后由构建服务器进行打包，接着由一些不同的技术来进行测试，最后才可以将代码标记为可发布的（releasable）。 在一个持续交付环境中工作时，习惯了漫长开发周期的开发人员或许需要改变他们心态。任何代码提交在任何时间点都可能会向客户发布，明白这一点是很重要的。对于在早期提交尚未准备好让用户使用的代码，类似功能开关这样的模式是很有用的。使用NoSQL可以消除持续交付工作流中的数据迁移和模式变更的步骤、手工操作步骤以及异常情况。对于代码隔离的其他有用的技术——例如代码分支——在持续交付工作流中并未过时，但是必须加以修改以适应持续交付的原则。例如，运行多个长生命周期的代码分支是不实际的，因为一个可发布的artifact（不知道这词对应什么中文）如果要经历流水线的所有阶段，它必须从一个单独的分支中构建而来。 2.3 持续部署图2.6 持续部署示意图 如图所示，持续部署与持续交付之间的差异就是前者将部署自动化了。 在持续交付的实践中，交付的目标是QA，但是实际上，软件最终是要交付到客户手上的。在SaaS领域里，持续部署采用得比较广泛，因为服务比较容易做到静默升级。 采用持续部署的前提是自动化测试的覆盖率足够高。 采用持续部署的好处是能减少运维的工作量，缩短新特性从开发到实际交付的周期。 3 代价与好处3.1 代价 构造自动测试用例会耗费大量的工作，而且要去覆盖不断增加的新功能点，也要随着代码的改动去修改测试用例。 测试被视为软件开发的一种最佳实践。无论是否采用持续集成，在一些方法论里——例如测试驱动开发——自动化测试都是必不可少的一部分。 采用持续集成的时候也可以不使用任何测试用例，但是在发布一个产品之前的质量保证（Quality Assurance）成本就会变得很高，因为一切都要频繁地采用人手操作。 要花费精力去部署一个构建系统，这有时候会比较复杂，难以灵活地修改 然而，有大量的开源的持续集成软件项目，选择很多 如果项目比较小，或者包含了未经测试的遗留代码，持续集成的价值就并不是那么大 持续集成所增加的价值依赖于测试的质量以及代码实际上的可测试程度。 团队规模大就意味着代码会非常频繁地提交到集成队列里，跟踪提交就会比较困难，并且排队进行构建会减慢每个人的工作，如果构建失败，整个开发团队必须停下手里的工作，立刻修复他们的错误。 但是持续集成是可以灵活变通的，不一定要在一天里多次构建，可以配置每天下班前半小时自动构建，有错误的话开发人员可以在下班前进行处理；或者每天凌晨自动构建，第二天早上开发人员一上班就能看到构建的结果报告，然后进行处理。 一天里有多个提交和合并，一个新功能的部分代码能轻易地推送上去，在新功能完成之前，集成测试都是不通过的。 3.2 好处 能快速发现错误和定位错误 避免在发布日期大家都在检查自己有冲突的版本，造成混乱 当单元测试不通过或者出现bug的时候，如果开发人员需要回滚代码，只会造成少量的改动丢失，因为集成是频繁的。 防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。 无论对于测试、demo还是发布的目的或需求，总是有一份当前的构建可用。 频繁的代码检查驱使开发人员编写模块化的、低复杂度的代码。 4 具体实践4.1 工具 名称 授权 价格 Git支持 Docker支持 自动测试 备注 Jenkins MIT 免费 不支持 不支持 需插件支持 GitLab CI MIT 免费 支持 支持 需自配测试服务 Phabricator Apache 2.0 免费 支持 Facebook出品 Travis CI 免费 支持 支持 不支持私有部署 Bamboo 收费 支持 支持 支持 Codeship 免费/收费 关联Github, GitLab 支持 不支持私有部署 CircleCI 免费/收费 关联Github 支持 支持大部分测试框架 不支持私有部署 Hudson Eclipse Public License 1.0 免费 需插件 需插件 其实这里的支持，意思应该是直接的支持，例如Jenkins，其实和git结合也很简单，通过脚本就可以实现。 5 参考资料 Maven实战（五）——自动化Web应用集成测试http://www.infoq.com/cn/news/2011/03/xxb-maven-5-integration-test 单元测试 - 维基百科https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95 Integration testing – Wikipediahttps://en.wikipedia.org/wiki/Integration_testing Continuous integration – Wikipediahttps://en.wikipedia.org/wiki/Continuous_integration Continuous integration | ThoughtWorkshttps://www.thoughtworks.com/continuous-integration 另一种声音：持续集成已死http://www.infoq.com/cn/news/2014/10/continuous-integration 持续集成是什么？http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html 25 best continuous integration tools as of 2017 - Slanthttps://www.slant.co/topics/799/~best-continuous-integration-tools Bamboo vs Jenkins Comparison | Atlassianhttps://www.atlassian.com/software/bamboo/comparison/bamboo-vs-jenkins 通过Docker容器运行持续集成/持续部署http://dockone.io/article/468 Continuous Integration, Deployment &amp; Delivery with Codeshiphttps://codeship.com 谈谈持续集成，持续交付，持续部署之间的区别http://blog.flow.ci/cicd_difference/ Continuous delivery – Wikipediahttps://en.wikipedia.org/wiki/Continuous_delivery Build automation – Wikipediahttps://en.wikipedia.org/wiki/Build_automation List of build automation software – Wikipediahttps://en.wikipedia.org/wiki/List_of_build_automation_software Software development process - Wikipediahttps://en.wikipedia.org/wiki/Software_development_process System integration - Wikipediahttps://en.wikipedia.org/wiki/System_integration Continuous Integration - Martin Fowlerhttps://martinfowler.com/articles/continuousIntegration.html#PracticesOfContinuousIntegration Integration Testing - Software Testing Fundamentalshttp://softwaretestingfundamentals.com/integration-testing/ Practical continuous deployment: a guide to automated software deliveryhttps://www.atlassian.com/blog/continuous-delivery/practical-continuous-deployment]]></content>
      <tags>
        <tag>软件工程</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一种RESTful接口的约定]]></title>
    <url>%2F2017%2F07%2F24%2FREST%2F</url>
    <content type="text"><![CDATA[1 概述1.1 撰写目的本文用于定义一种统一的RESTful接口设计方案，希望具有参考价值。本文所描述的方案比较学院派（死板），在上一家公司提出没有被采纳，在所了解到的有限的若干家声称采用了RESTful风格的公司里，发现他们也偏离甚远，而在书本以及网上大部分介绍RESTful的资料里，却都是这样的方案（URL命名风格、请求与响应的设计）。当然，他们这么做是有理由的，我也理解，这只是取舍问题。这篇文章其实是旧文了，2016年年底就已经写好，但是一直躺在电脑的硬盘里，不想白费了当时的功夫，因此在此公开。 1.2 为什么采用REST目的是为了服务端与客户端的解耦。SOA仅仅是从结构上将前后端分离，但是实际上数据逻辑还是没有实现解耦，服务端接口升级往往会影响客户端，两者的行为需要严格约定。而REST采用HTTP协议进行约定，客户端仅仅需要按照HTTP协议来理解服务端返回的数据，虽然与业务相关的数据结构还是需要约定，但是这确实进一步解耦了服务端与客户端。 另外，由于严格遵照HTTP协议进行数据返回，对于安全的接口，可以在返回的Header里设置缓存策略（接口安全性的概念在下文会解释）。 1.3 文档结构第二部分将阐述关于RESTful的若干个关键的概念，明确第二部分阐述的几个概念有利于设计、实现优雅规范的接口。 第三部分就URL命名的问题进行约定。 第四部分对消息实体进行约定。 第五部分对『向RESTful接口发起请求』进行阐述，约定要实现的方法，约定请求的头部和body的格式。 第六部分对接口的响应格式进行约定，包括响应消息的头部、状态码、JSON实体。 第七部分对版本控制的问题进行约定。 第八部分对RESTful接口的实现提出了实现工具的建议。 2 关键概念明确一些关键的概念是很重要的，虽然RESTful风格的API设计方案并没有统一的标准，但是还是需要符合一定的原则进行设计，否则就不能称为RESTful风格的API。因为许多人并没有对REST进行充分的了解就宣称自己的API是RESTful风格的API，以至于RESTful的提出者Fielding博士本人无法忍受，在2008年为此专门写了一篇博客『REST APIs must be hypertext-driven』，hypertext-driven与HATEOAS是同一个概念的不同表述，在下文会进行阐述。 2.1 RESTfulREST不是一种协议，也不是一种文件格式，更不是一种开发框架。它是一系列的设计约束的集合：无状态性、将超媒体作为应用状态的引擎等。REST是Representation State Transfer的缩写，中文是『表述性状态转移』，这里就涉及到资源的表述与状态两个概念。 简单地说，资源可以看作是服务器上存储的所有数据，资源的表述则是服务器对外提供的指向这些资源的方式，使用JSON、XML等均可，一个资源可以有多种表述；资源的状态则是服务器的数据存储状态，例如在t时刻，服务器中存储了m条数据，这时候客户端向服务端提交了一个创建数据的请求，服务器处理了此请求并创建了一条数据，那么在t+1时刻，服务器中就存储了m+1条数据，这两个时刻的资源状态就是不一样的，t时刻发生的请求导致了资源状态的改变。 2.2 HATEOASHypermedia As The Engine Of Application State，超媒体作为应用程序状态的引擎。这是REST区别于其他SOA风格的主要特点。客户端与服务端进行互动的时候，完全是通过服务端动态提供的超媒体进行的。除了对超媒体的一般理解，客户端不需要知道其他额外的知识。相反，在一些SOA接口的设计中，客户端与服务端的通信是要事先进行约定的，例如通过文档或者接口描述语言（Interface Description Language, IDL）。而基于HTTP协议的REST设计里，一般采用的就是请求与响应的Header来体现HATEOAS原则（具体请参考：https://en.wikipedia.org/wiki/HATEOAS）。这里也隐含这样一层含义：REST应尽可能地利用HTTP标准中现有的东西，例如Header、标准方法与状态码。 从标准的角度看，HTTP标准是一项RFC标准，世界认可；而其他自定义的SOA标准则可能是一项个人标准或者公司标准，最多是一项互联网草案（这对大部分公司来说都不可能），而一项标准越是被广为认可接受，其实现的通用性就越强。个人标准和公司标准都五花八门，这样对每一个标准都要参照其相关文档实现相应的行为逻辑是很麻烦的。 2.3 安全性一个方法被调用1次与被调用0次是一样的，此方法就是安全的，否则就是不安全的。例如，一个方法A仅仅是读取数据，并不创建或者修改数据，不论A方法被调用多少次，都不对数据记录产生任何影响，A方法是安全的。而假如有另一个方法B对数据进行删除，B方法被调用1次后，数据会被删除（或者标识位被修改），系统里的数据发生了变化，那么B方法是不安全的。 2.4 幂等性一个方法被同样地调用1次与被调用多次是一样的，即同样的输入会得到同样的输出，此方法就是幂等的，否则就不是幂等的。 2.3节中A方法与B方法都是幂等的，一个安全的方法一定是幂等的，一个幂等的方法不一定是安全的。 假设一个方法C对某个全局计数器执行自增操作并写入数据库，每次调用C方法都会对系统数据产生影响，那么C方法就不是幂等的。 3 URL命名URL用于标识资源，因此URL应该以名词进行命名，例如/users, /users/children等。 一般URL会内嵌参数，例如要获取id为313的user的信息，那么URL应该为/users/313，前面的user采用复数，如果要列出其所有后代，则URL应为/users/313/children，children为复数形式，如果要获取其id为499的后代，则URL应为/users/313/children/499 4 消息实体消息实体，就是请求和响应消息中的entity-body（也称为body），消息实体采用JSON字符串格式。 5 请求5.1 方法使用HTTP标准定义的请求方法。 5.1.1 get获取资源，单个参数一般写在URL上，多个参数则作为query parameter附在URL后面，例如： 单个参数：/user/123, 表示id为123的user 多个参数：/user?name=tom&amp;phone=13787890987&amp;gender=male get方法应为幂等的，并且不对数据记录产生影响。对于汉字与特殊字符，应该进行urlencode。 5.1.2 post创建资源，请求的headers里设置Content-type为application/json，参数为json类型。 根据约定，在创建成功之后，返回的状态码应该是201（Created），并且在response的Header里设置Location为新创建的资源的URL，例如，创建了一个新的user，该user创建后id为888，那么Header里应该设置Location为/users/888，当然，这应该是一个完整的URL，这里只是给出了一个相对路径的URI以作为说明。返回了这些数据后，客户端可以自定义后续行为，或者查看创建后的user，或者刷新当前的user列表，这些行为服务端并不关心。 如果重复提交了相同的数据，第一次应该返回201，以后则应返回409（Conflict），并且在response的Header里设置Location指向已经存在的资源，说明冲突的来源。 5.1.3 put更新资源，对现有资源进行修改，请求的headers与post一样，参数也是。此方法应该是幂等的。 5.1.4 delete删除资源。此方法应是幂等的。 5.2 HeaderContent-type应设为application/json。 另外应设置一个version，指明所使用的接口版本。这不属于HTTP协议中的一部分，是自定义的，出于版本控制的考量，具体见第七章。 5.3 body采用JSON字符串，具体的结构有待商定，这不属于HTTP协议的一部分，是自定义的。 这里主要放置业务相关的数据。 借用一篇10年前的文章的一张图： 6 响应6.1 Header根据响应的状态码不同，相应地设置头部，具体见下一节。 但是在我所了解的公司里，做法都是统一返回200，然后在返回的JSON字符串里设置消息码。我是不能理解的。据一位前端同学说，前端代码接收到了请求以后，不方便获取Http状态码。其实我也写过前端，不深入，但是一些基本的知识还是有的，我觉得这并不难做到，估计是他的代码封装的时候没有考虑到这一点，现在要改比较麻烦，所以不想大动干戈、伤筋动骨。 6.2 状态码 状态码 语义 使用场景 200 OK 正常返回消息，什么问题也没有 201 Created 创建资源成功，Header里应设置Location指向新创建的资源 202 Accepted 请求已被接收，但是处理过程较长，不能马上返回结果 304 Not Modified 没有任何修改发生 401 Unauthorized 缺乏权限，指已经登录但是缺乏请求这个资源的权限 403 Forbidden 拒绝访问，可用于未登录时拦截返回的状态码，此时Header里应设置Location为登录页面的URL 404 Not Found 不存在所请求的资源 406 Not Acceptable 请求没有被接收，参数约束校验不通过，或者其他业务类型的错误都可以返回这个状态码，response的body里应有表示错误信息的JSON实体。 409 Conflict 请求的资源有冲突，例如多次提交一样的创建请求，response的Header里应设置Location为产生冲突的资源的URL 500 Internal Server Error 服务器的非业务类错误，response的body里应有表示错误信息的JSON实体 6.3 body采用JSON字符串。JSON的结构分为两种：成功、失败。 一般而言，只有返回200的时候才需要读取成功的JSON，只有返回406和500的时候才需要读取失败的JSON，对于其他的状态码，客户端不需要服务器提供额外的消息。 对于成功的JSON，里面应该只包含一个result对象，而失败的JSON应该使用这样的结构： 1234567&#123; error: &#123; code: xxx, message: "xxx", data: &#123;...&#125; &#125;&#125; 失败的JSON只有一个error对象，包含错误码、消息及相关数据，message应该是直接可读的消息，客户端毋需理解发生了什么错误，客户端只需将消息展示出来即可。在收到406的时候，客户端只需知道发生的错误是由客户端造成的即可，具体是什么类型并不需要知道，将消息直接展示出来，让使用的人知道是什么即可，所以message应该是人类可以理解的文本。同理，收到500的时候，只需知道这个错误是服务端的问题即可，客户端也毋需知道具体的错误类型，最多就将错误码和消息展示出来，让使用者有反馈的依据即可。 7 版本控制考虑到接口有可能升级，升级的类型有几种： 新增功能接口 原有接口返回数据增加字段 现有接口返回数据变更现有字段格式或删除现有字段 现有接口变更业务逻辑 删除接口 其中，前两种升级并不会影响客户端，因此毋需处理。而后面三种会导致使用旧接口的客户端不能正常工作。 一般服务端升级与客户端升级都不是同步的，客户端升级往往会滞后，因此在服务端升级后应该保留旧版本的接口继续运行一段时间，让未升级的客户端可以继续工作一段时间，同时可以上线新版本的客户端。过一段时间后再将旧版本的接口下线。 而版本控制应该是向下兼容的，即假设当前版本是1.2，如果客户端请求1.3版本的服务，应当用当前版本提供服务。如果没有注明请求的版本号，应当提供当前版本的服务。 一般情况下，客户端请求需要带版本号，但是服务端并不需要对此进行处理，除非是同时运行新旧版本的同一个接口，才需要做差异处理。 8 实现工具8.1 Spring HATEOASSpring HATEOAS可以很方便地与Spring MVC结合来开发RESTful接口。具体参照其文档：http://docs.spring.io/spring-hateoas/docs/0.20.0.RELEASE/reference/html/#fundamentals.jaxb-json 9 缺陷其实这个方案基本就是网上一些被大部分人认可的做法的汇总，但是缺乏细节，例如分页，但是其实这些可以灵活变通，例如在查询字符串里加上分页参数。《一次无后端的供应链系统开发实践 (上篇)： 前后端分离的 Restful 接口设计》这篇文章的设计就比较全面，但是两者考量的问题范畴不同，他这个是serverless的设计，将业务逻辑都压在前端，后端仅仅作为前端与数据源之间的代理（数据源、客户端都在自己控制范围内的话其实没必要这样搞），这样的话，接口要表达的逻辑就比较复杂，而本文还是从传统的抽象思想去考虑，逻辑都在后端封装，因此接口并不需要表达多么复杂的逻辑。 10 参考文献当时写的时候没记下来，所以就不列出来了，在此不保证来源的权威性，请读者自行鉴别。^_^]]></content>
      <tags>
        <tag>REST</tag>
      </tags>
  </entry>
</search>