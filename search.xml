<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM加载、启动和初始化]]></title>
    <url>%2F2018%2F03%2F10%2Fjvm-loading-linking-initializing%2F</url>
    <content type="text"><![CDATA[0 概述这实际上是《The Java&reg; Virtual Machine Specification - Java SE 8 Edition》中第五章内容（Loading, Linking, and Initializing）的部分翻译。主要目的是整理阅读笔记，让我自己看得明白，在这个前提下，尽量让别人看得明白，如果读者觉得我写得很混乱，还请自行阅读原文，不便之处敬请见谅。如有错误，还请指正（拉到页面底部点击『联系我』就可以发邮件给我）。 阅读本文内容需要先对java的class文件结构有所了解。如果尚不了解，不妨参考我的另一篇博文 Java class文件格式 加载是这样一个过程：寻找一个特定名称的class或者interface的二进制表达形式（binary representation），然后从这个二进制表达形式中创建出一个class或者interface。 链接是这样一个过程：取得class或者interface，然后将其结合到JVM的运行时状态，使得它可以被执行。 初始化一个class或者interface的过程就是执行这个class或者interface的初始化方法&lt;clinit&gt;的过程。 1 运行时常量池（Run-Time Constant Pool）在class或interface被创建的时候，用二进制形式的class文件中的constant_pool表来构造运行时常量池。运行时常量池中的所有引用最初都是符号引用。运行时常量池中的符号引用来自二进制表达形式中的以下结构： Symbolic Reference to Structure in class file class CONSTANT_Class_info field CONSTANT_Fieldref_info class method CONSTANT_Methodref_info interface method CONSTANT_InterfaceMethodref_info method handle CONSTANT_MethodHandle_info method type CONSTANT_MethodType_info call site specifier CONSTANT_InvokeDynamic_info 另外，某些不是符号引用的运行时值则来自constant_pool表中的以下结构： 字符串字面量 CONSTANT_String_info 运行时常量值 CONSTANT_Integer_info CONSTANT_Float_info CONSTANT_Long_info CONSTANT_Double_info constant_pool里剩下的结构则只会被间接使用： CONSTANT_NameAndType_info CONSTANT_Utf8_info 2 JVM启动JVM通过使用引导类加载器（bootstrap class loader）创建初始类来启动，初始类的指定方式与实现相关。 然后，JVM链接初始类，初始化它，并调用public static void main(String[])方法。此方法的调用将驱动所有进一步的执行。执行构成 main 方法的JVM指令可能会导致附加类和接口的链接（链接之后进而创建），以及调用其他方法。 在JVM的实现中，初始类可以作为命令行参数提供。或者， JVM的实现可以提供一个初始类来设置类加载程序，然后加载一个应用程序。可以选择其他初始类，只要它们与前一段中给出的规范一致即可。 3 创建和加载（Creation and Loading） 符号约定class或者interface $C$ 用其类名 $N$ 来表示，其创建过程由另一个class or interface $D$ 触发，$D$通过运行时常量池引用$C$。class or interface的创建也可以通过$D$调用Java SE平台的特定class libraries中的方法来触发，例如反射。 如果$C$不是数组类，则通过使用class loader加载$C$的二进制表达来创建。 数组类没有外部的二进制表达，由JVM来创建，而不是class loader。 类加载器 $L$可以通过以下两种方式来创建$C$： 直接定义$C$ 委托给另一个class loader 如果$L$委托了另一个class loader来加载$C$，则说$L$启动了$C$的加载（$L$ initiates loading of $C$），或者等价地说，$L$是$C$的initiating loader。$N^L$ 表示由$L$ initiates loading的$C$。 如果$L$直接创建$C$，则我们说$L$定义了$C$（$L$ defines $C$），或者等价地说，$L$是$C$的 defining loader。&lt;$N, L$&gt; 表示由$L$ defines的$C$。同时，$L$也是$C$的initiating loader。 3.1 用Bootstrap Class Loader加载下面的步骤用于加载、从而创建由$N$表示的、非数组类型的类或者接口$C$。 首先，JVM判断bootstrap class loader是否已经被标记为由$N$表示的类或接口的initiating loader。如果是，这个类或者接口就是$C$，后续没有创建过程。 否则，JVM将$N$作为参数来调用bootstrap class loader的方法，用平台依赖的方式来搜索给出的$C$的表达形式。 通常，类或接口会使用分层文件系统中的文件来表达，并且其名称会编码在文件的路径名（pathname）中。 这个阶段需要检查以下错误： 如果找不到给出的$C$的表达形式，抛出ClassNotFoundException 然后，JVM尝试使用加载算法，从给出的表达形式中取得$N$表示的类，将结果作为$C$。 3.2 用User-defined Class Loader加载下面的步骤用于使用用户定义的类加载器（user-defined class loader） $L$加载、从而创建由$N$表示的、非数组类型的类或者接口$C$。 首先，JVM判断$L$是否已经被标记为由$N$表示的类或接口的initiating loader。如果是，这个类或者接口就是$C$，后续没有创建过程。 否则，JVM调用$L$的loadClass(N)方法，这个调用的返回值就是创建后的类或接口$C$。 然后JVM将$L$记录为$C$的initiating loader。 当使用$N$来调用$L$的loadClass方法时，$L$必须执行以下两个操作之一来加载$C$： $L$可以创建一个byte数组，这个数组表达了$C$的ClassFile结构；然后它必须调用ClassLoader类的defineClass方法，执行这个方法使得JVM用$L$使用加载算法从byte数组中取得$C$。 $L$可以将加载过程委托给另一个类加载器$L’$，将参数$N$直接或者间接地传给$L’$的方法调用（一般是loadClass方法）。方法调用的结果是$C$。 在上述两个步骤中，无论处于任何原因无法加载$N$所表示的类或接口时，都必须抛出ClassNotFoundException。 3.3 创建数组类（Array Classes）下面的步骤用于使用类加载器$L$来加载、从而创建由$N$表示的、数组类型的类$C$。 如果$L$已被记录为与$N$相同的组件类型（component type）的数组类的initiating loader，则该类为$C$，并且不需要再进行任何数组类创建。 否则，执行下面的步骤来创建$C$： 如果组件类型是引用类型（reference type），则使用$L$递归地应用本节的算法，以加载、从而创建$C$的组件类型； JVM使用指定的组件类型和维数创建一个新的数组类。 如果组件类型是一个引用类型，$C$会被标记为 『已被组件类型的defining class loader定义了』（having been defined by the defining class loader of the component type）。否则，$C$会被标记为『已被bootstrap class loader定义了』（having been defined by the bootstrap class loader）。 无论如何，JVM都会将$L$记录为$C$的initiating loader。 如果组件类型是一个引用类型，那么这个数组类的可见性（accessibility）和组件类型一致，否则可见性为public 3.4 加载的约束在class loader出现的时候，确保类型安全链接要特别小心。有可能存在这样一种情况：两个不同的class loader触发了由$N$表示的class or interface的加载，而$N$在每个class loader里可能表示了不同的class or interface。 （TBD） 3.5 从class文件表达形式中获得Class将一个非数组类型的class或者interface $C$ 记为 $N$，下面是用loader $L$从class文件格式中加载$C$为Class对象的步骤： JVM判断$L$是否已经被标记为$N$的initiating loader，如果是，创建过程将不可用，并且抛出LinkageError 否则，JVM尝试解析给出的表达。但是，给出的表达不一定是$C$的一个有效的表达。这个加载阶段必须检查以下错误： 如果给出的表达形式不是ClassFile结构，抛出ClassFormatError 否则，如果给出的表达不在支持的版本范围内（major version和minor version），抛出UnsupportedClassVersionError 否则，如果给出的表达不是类名$N$的实际表达，抛出NoClassDefFoundError或者其子类 如果$C$有直接父类，就用Class and Interface Resolution算法来解析出$C$到其直接父类的符号链接。 这个阶段要检查以下错误： 如果其直接父类实际上是一个interface，抛出IncompatibleClassChangeError 否则，如果$C$任意父类是$C$本身，抛出ClassCircularityError 如果$C$有任何直接父接口，则使用 Class and Interface Resolution 算法来解析出$C$到其直接父接口的符号链接。 这个阶段要检查以下错误： 如果其直接父接口实际上不是一个interface，抛出IncompatibleClassChangeError 如果$C$的任何一个父接口是$C$本身，抛出ClassCircularityError JVM将$C$标记为拥有$L$作为其defining class loader，并且标记$L$是$C$的initiating loader 4 链接（Linking）链接一个class或者interface包括验证和准备阶段，涉及到的对象有： 该class或interface本身 其直接父类 其直接父接口 如果这是数组类型，还涉及其元素类型 解析class或interface中的符号链接是链接阶段可选的一部分。 该规范允许实现的灵活性，以便在链接活动（以及由于递归、加载）发生时，只要保持以下所有属性： 一个class或interface在链接前要被完全加载 一个class或interface在初始化前要被完全验证 程序执行的一些操作可能直接或间接地要求链接涉及错误的class或interface，当这些错误被检测到时，必须在发生这些操作的地方抛出这些错误。 例如，一个JVM实现可能选择在使用到一个class或interface的时候才去解析其中的每个符号链接（懒加载或者延迟加载，”lazy” or “late” resolution），或者在验证class的时候一次性解析其中所有的符号链接（”eager” or “static” resolution）。这意味着在某些实现中，在class或interface初始化之后还有可能继续执行解析过程。无论采用哪种策略，在解析期间检测到的任何错误都必须在程序中的使用对class或interface的符号引用的地方抛出，不论是直接还是间接地使用到。 由于链接阶段涉及到新数据结构的分配（allocation），有可能因OutOfMEmoryError而失败。 4.1 验证（Verification）验证阶段确保了class或interface的二进制表达在结构上是正确的。验证阶段有可能引起其他类或接口被加载，但是不需要导致它们被验证或者准备。 如果class或interface的二进制表达不满足The class File Format - Constraints on Java Virtual Machine Code中列出的静态约束或结构型约束，那么在程序中导致class或interface被校验的地方必须要抛出VerifyError。 如果因为抛出了LinkageError（或子类）实例错误导致JVM尝试验证class或interface失败，则随后尝试验证class或interface始终会失败，并抛出相同的错误 作为初步验证尝试的结果。 4.2 准备（Preparation）准备阶段包括创建class or interface的static fields，并初始化默认值。这个过程不需要执行任何JVM代码。静态字段的显式初始值设定是作为初始化的一部分执行，而不是准备阶段。 在class or interface $C$ 的准备阶段，JVM有以下约束： 令$L_1$为$C$的defining loader，$m$为$C$中覆盖自父类或者父接口&lt;$D, L_2$&gt;的方法，对于每个$m$，令其返回值为$T_r$，形参为$T_{f_1},…,T_{f_n}$，那么： 如果$T_r$不是数组类型，令$T_0$为$T_r$；否则令$T_0$为$T_r$的元素类型； 对于$i=1, …, n$，如果$T_{f_i}$不是数组类型，令$T_i$为$T_{f_i}$；否则令$T_i$为$T_{f_i}$的元素类型 则有：$$ {T_i}^{L_1} = {T_i}^{L_2}, i=0, …, n $$ 更进一步的情况，如果$C$实现了父接口&lt;$I, L_3$&gt;中的方法$m$，但是$C$没有声明方法$m$，但是$C$的父类&lt;$D, L_2$&gt;声明了方法$m$的实现，则有以下约束： $m$的返回类型记为$T_r$，$m$的形参类型记为$T_{f1}, …, T_{fn}$，则：如果$T_r$不是数组类型，令$T_0$为$T_r$，否则令$T_0$为$T_r$的元素类型（element type）。对于所有$i=0, …, n$：如果$T_{fi}$不是数组类型，则$T_i$为$T_{fi}$，否则$T_i$为$T_{fi}$的元素类型。那么有$$ {T_i}^{L_2}={T_i}^{L_3}, i=0, …, n $$ 4.3 解析（Resolution）以下JVM指令对运行时常量池做了符号引用，执行任何这些指令都需要解析其符号引用：anewarray, checkcast, getfield, getstatic, instanceof, invokedynamic, invokeinterface, invokespecial, invokestatic, invokevirtual, ldc, ldc_w, multianewarray, new, putfield, and putstatic。 解析是从运行时常量池中的符号引用中动态确定具体值的过程。 解析某次出现的invokedynamic指令中的符号引用并不意味着该符号引用对于其它任何invokedynamic指令来说都被解析了。 对于其他指令来说，解析了某次出现的指令中的符号引用，确实意味着该符号应用对于其他任意的非invokedynamic指令来说都视为被解析了。 上文的意思是，由一个特定的invokedynamic指令确定的具体值是一个绑定到该特定invokedynamic指令的call site object。 （TBD） 下面部分阐述对一个class或interface $D$所引用的、尚在运行时常量池中的符号引用的解析过程。符号引用的类型不同，解析的细节也不同。 4.3.1 Class and Interface Resolution 类和接口解析 执行以下步骤来将$D$所引用的、未解析的符号引用解析为由$N$表示的class或interface $C$： 用$D$的defining class loader来创建由$N$表示的class或interface，细节在第三节（Creation and Loading）给出了。 在创建过程中抛出的任何作为失败结果的exception都可以作为解析过程的失败结果抛出。 如果$C$是数组类并且其元素类型是一个引用类型，则递归地调用上一小节（Class and Interface Resolution）中的算法来解析其元素类型的符号引用。 最后，检查$C$的访问授权： 如果$C$不能被$D$访问，抛出IllegalAccessError 这种情况举例：如果$C$这个类本来是被声明为public的，但是在$D$编译完之后被改为了非public了。 如果第1、2步成功执行但是第3步失败了，$C$仍然是有效和可用的。尽管如此，这个解析过程也是失败了的，并且$D$也禁止访问$C$。 4.3.2 Field Resolution 字段解析为了将$D$中未解析的符号引用解析为一个class或interface $C$中的一个字段（field），由字段引用（field reference）给出的到$C$的符号引用必须首先被解析（4.3.1）。 在解析字段引用的时候，字段解析（field resolution）首先尝试查找在$C$及其父类中引用的字段： 如果$C$使用了由字段引用指定的名称和描述符来声明一个字段，则字段查找（field lookup）成功。所声明的字段就是查找结果。 否则，对$C$的直接父接口递归地进行字段查找。 否则，如果$C$具有父类$S$，对$S$递归地进行字段查找。 否则，字段查找失败。 然后： 如果字段查找失败了，字段解析抛出NoSuchFieldError 否则，如果字段查找成功了，但是$D$不能访问该引用字段，抛出IllegalAccessError 否则，令实际声明该引用字段的class或interface为&lt;$E, L_1$&gt;，令$L_2$为$D$的defining loading 假设引用字段的类型为$T_f$，如果$T_f$不是数组类型，则$T$为$T_f$，如果$T_f$为数组类型，则$T$为$T_f$的元素类型。 JVM必须保证$T^{L_1}=T^{L_2}$的约束。 4.3.3 Method Resolution 方法解析为了将$D$中的符号引用解析为class $C$中的方法，由该方法引用给出的到$C$的符号引用要首先被解析（4.3.1）。 当解析一个方法引用时： 如果$C$是一个interface，抛出IncompatibleClassChangeError 否则，方法解析（method resolution）尝试在$C$及其父类中定位该引用方法： 如果$C$刚好声明了一个由该方法引用指定的名字的方法，并且声明的方法是一个signature polymorphic method，那么方法查找成功。描述符中声明的所有类名都被解析了。 The resolved method is the signature polymorphic method declaration. It is not necessary for C to declare a method with the descriptor specified by the method reference. signature polymorphic method这个概念在《The Java&reg; Virtual Machine Specification - Java SE 8 Edition》的 2.9 Special Methods 中定义： A method is signature polymorphic if all of the following are true: • It is declared in the java.lang.invoke.MethodHandle class. • It has a single formal parameter of type Object[]. • It has a return type of Object. • It has the ACC_VARARGS and ACC_NATIVE flags set. 否则，如果$C$用该方法引用指定的名字和描述符声明了一个方法，方法查找成功。 否则，如果$C$有父类，对$C$的直接父类递归地调用步骤2。 否则，方法解析尝试在$C$的父接口中定位引用方法： If the maximally-specific superinterface methods of C for the name and descriptor specified by the method reference include exactly one method that does not have its ACC_ABSTRACT flag set, then this method is chosen and method lookup succeeds. Otherwise, if any superinterface of C declares a method with the name and descriptor specified by the method reference that has neither its ACC_PRIVATE flag nor its ACC_STATIC flag set, one of these is arbitrarily chosen and method lookup succeeds. Otherwise, method lookup fails. A maximally-specific superinterface method of a class or interface $C$ for a particular method name and descriptor is any method for which all of the following are true: The method is declared in a superinterface (direct or indirect) of $C$. The method is declared with the specified name and descriptor. The method has neither its ACC_PRIVATE flag nor its ACC_STATIC flag set. Where the method is declared in interface I, there exists no other maximally- specific superinterface method of $C$ with the specified name and descriptor that is declared in a subinterface of $I$. The result of method resolution is determined by whether method lookup succeeds or fails: If method lookup fails, method resolution throws a NoSuchMethodError. Otherwise, if method lookup succeeds and the referenced method is notaccessible (§5.4.4) to $D$, method resolution throws an IllegalAccessError. Otherwise,let&lt;$E,L_1$&gt;be the class or interface in which the referenced method $m$ is actually declared, and let $L_2$ be the defining loader of $D$. Given that the return type of $m$ is $T_r$, and that the formal parameter types of $m$are $T_{f_1}, …, T_{f_n}$, then: If $T_r$ is not an array type, let $T_0$ be $T_r$; otherwise, let $T_0$ be the element type (§2.4) of $T_r$. For $i = 1, …, n$: If $T_{f_i}$ is not an array type, let $T_i$ be $T_{f_i}$; otherwise, let $T_i$ be the element type (§2.4) of $T_{f_i}$. The Java Virtual Machine must impose the loading constraints $T^{L_1} = T^{L_2}$ for $i = 0, …, n$ (§5.3.4). When resolution searches for a method in the class’s superinterfaces, the best outcome is to identify a maximally-specific non-abstract method. It is possible that this method will be chosen by method selection, so it is desirable to add class loader constraints for it. Otherwise, the result is nondeterministic. This is not new: The Java® Virtual Machine Specification has never identified exactly which method is chosen, and how “ties” should be broken. Prior to Java SE 8, this was mostly an unobservable distinction. However, beginning with Java SE 8, the set of interface methods is more heterogenous, so care must be taken to avoid problems with nondeterministic behavior. Thus: Superinterface methods that are private and static are ignored by resolution. This is consistent with the Java programming language, where such interface methods are not inherited. Any behavior controlled by the resolved method should not depend on whether the method is abstract or not. Note that if the result of resolution is an abstract method, the referenced class $C$ may be non-abstract. Requiring $C$ to be abstract would conflict with the nondeterministic choice of superinterface methods. Instead, resolution assumes that the run time class of the invoked object has a concrete implementation of the method. 4.3.4 Interface Method Resolution（TBD） 4.3.5 Method Type and Method Handle Resolution（TBD） 4.3.6 Call Site Specifier Resolution（TBD） 4.4 访问控制（Access Control）当且仅当以下都为真时，class或interface $C$对class或interface $D$来说是可访问的： $C$为public； $C$和$D$是同一个运行时包（run-time package）的成员。 当且仅当以下都为真时，一个字段或方法$R$对class或interface $D$来说是可访问的： $R$为public； $R$为protected并且在类$C$中被声明，同时$D$是$C$的子类或者是$C$本身。更进一步，如果$R$不是static的，指向$R$的符号引用必须包含指向类$T$的符号引用，这个$T$是$D$的子类或者是$D$的父类或者是$D$本身； $R$是protected的，或者具有默认的访问级别（即没有显式声明访问修饰符，非public、非protected、非private），并且和$D$是同一个运行时包（run-time package）的成员； $R$是private的并且在$D$里声明。 上述访问控制的讨论省略了调用protected方法或者访问protected字段的目标的相关限制（目标必须是$D$或者是$D$的子类型）。这种约束是验证阶段的一部分，不是链接时的访问控制。 4.5 覆盖（Overriding）有$C$类中声明的实例方法$m_C$和$A$类中声明的另一个实例方法$m_A$，当$m_C$和$m_A$一样或者下列条件都为真时，我们说$m_C$覆盖了$m_A$： $C$是$A$的子类 $m_C$和$m_A$具有同样的名称和描述符 $M_C$没有标记为ACC_PRIVATE 以下其中一个为真： $m_A$被标记为ACC_PUBLIC；或者被标记为ACC_PROTECTED；或者都没有标记为ACC_PUBLIC、ACC_PROTECTED、ACC_PRIVATE并且$A$和$C$属于同一个运行时包。 $m_C$覆盖了方法$m’$（$m’$与$m_C$和$m_A$都不同），而$m’$覆盖了$m_A$ 5 初始化（Initialization）（TBD） 6 绑定本地方法实现（Binding Native Method Implementations）绑定是这样一个过程：一种用Java以外的语言编写的、实现本地方法的函数被集成到JVM中以便执行。 虽然这个过程通常被称为链接，但术语『绑定』在这个规范中用来避免与JVM的类或接口链接混淆。 7 JVM Exit某个线程调用了Runtime或System类的exit方法或者Runtime类的halt方法、并且exit或halt操作得到了安全管理器（security manager）的准许时，JVM退出。 另外，JNI（Java Native Interface）规范描述了当JNI Invocation API被用于加载和卸载JVM时JVM的终止。 Reference The Java&reg; Virtual Machine Specification - Java SE 8 Edition]]></content>
      <tags>
        <tag>JVM, Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java class文件格式]]></title>
    <url>%2F2018%2F03%2F10%2Fjava-class-file-format%2F</url>
    <content type="text"><![CDATA[0 概述这实际上是《The Java&reg; Virtual Machine Specification - Java SE 8 Edition》中第四章内容（The class File Format）的部分翻译。主要目的是整理阅读笔记，让我自己看得明白，在这个前提下，尽量让别人看得明白，如果读者觉得我写得很混乱，还请自行阅读原文，不便之处敬请见谅。如有错误，还请指正（拉到页面底部点击『联系我』就可以发邮件给我）。 每一个class文件都包含了一个单独的class或者interface的定义。尽管一个class或者interface并不是有一个以文件形式存在的外部表达，但是下面还是通俗地将class或interface的任何有效表达称为类文件格式（the class file format）。 一个类文件由一个8位字节流组成。 所有的16位，32位和64位量分别通过读取2、4、8个连续的8位字节来构造。 多字节数据项总是以big-endian顺序存储，其中高字节排在第一位。 在Java SE平台中，此格式由接口java.io.DataInput和java.io.DataOutput以及类如java.io.DataInputStream和java.io.DataOutputStream支持。 本章定义了自己的一组表示类文件数据的数据类型： 类型u1，u2和u4分别表示一个无符号的一个，两个或四个字节数量（即1 byte、2 byte和4 byte）。 在Java SE平台中，这些类型可以通过接口java.io.DataInput的readUnsignedByte，readUnsignedShort和readInt等方法读取。 1 ClassFile结构一个class文件包含一个单独的ClassFile结构：123456789101112131415161718ClassFile &#123; u4 magic; u2 minor_version; u2 major_version; u2 constant_pool_count; cp_info constant_pool[constant_pool_count-1]; u2 access_flags; u2 this_class; u2 super_class; u2 interfaces_count; u2 interfaces[interfaces_count]; u2 fields_count; field_info fields[fields_count]; u2 methods_count; method_info methods[methods_count]; u2 attributes_count; attribute_info attributes[attributes_count];&#125; ClassFile结构中的各个item含义如下： 1.1 magic魔法数字，用于标识class文件格式，固定为0xCAFEBABE 1.2 minor_version, major_versionminor_version和major_version组合到一起，决定了class文件格式的版本。 假设class文件的major_version为$M$，minor_version为$m$，那么我们将class文件格式的版本记为$M.m$，因此，这个版本号可以按字典序排序，例如$1.5&lt;2.0&lt;2.1$。 一个JVM的实现可以支持的class文件格式版本记为$v$，当且仅当v落在连续区间 $Mi.0 \leq v \leq Mj.m$ 时成立。 JVM实现所遵循的Java SE平台的release level决定了其支持范围。 例如 Oracle对JDK release 1.0.2的JVM实现支持的class文件格式版本为$[45.0, 45.3]$ JDK release 1.1.* 支持$[45.0, 45.65535]$ 对于$k \geq 2$，JDK release $1.k$ 支持范围为$[45.0, 44+k.0]$ 1.3 constant_pool_countconstant_pool[]中的条目数量+1 1.4 constant_pool[]constant_pool是一个结构表，表示ClassFile结构及其子结构中引用的各种 字符串常量 类和接口名 字段名 其他常量。 每个constant_pool表项的格式由第一个“标记(tag)”字节表示。constant_pool表下标的取值范围是$[1, constant_pool_count)$ 1.5 access_flagsaccess_flags 项的值是用于表示对此类或接口的访问权限和属性的标志的掩码。 16bit Flag Name Value 二进制 十进制表示 Interpretation ACC_PUBLIC 0x0001 00000000 00000001 1 声明public ACC_FINAL 0x0010 00000000 00010000 16 声明final ACC_SUPER 0x0020 00000000 00100000 32 当调用invokespecial指令时，特殊对待父类方法 ACC_INTERFACE 0x0200 00000010 00000000 512 指明这是interface而非class ACC_ABSTRACT 0x0400 00000100 00000000 1024 声明abstract ACC_SYNTHETIC 0x1000 00010000 00000000 4096 声明synthetic，在源码中不存在 ACC_ANNOTATION 0x2000 00100000 00000000 8192 指明这是注解 ACC_ENUM 0x4000 01000000 00000000 16384 指明这是enum 1.6 this_classthis_class的值必须是constant_pool[]的有效下标。constant_pool[this_class]必须为CONSTANT_Class_info结构，表示了在此class文件中定义的类或者接口。 1234CONSTANT_Class_info &#123; u1 tag; u2 name_index;&#125; 1.7 super_classsuper_class的值也必须是constant_pool[]的有效下标。 对于类来说， 如果此值不是0， 则constant_pool[super_class]必须为CONSTANT_Class_info结构，表示了此class文件定义的类的直接父类。 如果此值为0，则此class文件必须表示Object类，这是唯一没有直接父类的类或者接口。 对于接口来说，没有规定。 1.8 interfaces_count指明了此类的直接父接口的数量。 1.9 interfaces[]里面的每个值都必须是constant_pool[]的有效下标。所指向的constant_pool中的条目必须为CONSTANT_Class_info结构，指明了其直接父接口。 1.10 fileds_count给出fields[]中field_info结构的数量。field_info结构表示了此类或接口所声明的所有field，包括class variables和instance virables（也就是静态变量和实例变量）。 1.11 fields[]所有值都必须为field_info结构，给出对变量的完整描述。只包含由此类或者接口声明的变量，不包括继承而来的。 1234567field_info &#123; u2 access_flags; u2 name_index; u2 descriptor_index; u2 attributes_count; attribute_info attributes[attributes_count];&#125; 1.12 methods_count给出methods[]中method_info结构的数量 1.13 methods[]所有值都必须为method_info结构。 如果ACC_NATIVE和ACC_ABSTRACT标志都没有在method_info里的access_flags中设置，实现此方法的JVM指令也要提供。 methods[]表达了此class or intreface声明的所有方法，包括实例方法、类方法、实例初始化方法和class or interface 初始化方法，不包括继承而来的方法。 1234567method_info &#123; u2 access_flags; u2 name_index; u2 descriptor_index; u2 attributes_count; attribute_info attributes[attributes_count];&#125; 1.14 attributes_countsize of attributes[] 1.15 attributes[]12345attribute_info &#123; u2 attribute_name_index; u4 attribute_length; u1 info[attribute_length];&#125; 2 The Internal Form of Names 2.1 Binary Class and Interface Namesclass文件结构中，class和interface的名字总是以一种全限定（fully qualified）的形式表达的，被称为binary names（JLS §13.1）。这些名字总是表达为CONSTANT_Utf8_info结构。 类和接口名称是从那些CONSTANT_NameAndType_info结构中引用的, 它们的名称是其描述符的一部分, 并且来自所有CONSTANT_Class_info结构 由于历史原因, 类文件结构中出现的binary names的语法不同于JLS §13.1中记录的二进制名称的语法。标识符（identifiers）构成了binary names，通常用ASCII码（.）分割各个标识符，在这种内部形式中，替换为了ASCII码（/）。标识符本身必须是未限定的名称（unqualified names）。 2.2 Unqualified Names 未限定的名称方法、field、本地变量和形式参数的名称都存储为unqualified names。 一个unqualified names必须包含至少一个Unicode码（Unicode code point），并且不能包含以下ASCII字符：., ;, [, /（即，句号、分号、左方括号和斜线）。 方法名的约束还要加上不能出现ASCII字符&lt;、&gt;（即左尖括号和右尖括号），例外方法为 &lt;init&gt; &lt;clinit&gt; 3 Descriptors 描述符描述符是用于表示field或者方法的字符串。 3.1 Grammer Notaion 语法符号（先定义用于描述描述符构成的语法）：描述符是使用语法指定的。语法是一组生产、 描述字符序列如何形成各种语法正确的描述符。 语法的终端符号以固定宽度字体显示。 非终结名称符号以斜体类型显示。 非终结名称的定义由定义的非终结名称的名称引入，后跟冒号。 非终结名称的一个或多个可选定义随后将跟随后续行。 生产右侧的语法 {x} 表示 x 的零个或多个匹配项。 生产右侧的短语 (one of) 表示以下行或行上的每个终端符号都是可选的定义。 3.2 Field Descriptors field descriptors的说明： FieldType term Type Interpretation B byte signed byte C char Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16 D double double-precision floating-point value F float single-precision floating-point value I int integer J long long integer L ClassName ; reference an instance of class ClassName S short signed short Z boolean true or false [ reference one array dimension 例子： 一个Object实例表示为：Ljava/lang/Object; 一个多维数组double[][][]表示为[[[D 3.3 Method Descriptors 方法描述符 例子： 1 1Object m(int i, double d, Thread t) &#123;...&#125; 描述符为：(IDLjava/lang/Thread;)Ljava/lang/Object; 4 The Constant PoolJava 虚拟机指令不依赖于类、接口、类实例或数组的运行时布局。相反, 指令指的是 constant_pool 表中的符号信息。 constant_pool中的所有条目都具有以下的一般结构： 1234cp_info &#123; u1 tag; u1 info[]; &#125; 其中，tag用于指示cp_info条目的类型，info数组的内容随tag的值而变化。每个标记字节必须后跟两个或多个字节, 以提供有关特定常量的信息。tag的取值范围如下： Constant Type Value CONSTANT_Class 7 CONSTANT_Fieldref 9 CONSTANT_Methodref 10 CONSTANT_InterfaceMethodref 11 CONSTANT_String 8 CONSTANT_Integer 3 CONSTANT_Float 4 CONSTANT_Long 5 CONSTANT_Double 6 CONSTANT_NameAndType 12 CONSTANT_Utf8 1 CONSTANT_MethodHandle 15 CONSTANT_MethodType 16 CONSTANT_InvokeDynamic 18 4.1 CONSTANT_Class_info1234CONSTANT_Class_info &#123; u1 tag; u2 name_index;&#125; tag的值为7，表示这是一个CONSTANT_Class，name_index必须是constant_pool的有效下标，指向的必须是一个CONSTANT_Utf8_info结构。也就是说指向了常量池中表示类名的字符串常量。类名表达为internal form，例如： int[][]表达为[[I Thread[]表达为[Ljava/lang/Thread; 4.2 CONSTANT_Fieldref_info, CONSTANT_Methodref_info和CONSTANT_InterfaceMethodref_info4.3 CONSTANT_String_info4.4 CONSTANT_Integer_info4.5 CONSTANT_Long_info4.6 CONSTANT_NameAndType_info4.7 CONSTANT_Utf8_info12345CONSTANT_Utf8_info &#123; u1 tag; u2 length; u1 bytes[length];&#125; 4.8 CONSTANT_MethodHandle_info4.9 CONSTANT_MethodType_info4.10 CONSTANT_InvokeDynamic_info5 Fields1234567field_info &#123; u2 access_flags; u2 name_index; u2 descriptor_index; u2 attributes_count; attribute_info attributes[attributes_count];&#125; attributes[]里面的每个item都必须是attribute_info结构 6 Methods1234567method_info &#123; u2 access_flags; u2 name_index; u2 descriptor_index; u2 attributes_count; attribute_info attributes[attributes_count];&#125; attributes[]里面的每个item都必须是attribute_info结构 7 Attributes12345attribute_info &#123; u2 attribute_name_index; u4 attribute_length; u1 info[attribute_length];&#125; The Code Attribute12345678910111213141516Code_attribute &#123; u2 attribute_name_index; u4 attribute_length; u2 max_stack; u2 max_locals; u4 code_length; u1 code[code_length]; u2 exception_table_length; &#123; u2 start_pc; u2 end_pc; u2 handler_pc; u2 catch_type; &#125; exception_table[exception_table_length]; u2 attributes_count; attribute_info attributes[attributes_count];&#125; max_stack给出在方法执行的任意地方操作数栈的最大深度 max_locals给出方法调用时本地方法表的最大容量 code[]给出了实现方法的JVM代码的实际字节（byte）。 8 Format Checking（TBD） 9 Constraints on Java Virtual Machine Code （TBD） 10 Verification of class Files （TBD） 10.1 Verification by Type Checking10.2 Verification by Type Inference11 JVM的限制 ClassFile结构中16-bit的constant_pool_count限制了per-class或者per-interface的常量池最多只有65535个条目（entries）。这对单个类或接口的总体复杂性起到了内部限制作用。 ClassFile结构中的fields_count限制了一个class or interface能声明的field数量不能超过65535。（不包括继承的） 方法数量限制同上。（methods_count） 直接父接口的数量限制同上（interfaces_count） 方法调用时创建的帧里面，本地变量表中的本地变量数量最多为65535，由Code attribute中的max_locals item所限制，以及由JVM指令集的16-bit本地变量索引所限制。其中，long和double类型视为两个本地变量 Code attribute中的max_stack item限制了frame中的操作数栈的大小为65535其中，long和double类型的操作数视为两个单元 method descriptor的定义限制了方法参数的数量最多为255其中，实例方法的this占了一个单元，long和double类型的会占两个单元 field和方法的名称、field和方法的descriptor以及其他string常量值（包括被ConstantValue attribute引用的）最多为65535个byte，由CONSTANT_Utf8_info结构中的16-bit无符号length item所限制 数组的维度最多为255，由multianewarray指令中的opcode dimensions的大小所限制 The number of dimensions in an array is limited to 255 by the size of the dimensions opcode of the multianewarray instruction and by the constraints imposed on the multianewarray, anewarray, and newarray instructions Reference The Java&reg; Virtual Machine Specification - Java SE 8 Edition]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Druid连接池监控的一次改造]]></title>
    <url>%2F2017%2F08%2F31%2Fdruid-monitor-remould%2F</url>
    <content type="text"><![CDATA[1. 背景druid本身提供了监控功能，具体在我另一篇博文《Druid连接池监控》里有介绍。当时提到有以下缺陷： 无法灵活监控多个目标 切换环境不方便 JMX重连不会成功 因此针对这些问题，对其进行改造。改造后的源码已经放在个人的github上：https://github.com/bungder/druid-aggregated-monitor 对应本文的版本，已经打了tag：https://github.com/bungder/druid-aggregated-monitor/releases/tag/0.0.1 对于在同一个工程里进行监控和展示的情况不进行考虑，具体原因见刚刚提到的博文。 2. 原理分析首先，监控数据的展示是通过com.alibaba.druid.support.http.StatViewServlet实现的，将其源码贴上来分析： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181package com.alibaba.druid.support.http;import java.io.IOException;import java.util.HashMap;import java.util.Map;import javax.management.MBeanServerConnection;import javax.management.ObjectName;import javax.management.remote.JMXConnector;import javax.management.remote.JMXConnectorFactory;import javax.management.remote.JMXServiceURL;import javax.servlet.ServletException;import com.alibaba.druid.stat.DruidStatService;import com.alibaba.druid.support.logging.Log;import com.alibaba.druid.support.logging.LogFactory;/** * 注意：避免直接调用Druid相关对象例如DruidDataSource等，相关调用要到DruidStatManagerFacade里用反射实现 * * @author sandzhang&lt;sandzhangtoo@gmail.com&gt; */public class StatViewServlet extends ResourceServlet &#123; private final static Log LOG = LogFactory.getLog(StatViewServlet.class); private static final long serialVersionUID = 1L; public static final String PARAM_NAME_RESET_ENABLE = "resetEnable"; public static final String PARAM_NAME_JMX_URL = "jmxUrl"; public static final String PARAM_NAME_JMX_USERNAME = "jmxUsername"; public static final String PARAM_NAME_JMX_PASSWORD = "jmxPassword"; private DruidStatService statService = DruidStatService.getInstance(); /** web.xml中配置的jmx的连接地址 */ private String jmxUrl = null; /** web.xml中配置的jmx的用户名 */ private String jmxUsername = null; /** web.xml中配置的jmx的密码 */ private String jmxPassword = null; private MBeanServerConnection conn = null; public StatViewServlet()&#123; super("support/http/resources"); &#125; public void init() throws ServletException &#123; super.init(); try &#123; String param = getInitParameter(PARAM_NAME_RESET_ENABLE); if (param != null &amp;&amp; param.trim().length() != 0) &#123; param = param.trim(); boolean resetEnable = Boolean.parseBoolean(param); statService.setResetEnable(resetEnable); &#125; &#125; catch (Exception e) &#123; String msg = "initParameter config error, resetEnable : " + getInitParameter(PARAM_NAME_RESET_ENABLE); LOG.error(msg, e); &#125; // 获取jmx的连接配置信息 String param = readInitParam(PARAM_NAME_JMX_URL); if (param != null) &#123; jmxUrl = param; jmxUsername = readInitParam(PARAM_NAME_JMX_USERNAME); jmxPassword = readInitParam(PARAM_NAME_JMX_PASSWORD); try &#123; initJmxConn(); &#125; catch (IOException e) &#123; LOG.error("init jmx connection error", e); &#125; &#125; &#125; /** * 读取servlet中的配置参数. * * @param key 配置参数名 * @return 配置参数值，如果不存在当前配置参数，或者为配置参数长度为0，将返回null */ private String readInitParam(String key) &#123; String value = null; try &#123; String param = getInitParameter(key); if (param != null) &#123; param = param.trim(); if (param.length() &gt; 0) &#123; value = param; &#125; &#125; &#125; catch (Exception e) &#123; String msg = "initParameter config [" + key + "] error"; LOG.warn(msg, e); &#125; return value; &#125; /** * 初始化jmx连接 * * @throws IOException */ private void initJmxConn() throws IOException &#123; if (jmxUrl != null) &#123; JMXServiceURL url = new JMXServiceURL(jmxUrl); Map&lt;String, String[]&gt; env = null; if (jmxUsername != null) &#123; env = new HashMap&lt;String, String[]&gt;(); String[] credentials = new String[] &#123; jmxUsername, jmxPassword &#125;; env.put(JMXConnector.CREDENTIALS, credentials); &#125; JMXConnector jmxc = JMXConnectorFactory.connect(url, env); conn = jmxc.getMBeanServerConnection(); &#125; &#125; /** * 根据指定的url来获取jmx服务返回的内容. * * @param connetion jmx连接 * @param url url内容 * @return the jmx返回的内容 * @throws Exception the exception */ private String getJmxResult(MBeanServerConnection connetion, String url) throws Exception &#123; ObjectName name = new ObjectName(DruidStatService.MBEAN_NAME); String result = (String) conn.invoke(name, "service", new String[] &#123; url &#125;, new String[] &#123; String.class.getName() &#125;); return result; &#125; /** * 程序首先判断是否存在jmx连接地址，如果不存在，则直接调用本地的duird服务； 如果存在，则调用远程jmx服务。在进行jmx通信，首先判断一下jmx连接是否已经建立成功，如果已经 * 建立成功，则直接进行通信，如果之前没有成功建立，则会尝试重新建立一遍。. * * @param url 要连接的服务地址 * @return 调用服务后返回的json字符串 */ protected String process(String url) &#123; String resp = null; if (jmxUrl == null) &#123; resp = statService.service(url); &#125; else &#123; if (conn == null) &#123;// 连接在初始化时创建失败 try &#123;// 尝试重新连接 initJmxConn(); &#125; catch (IOException e) &#123; LOG.error("init jmx connection error", e); resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR, "init jmx connection error" + e.getMessage()); &#125; if (conn != null) &#123;// 连接成功 try &#123; resp = getJmxResult(conn, url); &#125; catch (Exception e) &#123; LOG.error("get jmx data error", e); resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR, "get data error:" + e.getMessage()); &#125; &#125; &#125; else &#123;// 连接成功 try &#123; resp = getJmxResult(conn, url); &#125; catch (Exception e) &#123; LOG.error("get jmx data error", e); resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR, "get data error" + e.getMessage()); &#125; &#125; &#125; return resp; &#125;&#125; 首先，现在需要搞清楚的问题有： 配置信息是如何生效的 监控数据是怎么流动的 权限控制是怎样实现的 为什么重连会失败 逐个方法去看，init方法是初始化的，应该能找到『配置信息是如何生效的』的答案。里面调用了readInitparam方法来读取，而这个方法又调用了getInitParameter方法，进入方法后发现此方法是javax.servlet.GenericServlet里的，已经不是druid的代码，意味着读取参数是通过调用容器的api实现的，这个过程无法进行篡改。 这里只是读取参数值，还没使用，让我们一步步回退回init方法，在读取了参数值之后就调用initJmxConn方法，该方法初始化了与监控目标之间的JMX连接，是关键的地方。但是里面也没多少东西，主要就是根据url去获取连接，对于『为什么重连会失败』，应该也是一个切入点。但是一路点进去看都没发现有重试的机制。 接着往下看，剩下getJmxResult和process两个方法，其注释里已经讲得很明白了。可以发现，在process方法里有重连的机制，那么还是没搞清楚为什么无法重连成功。 在看完这个类之后，可以发现请求的调用链并没有体现出来，所以看它的父类ResourceServlet。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286/* * Copyright 1999-2011 Alibaba Group Holding Ltd. * * Licensed under the Apache License, Version 2.0 (the "License"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an "AS IS" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package com.alibaba.druid.support.http;import com.alibaba.druid.support.http.util.IPAddress;import com.alibaba.druid.support.http.util.IPRange;import com.alibaba.druid.support.logging.Log;import com.alibaba.druid.support.logging.LogFactory;import com.alibaba.druid.util.StringUtils;import com.alibaba.druid.util.Utils;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.HttpSession;import java.io.IOException;import java.util.ArrayList;import java.util.List;@SuppressWarnings("serial")public abstract class ResourceServlet extends HttpServlet &#123; private final static Log LOG = LogFactory.getLog(ResourceServlet.class); public static final String SESSION_USER_KEY = "druid-user"; public static final String PARAM_NAME_USERNAME = "loginUsername"; public static final String PARAM_NAME_PASSWORD = "loginPassword"; public static final String PARAM_NAME_ALLOW = "allow"; public static final String PARAM_NAME_DENY = "deny"; public static final String PARAM_REMOTE_ADDR = "remoteAddress"; protected String username = null; protected String password = null; protected List&lt;IPRange&gt; allowList = new ArrayList&lt;IPRange&gt;(); protected List&lt;IPRange&gt; denyList = new ArrayList&lt;IPRange&gt;(); protected final String resourcePath; protected String remoteAddressHeader = null; public ResourceServlet(String resourcePath)&#123; this.resourcePath = resourcePath; &#125; public void init() throws ServletException &#123; initAuthEnv(); &#125; private void initAuthEnv() &#123; String paramUserName = getInitParameter(PARAM_NAME_USERNAME); if (!StringUtils.isEmpty(paramUserName)) &#123; this.username = paramUserName; &#125; String paramPassword = getInitParameter(PARAM_NAME_PASSWORD); if (!StringUtils.isEmpty(paramPassword)) &#123; this.password = paramPassword; &#125; String paramRemoteAddressHeader = getInitParameter(PARAM_REMOTE_ADDR); if (!StringUtils.isEmpty(paramRemoteAddressHeader)) &#123; this.remoteAddressHeader = paramRemoteAddressHeader; &#125; try &#123; String param = getInitParameter(PARAM_NAME_ALLOW); if (param != null &amp;&amp; param.trim().length() != 0) &#123; param = param.trim(); String[] items = param.split(","); for (String item : items) &#123; if (item == null || item.length() == 0) &#123; continue; &#125; IPRange ipRange = new IPRange(item); allowList.add(ipRange); &#125; &#125; &#125; catch (Exception e) &#123; String msg = "initParameter config error, allow : " + getInitParameter(PARAM_NAME_ALLOW); LOG.error(msg, e); &#125; try &#123; String param = getInitParameter(PARAM_NAME_DENY); if (param != null &amp;&amp; param.trim().length() != 0) &#123; param = param.trim(); String[] items = param.split(","); for (String item : items) &#123; if (item == null || item.length() == 0) &#123; continue; &#125; IPRange ipRange = new IPRange(item); denyList.add(ipRange); &#125; &#125; &#125; catch (Exception e) &#123; String msg = "initParameter config error, deny : " + getInitParameter(PARAM_NAME_DENY); LOG.error(msg, e); &#125; &#125; public boolean isPermittedRequest(String remoteAddress) &#123; boolean ipV6 = remoteAddress != null &amp;&amp; remoteAddress.indexOf(':') != -1; if (ipV6) &#123; return "0:0:0:0:0:0:0:1".equals(remoteAddress) || (denyList.size() == 0 &amp;&amp; allowList.size() == 0); &#125; IPAddress ipAddress = new IPAddress(remoteAddress); for (IPRange range : denyList) &#123; if (range.isIPAddressInRange(ipAddress)) &#123; return false; &#125; &#125; if (allowList.size() &gt; 0) &#123; for (IPRange range : allowList) &#123; if (range.isIPAddressInRange(ipAddress)) &#123; return true; &#125; &#125; return false; &#125; return true; &#125; protected String getFilePath(String fileName) &#123; return resourcePath + fileName; &#125; protected void returnResourceFile(String fileName, String uri, HttpServletResponse response) throws ServletException, IOException &#123; String filePath = getFilePath(fileName); if (fileName.endsWith(".jpg")) &#123; byte[] bytes = Utils.readByteArrayFromResource(filePath); if (bytes != null) &#123; response.getOutputStream().write(bytes); &#125; return; &#125; String text = Utils.readFromResource(filePath); if (text == null) &#123; response.sendRedirect(uri + "/index.html"); return; &#125; if (fileName.endsWith(".css")) &#123; response.setContentType("text/css;charset=utf-8"); &#125; else if (fileName.endsWith(".js")) &#123; response.setContentType("text/javascript;charset=utf-8"); &#125; response.getWriter().write(text); &#125; public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String contextPath = request.getContextPath(); String servletPath = request.getServletPath(); String requestURI = request.getRequestURI(); response.setCharacterEncoding("utf-8"); if (contextPath == null) &#123; // root context contextPath = ""; &#125; String uri = contextPath + servletPath; String path = requestURI.substring(contextPath.length() + servletPath.length()); if (!isPermittedRequest(request)) &#123; path = "/nopermit.html"; returnResourceFile(path, uri, response); return; &#125; if ("/submitLogin".equals(path)) &#123; String usernameParam = request.getParameter(PARAM_NAME_USERNAME); String passwordParam = request.getParameter(PARAM_NAME_PASSWORD); if (username.equals(usernameParam) &amp;&amp; password.equals(passwordParam)) &#123; request.getSession().setAttribute(SESSION_USER_KEY, username); response.getWriter().print("success"); &#125; else &#123; response.getWriter().print("error"); &#125; return; &#125; if (isRequireAuth() // &amp;&amp; !ContainsUser(request)// &amp;&amp; !("/login.html".equals(path) // || path.startsWith("/css")// || path.startsWith("/js") // || path.startsWith("/img"))) &#123; if (contextPath.equals("") || contextPath.equals("/")) &#123; response.sendRedirect("/druid/login.html"); &#125; else &#123; if ("".equals(path)) &#123; response.sendRedirect("druid/login.html"); &#125; else &#123; response.sendRedirect("login.html"); &#125; &#125; return; &#125; if ("".equals(path)) &#123; if (contextPath.equals("") || contextPath.equals("/")) &#123; response.sendRedirect("/druid/index.html"); &#125; else &#123; response.sendRedirect("druid/index.html"); &#125; return; &#125; if ("/".equals(path)) &#123; response.sendRedirect("index.html"); return; &#125; if (path.contains(".json")) &#123; String fullUrl = path; if (request.getQueryString() != null &amp;&amp; request.getQueryString().length() &gt; 0) &#123; fullUrl += "?" + request.getQueryString(); &#125; response.getWriter().print(process(fullUrl)); return; &#125; // find file in resources path returnResourceFile(path, uri, response); &#125; public boolean ContainsUser(HttpServletRequest request) &#123; HttpSession session = request.getSession(false); return session != null &amp;&amp; session.getAttribute(SESSION_USER_KEY) != null; &#125; public boolean isRequireAuth() &#123; return this.username != null; &#125; public boolean isPermittedRequest(HttpServletRequest request) &#123; String remoteAddress = getRemoteAddress(request); return isPermittedRequest(remoteAddress); &#125; protected String getRemoteAddress(HttpServletRequest request) &#123; String remoteAddress = null; if (remoteAddressHeader != null) &#123; remoteAddress = request.getHeader(remoteAddressHeader); &#125; if (remoteAddress == null) &#123; remoteAddress = request.getRemoteAddr(); &#125; return remoteAddress; &#125; protected abstract String process(String url);&#125; 其中，service方法里有URL的判断，方法里有request和response，看上去就是流程的起点，但是一般我们写servlet都是从doGet和doPost入手的，这里面不知道做了什么封装，于是继续往父类去看，发现其父类是javax.servlet.http.HttpServlet，已经是J2EE定义的类了，我用的是tomcat容器，所以这个类由tomcat提供。里面有常见的doPost和doGet方法 可以看到，doGet和doPost方法默认都是不通的： 12345678910111213141516171819202122232425protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; String protocol = req.getProtocol(); String msg = lStrings.getString("http.method_get_not_supported"); if (protocol.endsWith("1.1")) &#123; resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg); &#125; else &#123; resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg); &#125;&#125;protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String protocol = req.getProtocol(); String msg = lStrings.getString("http.method_post_not_supported"); if (protocol.endsWith("1.1")) &#123; resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg); &#125; else &#123; resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg); &#125;&#125; 赶紧去看注释： 1234567891011121314151617181920212223242526272829303132333435/** * Called by the server (via the &lt;code&gt;service&lt;/code&gt; method) to * allow a servlet to handle a GET request. * * &lt;p&gt;Overriding this method to support a GET request also * automatically supports an HTTP HEAD request. A HEAD * request is a GET request that returns no body in the * response, only the request header fields. * * &lt;p&gt;When overriding this method, read the request data, * write the response headers, get the response's writer or... * /protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException&#123; //...&#125;/** * Called by the server (via the &lt;code&gt;service&lt;/code&gt; method) * to allow a servlet to handle a POST request. * * ... * * &lt;p&gt;When overriding this method, read the request data, * write the response headers... * */ protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //...&#125; 原来这些方法是由service方法调用的，并且需要自己覆盖，很符合我们一贯的经验。再看看service方法是怎么回事： 1234567891011121314151617181920212223242526272829303132/** * Receives standard HTTP requests from the public * &lt;code&gt;service&lt;/code&gt; method and dispatches * them to the &lt;code&gt;do&lt;/code&gt;&lt;i&gt;Method&lt;/i&gt; methods defined in * this class. This method is an HTTP-specific version of the * &#123;@link javax.servlet.Servlet#service&#125; method. There's no * need to override this method. * * @param req the &#123;@link HttpServletRequest&#125; object that * contains the request the client made of * the servlet * * @param resp the &#123;@link HttpServletResponse&#125; object that * contains the response the servlet returns * to the client * * @exception IOException if an input or output error occurs * while the servlet is handling the * HTTP request * * @exception ServletException if the HTTP request * cannot be handled * * @see javax.servlet.Servlet#service */protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //...&#125; 这个方法是请求的统一接收入口，然后将请求分发到doGet、doPost、doHead等对应标准HTTP请求方法的方法去。注释里特地说明了没有必要覆盖这个方法，druid的开发者很直接粗暴，不管你请求方法是什么，全部一刀切，反正这玩意儿要求不高。总之，现在我们知道了，service方法就是请求的入口，这样我们再回去看看com.alibaba.druid.support.http.ResourceServlet的service方法，通过这个方法应该就能理顺整个流程。 将其方法代码加上我自己的注释贴出来： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495/** * 整个方法其实做的还是路由分发的工作，根据请求的地址，分别返回不同的资源，并且进行访问控制。 */public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String contextPath = request.getContextPath(); String servletPath = request.getServletPath(); String requestURI = request.getRequestURI(); response.setCharacterEncoding("utf-8"); if (contextPath == null) &#123; // root context contextPath = ""; &#125; String uri = contextPath + servletPath; String path = requestURI.substring(contextPath.length() + servletPath.length()); // 禁止访问的时候返回nopermit.html，returnResourceFile这个方法很关键，下文说说 if (!isPermittedRequest(request)) &#123; path = "/nopermit.html"; returnResourceFile(path, uri, response); return; &#125; /* 从名字看来，这是接收登录请求的 * 很明显，校验就是匹配username和password是否都与配置的匹配，如果匹配就在session里塞点标识 * 很原始的做法，但是对于一个内部使用的线程池监控来说也不用做得太复杂 */ if ("/submitLogin".equals(path)) &#123; String usernameParam = request.getParameter(PARAM_NAME_USERNAME); String passwordParam = request.getParameter(PARAM_NAME_PASSWORD); if (username.equals(usernameParam) &amp;&amp; password.equals(passwordParam)) &#123; request.getSession().setAttribute(SESSION_USER_KEY, username); response.getWriter().print("success"); &#125; else &#123; response.getWriter().print("error"); &#125; return; &#125; /* 拦截登录 */ if (isRequireAuth() // &amp;&amp; !ContainsUser(request)// &amp;&amp; !("/login.html".equals(path) // || path.startsWith("/css")// || path.startsWith("/js") // || path.startsWith("/img"))) &#123; if (contextPath.equals("") || contextPath.equals("/")) &#123; response.sendRedirect("/druid/login.html"); &#125; else &#123; if ("".equals(path)) &#123; response.sendRedirect("druid/login.html"); &#125; else &#123; response.sendRedirect("login.html"); &#125; &#125; return; &#125; // 缺省首页的跳转 if ("".equals(path)) &#123; if (contextPath.equals("") || contextPath.equals("/")) &#123; response.sendRedirect("/druid/index.html"); &#125; else &#123; response.sendRedirect("druid/index.html"); &#125; return; &#125; if ("/".equals(path)) &#123; response.sendRedirect("index.html"); return; &#125; /* * 在不改造的时候，正常监控一个druid实例，会发现页面的数据都是异步刷新的， * 通过浏览器的开发者工具能发现取数据的请求都是json后缀的，所以这里就是监控数据流动的节点 * process方法是关键，而这个方法是一个抽象方法，由具体的实现类来实现，下文将回到&#123;@link com.alibaba.druid.support.http.StatViewServlet#process(String)&#125;方法里看 * / if (path.contains(".json")) &#123; String fullUrl = path; if (request.getQueryString() != null &amp;&amp; request.getQueryString().length() &gt; 0) &#123; fullUrl += "?" + request.getQueryString(); &#125; response.getWriter().print(process(fullUrl)); return; &#125; // 在以上情况都不匹配的时候，返回资源文件 // find file in resources path returnResourceFile(path, uri, response);&#125; 有两个方法需要看： returnResourceFile process returnResourceFile方法在ResourceServlet里面实现了（注释是我加的）： 123456789101112131415161718192021222324252627282930313233343536373839protected void returnResourceFile(String fileName, String uri, HttpServletResponse response) throws ServletException, IOException &#123; String filePath = getFilePath(fileName); // 如果是jpg，则返回流 if (fileName.endsWith(".jpg")) &#123; byte[] bytes = Utils.readByteArrayFromResource(filePath); if (bytes != null) &#123; response.getOutputStream().write(bytes); &#125; return; &#125; /* * 否则读取文件，返回文件内的文本 * 其中，Utils.readFromResource有这么关键的一行 * Thread.currentThread().getContextClassLoader().getResourceAsStream(resource); * 这和servlet初始化的时候是有关的 * ResourceServlet本身也是一个抽象类，其子类StatViewServlet初始化的时候指定了资源目录的路径： * public StatViewServlet()&#123; * super("support/http/resources"); * &#125; */ String text = Utils.readFromResource(filePath); if (text == null) &#123; // 如果请求的路径映射不到资源文件，则调到默认首页（其实就是将404指向了index.html） response.sendRedirect(uri + "/index.html"); return; &#125; // 如果是css或者是js文件，则还需要设置相应的响应头部 if (fileName.endsWith(".css")) &#123; response.setContentType("text/css;charset=utf-8"); &#125; else if (fileName.endsWith(".js")) &#123; response.setContentType("text/javascript;charset=utf-8"); &#125; response.getWriter().write(text);&#125; 接着看process方法（注释是原有的）： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 程序首先判断是否存在jmx连接地址，如果不存在，则直接调用本地的duird服务； 如果存在，则调用远程jmx服务。在进行jmx通信，首先判断一下jmx连接是否已经建立成功，如果已经 * 建立成功，则直接进行通信，如果之前没有成功建立，则会尝试重新建立一遍。. * * @param url 要连接的服务地址 * @return 调用服务后返回的json字符串 */protected String process(String url) &#123; String resp = null; if (jmxUrl == null) &#123; resp = statService.service(url); &#125; else &#123; if (conn == null) &#123;// 连接在初始化时创建失败 try &#123;// 尝试重新连接 initJmxConn(); &#125; catch (IOException e) &#123; LOG.error("init jmx connection error", e); resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR, "init jmx connection error" + e.getMessage()); &#125; if (conn != null) &#123;// 连接成功 try &#123; resp = getJmxResult(conn, url); &#125; catch (Exception e) &#123; LOG.error("get jmx data error", e); resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR, "get data error:" + e.getMessage()); &#125; &#125; &#125; else &#123;// 连接成功 try &#123; resp = getJmxResult(conn, url); &#125; catch (Exception e) &#123; LOG.error("get jmx data error", e); resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR, "get data error" + e.getMessage()); &#125; &#125; &#125; return resp;&#125; 可见它是有重连的，而保证了连接成功之后，获取数据的方法是getJmxResult，这个是在StatViewServlet里面实现的： 1234567private String getJmxResult(MBeanServerConnection connetion, String url) throws Exception &#123; ObjectName name = new ObjectName(DruidStatService.MBEAN_NAME); String result = (String) conn.invoke(name, "service", new String[] &#123; url &#125;, new String[] &#123; String.class.getName() &#125;); return result;&#125; 所以实际上就是用MBeanServer的连接去直接取数据然后原样返回，所有的监控数据其实是缓存在被监控的目标处的，web的监控只是一个请求转发与展示的作用。 所以现在总结StatViewServlet整个工作的主要过程： 记录用户名和密码 根据配置的jmxUrl初始化jmx连接 接收请求，分发请求 如果请求是json数据请求，则通过jmx连接到被监控对象处取数据，然后返回 3. 改进思路3.1 思路一：动态创建并注册StatViewServlet这是首先想到的思路，因为使用这种办法不需要对druid的web监控细节了解多少。要实现这个目标，需要做到以下两点之一： 对于Java Web容器的启动过程很了解，并且深入细节 Google能找到相似的例子 第一点我还做不到，短时间内也做不到，所以只能往第二点去努力。找到了一个最贴切的办法是：Dynamic Servlet Registration Example 12345678910111213141516171819202122232425262728import java.util.Map;import javax.servlet.ServletContext;import javax.servlet.ServletContextEvent;import javax.servlet.ServletContextListener;import javax.servlet.ServletRegistration;import javax.servlet.annotation.WebListener;@WebListenerpublic class ServletContextListenerImpl implements ServletContextListener &#123; @Override public void contextInitialized(final ServletContextEvent sce) &#123; final ServletContext servletContext = sce.getServletContext(); final ServletRegistration.Dynamic dynamic = servletContext.addServlet("Example Servlet", ExampleServlet.class); dynamic.addMapping("/"); final Map&lt;String, ? extends ServletRegistration&gt; map = servletContext.getServletRegistrations(); for (String key : map.keySet()) &#123; servletContext.log("Registered Servlet: " + map.get(key).getName()); &#125; &#125; @Override public void contextDestroyed(final ServletContextEvent sce) &#123; //NO-OP &#125;&#125; 主要就是实现javax.servlet.ServletContextListener，通过javax.servlet.ServletContextEvent实例获取javax.servlet.ServletContext实例，然后调用它的方法去注册新的servlet。 看上去好像可行的样子，但是在实际运行起来之后，在这一行报错了： 1final ServletRegistration.Dynamic dynamic = servletContext.addServlet("Example Servlet", ExampleServlet.class); 错误信息没有记录下来，但是意思就是说这个操作是不支持的，反正就是没戏。具体为什么，还需要进一步了解。 3.2 思路二：修改StatViewServlet的机制在第一个思路走不通之后，只能从其工作机制上入手。其原理分析已经在上文给出。 因为只要有JMX的连接就可以获取数据了，所以关键在于以下几点： 持有多个jmx连接并且与不同的请求关联起来 根据配置去动态创建连接 将原本固定的几个页面与配置的多个监控对象动态地对应起来 配置能根据部署环境的不同而改变，并且发生变更的时候能轻易修改 列出所有被监控对象 对于第一点，创建jmx连接只要有jmxUrl就够了，所以很容易做到，至于与请求关联起来，其实就是从请求的url里提取特征，用于表示不同的监控对象，然后将此特征映射到对应的jmx连接即可。 对于第二点，这其实就是普通的读取、解析配置，然后用配置信息去初始化jmx连接（当然还有登录名、密码和黑白名单等）。 第三点，转下弯，原有的逻辑是将url直接映射为资源文件，只要在这中间加一层解析即可。 第四点，简单的方案是配置多个配置文件，根据不同的环境打不同的包。但是这种做法不灵活，最好还是做成注册中心的形式，被监控对象启动的时候网注册中心写入信息，这边从注册中心读，还有下线机制。但是这种做法工作量大，而且要改被监控的一方，容易引入bug。要不就与配置中心集成，这样就只需改动web监控一端即可。这里的配置方案有多种，很适合采用SPI。 第五点，根据配置信息做个汇总，然后给个页面列出来就可以。 4 实现上文提及的问题在这里基本上都解决了，思路都讲清楚了，实现就不再重复讲。请移步我github的仓库：https://github.com/bungder/druid-aggregated-monitor 在这里提提失败重连的问题 4.1重连失败的问题其重连失败的问题，在debug的时候发现其实并没有重连，它重连的条件是conn为null，但是实际上conn初始化之后就不会为null了，但是当连接失效之后，里面的terminated属性为true，而MBeanServerConnection是一个interface，本身没定义操作这个属性的方法，并且至少有两个类实现了这个接口，运行时的实际类型并不确定是否总是某个实现类型，所以也不好去强转类型进行操作。但是可以利用它本身的逻辑：既然它触发重连的条件是conn为null，我就将它设成null好了。当conn不为null但是获取数据又出错的时候，就可以判断连接有问题，不妨触发重试，即使这种情况下不一定是连接失效了，但是正常情况下不会出现这种现象，就将其当成是连接失效也无妨。]]></content>
      <tags>
        <tag>druid</tag>
        <tag>连接池</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Druid连接池监控]]></title>
    <url>%2F2017%2F08%2F27%2Fdruid-monitor%2F</url>
    <content type="text"><![CDATA[1. 普通的web监控阿里开源的连接池Druid自带了web监控的功能，具体的操作在其github的wiki上可以找到：配置_StatViewServlet配置 · alibaba/driud wiki 其实主要就是配置一个Servlet，但是github wiki上的做法只能在druid所在的项目中启用web服务的做法，在如今盛行的微服务架构中，很多时候druid所在的服务里并不提供web服务，这就需要额外的配置。其实druid本身也提供了这种功能，只是wiki里没有说。 druid本身可以通过启用JMX端口来将监控数据传输到远端进行处理，具体做法是： 在启动服务的时候加上JVM启动参数（下文说） 在远端启用web服务，配置StatViewServlet，在initParam中指定JMX地址 1.1 JVM启动参数： -Djava.net.preferIPv4Stack=true-Dcom.sun.management.jmxremote-Djava.rmi.server.hostname=192.168.199.123-Dcom.sun.management.jmxremote.port=9876-Dcom.sun.management.jmxremote.authenticate=false-Dcom.sun.management.jmxremote.ssl=false 其中，-Djava.rmi.server.hostname一项指定了服务所在的IP地址，-Dcom.sun.management.jmxremote.port一项指定了JMX端口。 1.2 远程web工程Servlet配置在web.xml里添加如下配置： 123456789101112131415161718192021&lt;servlet&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;servlet-class&gt;com.alibaba.druid.support.http.StatViewServlet&lt;/servlet-class&gt; &lt;!-- 远程访问JavaSE项目使用jmx连接 --&gt; &lt;init-param&gt; &lt;param-name&gt;jmxUrl&lt;/param-name&gt; &lt;param-value&gt;service:jmx:rmi:///jndi/rmi://192.168.199.123:9876/jmxrmi&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;loginUsername&lt;/param-name&gt; &lt;param-value&gt;admin&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;loginPassword&lt;/param-name&gt; &lt;param-value&gt;admin&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;DruidStatView&lt;/servlet-name&gt; &lt;url-pattern&gt;/druid/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 如果想快速打包启动，不依赖外部web容器，可以采用SpringBoot，用嵌入式的web容器启动，原理也是一样。具体做法是： 创建Servlet： DruidStatViewServlet.java123456789101112131415161718192021package com.tansc.test.springboot.config.druid; import com.alibaba.druid.support.http.StatViewServlet; import javax.servlet.annotation.WebInitParam;import javax.servlet.annotation.WebServlet; /** * StatViewServlet */@SuppressWarnings("serial")@WebServlet(urlPatterns = "/druid/*", initParams=&#123; @WebInitParam(name="loginUsername",value="admin"),// 用户名 @WebInitParam(name="loginPassword",value="admin"),// 密码 @WebInitParam(name="jmxUrl",value="service:jmx:rmi:///jndi/rmi://192.168.199.123:9876/jmxrmi"), @WebInitParam(name="resetEnable",value="false")// 禁用HTML页面上的“Reset All”功能 &#125;)public class DruidStatViewServlet extends StatViewServlet &#123;&#125; 在启动类上加上注解@ServletComponentScan(&quot;com.tansc.test.springboot&quot;)以扫描Servlet。 1.3 查看监控数据上面的都配置好之后，启动服务，等服务启动成功之后，启动远端的web服务，然后访问web服务的/druid目录（与上面配置的匹配即可），例如在我本地起的：http://127.0.0.1:8080/druid 1.4 缺陷 这种做法是一对一的，也就是一个druid连接池实例必须对应一个StatViewServlet，一个StatViewServlet也只能对应一个druid实例。 切换环境不方便 JMX重连不会成功 虽然远端会有重连机制，但是在服务重启之后，重连总是报Connection refused，只能将远端的web服务重启才能成功连上（后来发现这其实没有重连，报错只是使用一个已经terminated的连接获取数据报错，具体见下一篇博文） 1.5 改进对于上面提到的两点缺陷，可以用以下两个思路去改进： 动态创建servlet，模仿分布式服务的注册中心的形式来改造 Servlet本身不提供这样的API，但是应该是可以做到的，具体要继续探索。 使用配置文件 web.xml里面本身不能读取配置文件的值，但是可以通过继承StatViewServlet来实现。 需要分析源码 （2017-08-31 目前已经改造了，见我下一篇博文：Druid连接池监控的一次改造） 1.6 性能损耗当远程的web服务启动并且在浏览器里访问统计页面之后，该服务的内存变化如下： 2. 持久化/自定义传输监控记录可以通过定制StatLogger实现，具体见其github的wiki：怎么保存Druid的监控记录 · alibaba/driud wiki 参考资料 配置StatFilter · alibaba/driud wikihttps://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatFilter 非web项目如何配置Druid监控 - 若鱼的专栏 - CSDN博客http://blog.csdn.net/goldenfish1919/article/details/68941237 Spring Boot 使用 Druid 和监控配置 - 小单的博客专栏 - CSDN博客http://blog.csdn.net/catoop/article/details/50925337 怎么保存Druid的监控记录 · alibaba/driud wikihttps://github.com/alibaba/druid/wiki/%E6%80%8E%E4%B9%88%E4%BF%9D%E5%AD%98Druid%E7%9A%84%E7%9B%91%E6%8E%A7%E8%AE%B0%E5%BD%95]]></content>
      <tags>
        <tag>druid</tag>
        <tag>连接池</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[持续集成简述]]></title>
    <url>%2F2017%2F07%2F24%2FCI%2F</url>
    <content type="text"><![CDATA[1 概述互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration, CI）。持续集成也被认为是敏捷开发的最重要实践之一。 本文主要介绍持续集成的概念以及一些工具与实践。 2 概念图2.1 持续集成概念示意图之一 上图来源于谈谈持续集成，持续交付，持续部署之间的区别，这图很直观地描述了持续集成相关的概念之间的关系，与持续集成密切相关的概念还有持续交付、持续部署，因此在下文将会就这三个概念进行阐述。 2.1 持续集成维基百科的定义（Continuous integration - Wikipedia）： 在软件工程里，持续集成（Continuous Integration, CI）是指这样的一种实践：在一天里多次将所有开发人员的代码合并到一个共享的主干里，每次合并都会触发持续集成服务器进行自动构建，这个过程包括了编译、单元测试、集成测试、质量分析等步骤，结果只有两个：成功或者失败。如果得到失败的结果，说明有人提交了不合格的代码，这就能及时发现问题。 在瀑布模型中，软件的开发过程被分为以下几个阶段： 需求分析 系统设计 编码实现 测试 集成 部署 维护 而一般在实际的开发中，基本也就遵循这些步骤进行开发，大部分情况下，不会完全按照瀑布流的方式执行，但是这些步骤都是有的，无非就是在文档的落实、步骤的次序与侧重有所变化。其中，所谓的集成，在平时的开发过程中很少直接提到这个名词，其含义是（见：System integration - Wikipedia）： 将子系统的组件整合到一个系统中并且确保子系统的功能可以组合为一个系统的过程。 所以，所谓的『集成』就是在存在多个系统协作的情况下，将子系统集成为一个大系统的过程，这个概念与『集成测试』中的『集成』是同一个概念。但是有些文章在解释『持续集成』这个概念的时候，将其解释为『将代码集成到主干分支』，目前也没见到有人说这是错的。 如果只有一个系统，那么就不存在『系统集成』这一个步骤，但是『持续集成』这个做法还是可以应用其中的，因为『持续集成』的精髓不在于『集成』，而在于『持续』，而我所理解的『持续』，就是将一些重复的操作自动化，然后频繁地触发这个自动化过程。 所以，结合上面提到的瀑布模型的几个阶段，以及『持续集成』这个名字，图2.1应该改为这样： 图2.2 持续集成概念示意图之二 从上图中看来，持续集成应该至少包括以下几部分: 自动化构建 自动化测试 自动发布 图2.3 持续集成阶段示意图 每一次的构建与测试，都应该得到一个结果：通过或者不通过，开发人员应该都能看到每一次构建与测试的结果，得到不通过的结果时应该能马上修复相关的缺陷，这就需要有一种合适的反馈渠道。 2.1.1 自动化构建自动化构建包括以下过程： 将源码编译成为二进制码 打包二进制码 运行自动化测试 生成文档 生成分发媒体（例如：Debian DEB、Red Hat RPM或者Windows MSI文件） 自动化构建可以通过两类工具实现： 构建自动化软件（Build automation utility） 例如Make、Ant、Maven、Gradle，目的是通过编译等活动来生成构建产物（build artifact）。 构建自动化服务器（Build automation servers） 一般是基于web的工具，通过计划任务或者是事件触发的方式调用构建自动化软件。一个CI服务器就是一类构建自动化服务器。 2.1.2 自动化测试自动化测试是持续集成必不可少的一部分，基本上，没有自动化测试的持续集成，都很难称之为真正的持续集成。我们希望持续集成能够尽早的暴露问题，但这远非配置一个 Hudson/Jenkins服务器那么简单，只有真正用心编写了较为完整的测试用例，并一直维护它们，持续集成才能孜孜不倦地运行测试并第一时间报告问题。 测试自动化是使用特定的软件（独立于被测试的软件）来控制测试的执行以及比较实际输出与预期输出。测试自动化可以将某些重复但必要的任务自动化，或者执行某些难以手动执行的额外测试。 自动化测试还包括单元测试、集成测试、系统测试、验收测试、性能测试等，在不同的场景下，它们都能为软件开发带来极大的价值。 2.1.2.1 单元测试单元测试（Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。 通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到预期的工作目标，没有程序错误。 2.1.2.2 集成测试集成测试（Integration Testing，有时也叫Integration and Testing, I&amp;T）即对独立的软件模块组装起来看成是一个整体进行测试。集成测试一般在单元测试之后、系统测试之前进行。实践表明，有时模块虽然可以单独工作，但是并不能保证组装起来也可以同时工作。 集成与单元测试最大的区别是它需要尽可能的测试整个功能及相关环境，对于测试Web应用而言，通常有这么几步： 启动Web容器 部署待测试Web应用 以Web客户端的角色运行测试用例 停止Web容器 通常有三种手段实现集成测试： 大爆炸（Big Bang）将所有单元组合到一起一次性测试一遍。 自上而下（Top Down）先测试高层次的单元，然后逐渐测试低层次的单元。 自下而上（Bottom Up）先测试低层次的单元，然后逐渐测试高层次的单元。 2.2 持续交付图2.4 持续交付示意图 持续交付（Continuous Delivery, CD）是一种软件工程的手段，让软件在短周期内产出，确保软件随时可以被可靠地发布。其目的在于更快、更频繁地构建、测试以及发布软件。通过加强对生产环境的应用进行渐进式更新，这种手段可以降低交付变更的成本与风险。一个简单直观的与可重复的部署过程对于持续交付来说是很重要的。 2.2.1 与DevOps的关系持续交付与DevOps的含义很相似，所以经常被混淆。但是它们是不同的两个概念。DevOps的范围更广，它以文化变迁为中心，特别是软件交付过程所涉及的多个团队之间的合作（开发、运维、QA、管理部门等），并且将软件交付的过程自动化。另一方面，持续交付是一种自动化交付的手段，关注点在于将不同的过程集中起来，并且更快、更频繁地执行这些过程。因此，DevOps可以是持续交付的一个产物，持续交付直接汇入DevOps。 2.2.2 与持续部署的关系有时候，持续交付也与持续部署混淆。持续部署意味着所有的变更都会被自动部署到生产环境中。持续交付意味着所有的变更都可以被部署到生产环境中，但是出于业务考虑，可以选择不部署。如果要实施持续部署，必须先实施持续交付。 2.2.3 原则图2.5 持续交付流水线示意图 持续交付将部署流水线（deployment pipeline）这个老生常谈的概念看作一种简单的防错方法：一系列的确认。通过这些确认，一款软件必须遵循特定的路径来发布。每当有变更被提交到源码控制仓库中时，代码要首先进行编译（有必要的话），然后由构建服务器进行打包，接着由一些不同的技术来进行测试，最后才可以将代码标记为可发布的（releasable）。 在一个持续交付环境中工作时，习惯了漫长开发周期的开发人员或许需要改变他们心态。任何代码提交在任何时间点都可能会向客户发布，明白这一点是很重要的。对于在早期提交尚未准备好让用户使用的代码，类似功能开关这样的模式是很有用的。使用NoSQL可以消除持续交付工作流中的数据迁移和模式变更的步骤、手工操作步骤以及异常情况。对于代码隔离的其他有用的技术——例如代码分支——在持续交付工作流中并未过时，但是必须加以修改以适应持续交付的原则。例如，运行多个长生命周期的代码分支是不实际的，因为一个可发布的产物如果要经历流水线的所有阶段，它必须从一个单独的分支中构建而来。 2.3 持续部署图2.6 持续部署示意图 如图所示，持续部署与持续交付之间的差异就是前者将部署自动化了。 在持续交付的实践中，交付的目标是QA，但是实际上，软件最终是要交付到客户手上的。在SaaS领域里，持续部署采用得比较广泛，因为服务比较容易做到静默升级。 采用持续部署的前提是自动化测试的覆盖率足够高。 采用持续部署的好处是能减少运维的工作量，缩短新特性从开发到实际交付的周期。 3 代价与好处3.1 代价 构造自动测试用例会耗费大量的工作，而且要去覆盖不断增加的新功能点，也要随着代码的改动去修改测试用例。 测试被视为软件开发的一种最佳实践。无论是否采用持续集成，在一些方法论里——例如测试驱动开发——自动化测试都是必不可少的一部分。 采用持续集成的时候也可以不使用任何测试用例，但是在发布一个产品之前的质量保证（Quality Assurance）成本就会变得很高，因为一切都要频繁地采用人手操作。 要花费精力去部署一个构建系统，这有时候会比较复杂，难以灵活地修改 然而，有大量的开源的持续集成软件项目，选择很多 如果项目比较小，或者包含了未经测试的遗留代码，持续集成的价值就并不是那么大 持续集成所增加的价值依赖于测试的质量以及代码实际上的可测试程度。 团队规模大就意味着代码会非常频繁地提交到集成队列里，跟踪提交就会比较困难，并且排队进行构建会减慢每个人的工作，如果构建失败，整个开发团队必须停下手里的工作，立刻修复他们的错误。 但是持续集成是可以灵活变通的，不一定要在一天里多次构建，可以配置每天下班前半小时自动构建，有错误的话开发人员可以在下班前进行处理；或者每天凌晨自动构建，第二天早上开发人员一上班就能看到构建的结果报告，然后进行处理。 一天里有多个提交和合并，一个新功能的部分代码能轻易地推送上去，在新功能完成之前，集成测试都是不通过的。 3.2 好处 能快速发现错误和定位错误 避免在发布日期大家都在检查自己有冲突的版本，造成混乱 当单元测试不通过或者出现bug的时候，如果开发人员需要回滚代码，只会造成少量的改动丢失，因为集成是频繁的。 防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。 无论对于测试、demo还是发布的目的或需求，总是有一份当前的构建可用。 频繁的代码检查驱使开发人员编写模块化的、低复杂度的代码。 4 具体实践4.1 工具 名称 授权 价格 Git支持 Docker支持 自动测试 备注 Jenkins MIT 免费 不支持 不支持 需插件支持 GitLab CI MIT 免费 支持 支持 需自配测试服务 Phabricator Apache 2.0 免费 支持 Facebook出品 Travis CI 免费 支持 支持 不支持私有部署 Bamboo 收费 支持 支持 支持 Codeship 免费/收费 关联Github, GitLab 支持 不支持私有部署 CircleCI 免费/收费 关联Github 支持 支持大部分测试框架 不支持私有部署 Hudson Eclipse Public License 1.0 免费 需插件 需插件 其实这里的支持，意思应该是直接的支持，例如Jenkins，其实和git结合也很简单，通过脚本就可以实现。 5 参考资料 Maven实战（五）——自动化Web应用集成测试http://www.infoq.com/cn/news/2011/03/xxb-maven-5-integration-test 单元测试 - 维基百科https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95 Integration testing – Wikipediahttps://en.wikipedia.org/wiki/Integration_testing Continuous integration – Wikipediahttps://en.wikipedia.org/wiki/Continuous_integration Continuous integration | ThoughtWorkshttps://www.thoughtworks.com/continuous-integration 另一种声音：持续集成已死http://www.infoq.com/cn/news/2014/10/continuous-integration 持续集成是什么？http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html 25 best continuous integration tools as of 2017 - Slanthttps://www.slant.co/topics/799/~best-continuous-integration-tools Bamboo vs Jenkins Comparison | Atlassianhttps://www.atlassian.com/software/bamboo/comparison/bamboo-vs-jenkins 通过Docker容器运行持续集成/持续部署http://dockone.io/article/468 Continuous Integration, Deployment &amp; Delivery with Codeshiphttps://codeship.com 谈谈持续集成，持续交付，持续部署之间的区别http://blog.flow.ci/cicd_difference/ Continuous delivery – Wikipediahttps://en.wikipedia.org/wiki/Continuous_delivery Build automation – Wikipediahttps://en.wikipedia.org/wiki/Build_automation List of build automation software – Wikipediahttps://en.wikipedia.org/wiki/List_of_build_automation_software Software development process - Wikipediahttps://en.wikipedia.org/wiki/Software_development_process System integration - Wikipediahttps://en.wikipedia.org/wiki/System_integration Continuous Integration - Martin Fowlerhttps://martinfowler.com/articles/continuousIntegration.html#PracticesOfContinuousIntegration Integration Testing - Software Testing Fundamentalshttp://softwaretestingfundamentals.com/integration-testing/ Practical continuous deployment: a guide to automated software deliveryhttps://www.atlassian.com/blog/continuous-delivery/practical-continuous-deployment]]></content>
      <tags>
        <tag>软件工程</tag>
        <tag>持续集成</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一种RESTful接口的约定]]></title>
    <url>%2F2017%2F07%2F24%2FREST%2F</url>
    <content type="text"><![CDATA[1 概述1.1 撰写目的本文用于定义一种统一的RESTful接口设计方案，希望具有参考价值。本文所描述的方案比较学院派（死板），在上一家公司提出没有被采纳，在所了解到的有限的若干家声称采用了RESTful风格的公司里，发现他们也偏离甚远，而在书本以及网上大部分介绍RESTful的资料里，却都是这样的方案（URL命名风格、请求与响应的设计）。当然，他们这么做是有理由的，我也理解，这只是取舍问题。这篇文章其实是旧文了，2016年年底就已经写好，但是一直躺在电脑的硬盘里，不想白费了当时的功夫，因此在此公开。 1.2 为什么采用REST目的是为了服务端与客户端的解耦。SOA仅仅是从结构上将前后端分离，但是实际上数据逻辑还是没有实现解耦，服务端接口升级往往会影响客户端，两者的行为需要严格约定。而REST采用HTTP协议进行约定，客户端仅仅需要按照HTTP协议来理解服务端返回的数据，虽然与业务相关的数据结构还是需要约定，但是这确实进一步解耦了服务端与客户端。 另外，由于严格遵照HTTP协议进行数据返回，对于安全的接口，可以在返回的Header里设置缓存策略（接口安全性的概念在下文会解释）。 1.3 文档结构第二部分将阐述关于RESTful的若干个关键的概念，明确第二部分阐述的几个概念有利于设计、实现优雅规范的接口。 第三部分就URL命名的问题进行约定。 第四部分对消息实体进行约定。 第五部分对『向RESTful接口发起请求』进行阐述，约定要实现的方法，约定请求的头部和body的格式。 第六部分对接口的响应格式进行约定，包括响应消息的头部、状态码、JSON实体。 第七部分对版本控制的问题进行约定。 第八部分对RESTful接口的实现提出了实现工具的建议。 2 关键概念明确一些关键的概念是很重要的，虽然RESTful风格的API设计方案并没有统一的标准，但是还是需要符合一定的原则进行设计，否则就不能称为RESTful风格的API。因为许多人并没有对REST进行充分的了解就宣称自己的API是RESTful风格的API，以至于RESTful的提出者Fielding博士本人无法忍受，在2008年为此专门写了一篇博客『REST APIs must be hypertext-driven』，hypertext-driven与HATEOAS是同一个概念的不同表述，在下文会进行阐述。 2.1 RESTfulREST不是一种协议，也不是一种文件格式，更不是一种开发框架。它是一系列的设计约束的集合：无状态性、将超媒体作为应用状态的引擎等。REST是Representation State Transfer的缩写，中文是『表述性状态转移』，这里就涉及到资源的表述与状态两个概念。 简单地说，资源可以看作是服务器上存储的所有数据，资源的表述则是服务器对外提供的指向这些资源的方式，使用JSON、XML等均可，一个资源可以有多种表述；资源的状态则是服务器的数据存储状态，例如在t时刻，服务器中存储了m条数据，这时候客户端向服务端提交了一个创建数据的请求，服务器处理了此请求并创建了一条数据，那么在t+1时刻，服务器中就存储了m+1条数据，这两个时刻的资源状态就是不一样的，t时刻发生的请求导致了资源状态的改变。 2.2 HATEOASHypermedia As The Engine Of Application State，超媒体作为应用程序状态的引擎。这是REST区别于其他SOA风格的主要特点。客户端与服务端进行互动的时候，完全是通过服务端动态提供的超媒体进行的。除了对超媒体的一般理解，客户端不需要知道其他额外的知识。相反，在一些SOA接口的设计中，客户端与服务端的通信是要事先进行约定的，例如通过文档或者接口描述语言（Interface Description Language, IDL）。而基于HTTP协议的REST设计里，一般采用的就是请求与响应的Header来体现HATEOAS原则（具体请参考：https://en.wikipedia.org/wiki/HATEOAS）。这里也隐含这样一层含义：REST应尽可能地利用HTTP标准中现有的东西，例如Header、标准方法与状态码。 从标准的角度看，HTTP标准是一项RFC标准，世界认可；而其他自定义的SOA标准则可能是一项个人标准或者公司标准，最多是一项互联网草案（这对大部分公司来说都不可能），而一项标准越是被广为认可接受，其实现的通用性就越强。个人标准和公司标准都五花八门，这样对每一个标准都要参照其相关文档实现相应的行为逻辑是很麻烦的。 2.3 安全性一个方法被调用1次与被调用0次是一样的，此方法就是安全的，否则就是不安全的。例如，一个方法A仅仅是读取数据，并不创建或者修改数据，不论A方法被调用多少次，都不对数据记录产生任何影响，A方法是安全的。而假如有另一个方法B对数据进行删除，B方法被调用1次后，数据会被删除（或者标识位被修改），系统里的数据发生了变化，那么B方法是不安全的。 2.4 幂等性一个方法被同样地调用1次与被调用多次是一样的，即同样的输入会得到同样的输出，此方法就是幂等的，否则就不是幂等的。 2.3节中A方法与B方法都是幂等的，一个安全的方法一定是幂等的，一个幂等的方法不一定是安全的。 假设一个方法C对某个全局计数器执行自增操作并写入数据库，每次调用C方法都会对系统数据产生影响，那么C方法就不是幂等的。 3 URL命名URL用于标识资源，因此URL应该以名词进行命名，例如/users, /users/children等。 一般URL会内嵌参数，例如要获取id为313的user的信息，那么URL应该为/users/313，前面的user采用复数，如果要列出其所有后代，则URL应为/users/313/children，children为复数形式，如果要获取其id为499的后代，则URL应为/users/313/children/499 4 消息实体消息实体，就是请求和响应消息中的entity-body（也称为body），消息实体采用JSON字符串格式。 5 请求5.1 方法使用HTTP标准定义的请求方法。 5.1.1 get获取资源，单个参数一般写在URL上，多个参数则作为query parameter附在URL后面，例如： 单个参数：/user/123, 表示id为123的user 多个参数：/user?name=tom&amp;phone=13787890987&amp;gender=male get方法应为幂等的，并且不对数据记录产生影响。对于汉字与特殊字符，应该进行urlencode。 5.1.2 post创建资源，请求的headers里设置Content-type为application/json，参数为json类型。 根据约定，在创建成功之后，返回的状态码应该是201（Created），并且在response的Header里设置Location为新创建的资源的URL，例如，创建了一个新的user，该user创建后id为888，那么Header里应该设置Location为/users/888，当然，这应该是一个完整的URL，这里只是给出了一个相对路径的URI以作为说明。返回了这些数据后，客户端可以自定义后续行为，或者查看创建后的user，或者刷新当前的user列表，这些行为服务端并不关心。 如果重复提交了相同的数据，第一次应该返回201，以后则应返回409（Conflict），并且在response的Header里设置Location指向已经存在的资源，说明冲突的来源。 5.1.3 put更新资源，对现有资源进行修改，请求的headers与post一样，参数也是。此方法应该是幂等的。 5.1.4 delete删除资源。此方法应是幂等的。 5.2 HeaderContent-type应设为application/json。 另外应设置一个version，指明所使用的接口版本。这不属于HTTP协议中的一部分，是自定义的，出于版本控制的考量，具体见第七章。 5.3 body采用JSON字符串，具体的结构有待商定，这不属于HTTP协议的一部分，是自定义的。 这里主要放置业务相关的数据。 借用一篇10年前的文章的一张图： 6 响应6.1 Header根据响应的状态码不同，相应地设置头部，具体见下一节。 但是在我所了解的公司里，做法都是统一返回200，然后在返回的JSON字符串里设置消息码。我是不能理解的。据一位前端同学说，前端代码接收到了请求以后，不方便获取Http状态码。其实我也写过前端，不深入，但是一些基本的知识还是有的，我觉得这并不难做到，估计是他的代码封装的时候没有考虑到这一点，现在要改比较麻烦，所以不想大动干戈、伤筋动骨。 6.2 状态码 状态码 语义 使用场景 200 OK 正常返回消息，什么问题也没有 201 Created 创建资源成功，Header里应设置Location指向新创建的资源 202 Accepted 请求已被接收，但是处理过程较长，不能马上返回结果 304 Not Modified 没有任何修改发生 401 Unauthorized 缺乏权限，指已经登录但是缺乏请求这个资源的权限 403 Forbidden 拒绝访问，可用于未登录时拦截返回的状态码，此时Header里应设置Location为登录页面的URL 404 Not Found 不存在所请求的资源 406 Not Acceptable 请求没有被接收，参数约束校验不通过，或者其他业务类型的错误都可以返回这个状态码，response的body里应有表示错误信息的JSON实体。 409 Conflict 请求的资源有冲突，例如多次提交一样的创建请求，response的Header里应设置Location为产生冲突的资源的URL 500 Internal Server Error 服务器的非业务类错误，response的body里应有表示错误信息的JSON实体 6.3 body采用JSON字符串。JSON的结构分为两种：成功、失败。 一般而言，只有返回200的时候才需要读取成功的JSON，只有返回406和500的时候才需要读取失败的JSON，对于其他的状态码，客户端不需要服务器提供额外的消息。 对于成功的JSON，里面应该只包含一个result对象，而失败的JSON应该使用这样的结构： 1234567&#123; error: &#123; code: xxx, message: "xxx", data: &#123;...&#125; &#125;&#125; 失败的JSON只有一个error对象，包含错误码、消息及相关数据，message应该是直接可读的消息，客户端毋需理解发生了什么错误，客户端只需将消息展示出来即可。在收到406的时候，客户端只需知道发生的错误是由客户端造成的即可，具体是什么类型并不需要知道，将消息直接展示出来，让使用的人知道是什么即可，所以message应该是人类可以理解的文本。同理，收到500的时候，只需知道这个错误是服务端的问题即可，客户端也毋需知道具体的错误类型，最多就将错误码和消息展示出来，让使用者有反馈的依据即可。 7 版本控制考虑到接口有可能升级，升级的类型有几种： 新增功能接口 原有接口返回数据增加字段 现有接口返回数据变更现有字段格式或删除现有字段 现有接口变更业务逻辑 删除接口 其中，前两种升级并不会影响客户端，因此毋需处理。而后面三种会导致使用旧接口的客户端不能正常工作。 一般服务端升级与客户端升级都不是同步的，客户端升级往往会滞后，因此在服务端升级后应该保留旧版本的接口继续运行一段时间，让未升级的客户端可以继续工作一段时间，同时可以上线新版本的客户端。过一段时间后再将旧版本的接口下线。 而版本控制应该是向下兼容的，即假设当前版本是1.2，如果客户端请求1.3版本的服务，应当用当前版本提供服务。如果没有注明请求的版本号，应当提供当前版本的服务。 一般情况下，客户端请求需要带版本号，但是服务端并不需要对此进行处理，除非是同时运行新旧版本的同一个接口，才需要做差异处理。 8 实现工具8.1 Spring HATEOASSpring HATEOAS可以很方便地与Spring MVC结合来开发RESTful接口。具体参照其文档：http://docs.spring.io/spring-hateoas/docs/0.20.0.RELEASE/reference/html/#fundamentals.jaxb-json 9 缺陷其实这个方案基本就是网上一些被大部分人认可的做法的汇总，但是缺乏细节，例如分页，但是其实这些可以灵活变通，例如在查询字符串里加上分页参数。《一次无后端的供应链系统开发实践 (上篇)： 前后端分离的 Restful 接口设计》这篇文章的设计就比较全面，但是两者考量的问题范畴不同，他这个是serverless的设计，将业务逻辑都压在前端，后端仅仅作为前端与数据源之间的代理（数据源、客户端都在自己控制范围内的话其实没必要这样搞），这样的话，接口要表达的逻辑就比较复杂，而本文还是从传统的抽象思想去考虑，逻辑都在后端封装，因此接口并不需要表达多么复杂的逻辑。 10 参考文献当时写的时候没记下来，所以就不列出来了，在此不保证来源的权威性，请读者自行鉴别。^_^]]></content>
      <tags>
        <tag>REST</tag>
      </tags>
  </entry>
</search>