{"meta":{"title":"Gordon","subtitle":null,"description":null,"author":"Gordon","url":"http://bungder.github.io"},"pages":[{"title":"分类","date":"2017-07-24T14:10:40.000Z","updated":"2017-07-24T14:11:09.000Z","comments":true,"path":"categories/index.html","permalink":"http://bungder.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-07-24T14:11:36.000Z","updated":"2017-07-24T14:12:00.000Z","comments":true,"path":"tags/index.html","permalink":"http://bungder.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"软件工程开发模型简述","slug":"software-engineering","date":"2017-07-29T16:41:48.000Z","updated":"2017-07-30T15:00:23.000Z","comments":true,"path":"2017/07/30/software-engineering/","link":"","permalink":"http://bungder.github.io/2017/07/30/software-engineering/","excerpt":"1 概述软件工程开发模型其实就是展开开发工作的方法论，其重要性不言而喻。以前本科的时候学过一门课就叫《软件工程》，但是当时学的很多东西都忘了，就只记得一个瀑布模型。然而瀑布模型过于原始，如今敏捷方法大行其道，有必要理清一下它们之间的关系（别人早已理清了，是我自己需要理清^_^），了解敏捷方法的由来。 维基百科上『软件工程』这一分类条目下的知识点总结如下： 本文主要就开发模型进行简单的总结。","text":"1 概述软件工程开发模型其实就是展开开发工作的方法论，其重要性不言而喻。以前本科的时候学过一门课就叫《软件工程》，但是当时学的很多东西都忘了，就只记得一个瀑布模型。然而瀑布模型过于原始，如今敏捷方法大行其道，有必要理清一下它们之间的关系（别人早已理清了，是我自己需要理清^_^），了解敏捷方法的由来。 维基百科上『软件工程』这一分类条目下的知识点总结如下： 本文主要就开发模型进行简单的总结。 2 开发模型（TODO） 2.1 瀑布模型（TODO） 2.2 螺旋模型（TODO） 总结其实这也在情理之中。本科的时候最多也就写几个小项目玩玩，基本上就只有编码、单元测试两个环节，或许会有简单的需求分析和系统设计，但是存在感都比较弱，也就是说，在本科的时候，基本上缺乏软件工程的参与经验，既没有对此存在疑问，也意识不到其重要性。同时，这门课的老师也缺乏工程实施经验，走的路线基本就是本硕博读完进高校教书，对于软件项目开发这种与学术界关系不大的课题，也就只能照本宣科，台上台下都与『软件工程』没发生过什么实质性关系。因此，在现在看来，在本科开设软件工程这门课实在有点为时尚早，又或许是课程的形式不恰当。但是从另一个角度看，本科的学生本来就没有经历完整项目流程的机会（指规范的开发），而高校聘请业界工程师来讲课实施起来也有点问题，将来要成为软件工程师的学生又不可能不了解软件工程的知识，因此也就只好这样了。 参考文献 瀑布模型 - 维基百科https://zh.wikipedia.org/wiki/瀑布模型 Waterfall model – Wikipediahttps://en.wikipedia.org/wiki/Waterfall_model Software development process – Wikipediahttps://en.wikipedia.org/wiki/Software_development_process 软件工程 - 维基百科https://zh.wikipedia.org/wiki/软件工程","categories":[],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://bungder.github.io/tags/软件工程/"}]},{"title":"持续集成简述","slug":"CI","date":"2017-07-24T13:51:48.000Z","updated":"2017-07-30T14:58:40.000Z","comments":true,"path":"2017/07/24/CI/","link":"","permalink":"http://bungder.github.io/2017/07/24/CI/","excerpt":"1 概述联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration, CI）。持续集成也被认为是敏捷开发的最重要实践之一。 本文主要介绍持续集成的概念以及一些工具与实践。 2 概念图2.1 持续集成概念示意图之一 上图来源于谈谈持续集成，持续交付，持续部署之间的区别，这图很直观地描述了持续集成相关的概念之间的关系，与持续集成密切相关的概念还有持续交付、持续部署，因此在下文将会就这三个概念进行阐述。","text":"1 概述联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration, CI）。持续集成也被认为是敏捷开发的最重要实践之一。 本文主要介绍持续集成的概念以及一些工具与实践。 2 概念图2.1 持续集成概念示意图之一 上图来源于谈谈持续集成，持续交付，持续部署之间的区别，这图很直观地描述了持续集成相关的概念之间的关系，与持续集成密切相关的概念还有持续交付、持续部署，因此在下文将会就这三个概念进行阐述。 2.1 持续集成在瀑布模型中，软件的开发过程被分为以下几个阶段： 需求分析 系统设计 编码实现 测试 集成 部署 维护 而一般在实际的开发中，基本也就遵循这些步骤进行开发，大部分情况下，不会完全按照瀑布流的方式执行，但是这些步骤都是有的，无非就是在文档的落实、步骤的次序与侧重有所变化。其中，所谓的集成，在平时的开发过程中很少直接提到这个名词，其含义是（见：System integration - Wikipedia）： 将子系统的组件整合到一个系统中并且确保子系统的功能可以组合为一个系统的过程。 所以，所谓的『集成』就是在存在多个系统协作的情况下，将子系统集成为一个大系统的过程，这个概念与『集成测试』中的『集成』是同一个概念。有些文章在解释『持续集成』这个概念的时候，并没有说清楚这个概念，有时候甚至误导读者，说『将代码集成到主干分支』，这样的说法是不对的。 如果只有一个系统，那么久不存在『集成』这一个步骤，但是『持续集成』这个做法还是可以应用其中的，因为『持续集成』的精髓不在于『集成』，而在于『持续』，而我所理解的『持续』，就是将一些重复的操作自动化，然后频繁地触发这个自动化过程。 所以，结合上面提到的瀑布模型的几个阶段，以及『持续集成』这个名字，图2.1应该改为这样： 图2.2 持续集成概念示意图之二 从上图中看来，持续集成应该至少包括以下几部分: 自动化构建 自动化测试 自动发布 图2.3 持续集成阶段示意图 维基百科的定义（Continuous integration - Wikipedia）： 在软件工程里，持续集成（Continuous Integration, CI）是指这样的一种实践：在一天里多次将所有开发人员的代码合并到一个共享的主干里，每次合并都会触发持续集成服务器进行自动构建，这个过程包括了编译、单元测试、集成测试、质量分析等步骤，结果只有两个：成功或者失败。如果得到失败的结果，说明有人提交了不合格的代码，这就能及时发现问题。 (TODO 引出反馈途径) 2.1.1 自动化构建（TODO） 2.1.2 自动化测试自动化测试是持续集成必不可少的一部分，基本上，没有自动化测试的持续集成，都很难称之为真正的持续集成。我们希望持续集成能够尽早的暴露问题，但这远非配置一个 Hudson/Jenkins服务器那么简单，只有真正用心编写了较为完整的测试用例，并一直维护它们，持续集成才能孜孜不倦地运行测试并第一时间报告问题。 自动化测试还包括单元测试、集成测试、系统测试、验收测试、性能测试等，在不同的场景下，它们都能为软件开发带来极大的价值。 2.1.2.1 单元测试单元测试（Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。 通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到软件规格书要求的工作目标，没有程序错误。 2.1.2.2 集成测试集成测试（Integration Testing，有时也叫Integration and Testing, I&amp;T）即对独立的软件模块组装起来看成是一个整体进行测试。集成测试一般在单元测试之后、系统测试之前进行。实践表明，有时模块虽然可以单独工作，但是并不能保证组装起来也可以同时工作。 集成与单元测试最大的区别是它需要尽可能的测试整个功能及相关环境，对于测试Web应用而言，通常有这么几步： 启动Web容器 部署待测试Web应用 以Web客户端的角色运行测试用例 停止Web容器 （TODO） 2.2 持续交付 持续交付（Continuous Delivery, CD）是一种软件工程的手段，让软件在短周期内产出，确保软件随时可以被可靠地发布。其目的在于更快、更频繁地构建、测试以及发布软件。通过加强对生产环境的应用进行渐进式更新，这种手段可以降低交付变更的成本与风险。一个简单直观的与可重复的部署过程对于持续交付来说是很重要的。 2.2.1 与DevOps的关系持续交付与DevOps的含义很相似，所以经常被混淆。但是它们是不同的两个概念。DevOps的范围更广，它以文化变迁为中心，特别是软件交付过程所涉及的多个团队之间的合作（开发、运维、QA、管理部门等），并且将软件交付的过程自动化。另一方面，持续交付是一种自动化交付的手段，关注点在于将不同的过程集中起来，并且更快、更频繁地执行这些过程。因此，DevOps可以是持续交付的一个产物，持续交付直接汇入DevOps。 2.2.2 与持续部署的关系有时候，持续交付也与持续部署混淆。持续部署意味着所有的变更都会被自动部署到生产环境中。持续交付意味着所有的变更都可以被部署到生产环境中，但是出于业务考虑，可以选择不部署。如果要实施持续部署，必须先实施持续交付。 2.2.3 原则 持续交付将部署流水线（deployment pipeline）这个老生常谈的概念看作一种简单的防错方法：一系列的确认。通过这些确认，一款软件必须遵循特定的路径来发布。每当有变更被提交到源码控制仓库中时，代码要首先进行编译（有必要的话），然后由构建服务器进行打包，接着由一些不同的技术来进行测试，最后才可以将代码标记为可发布的（releasable）。 在一个持续交付环境中工作时，习惯了漫长开发周期的开发人员或许需要改变他们心态。任何代码提交在任何时间点都可能会向客户发布，明白这一点是很重要的。对于在早期提交尚未准备好让用户使用的代码，类似功能开关这样的模式是很有用的。使用NoSQL可以消除持续交付工作流中的数据迁移和模式变更的步骤、手工操作步骤以及异常情况。对于代码隔离的其他有用的技术——例如代码分支——在持续交付工作流中并未过时，但是必须加以修改以适应持续交付的原则。例如，运行多个长生命周期的代码分支是不实际的，因为一个可发布的artifact（不知道这词对应什么中文）如果要经历流水线的所有阶段，它必须从一个单独的分支中构建而来。 2.3 持续部署(TODO) 3 代价与好处3.1 代价 构造自动测试用例会耗费大量的工作，而且要去覆盖不断增加的新功能点，也要随着代码的改动去修改测试用例。 测试被视为软件开发的一种最佳实践。无论是否采用持续集成，在一些方法论里——例如测试驱动开发——自动化测试都是必不可少的一部分。 采用持续集成的时候也可以不使用任何测试用例，但是在发布一个产品之前的质量保证（Quality Assurance）成本就会变得很高，因为一切都要频繁地采用人手操作。 要花费精力去部署一个构建系统，这有时候会比较复杂，难以灵活地修改 然而，有大量的开源的持续集成软件项目，选择很多 如果项目比较小，或者包含了未经测试的遗留代码，持续集成的价值就并不是那么大 持续集成所增加的价值依赖于测试的质量以及代码实际上的可测试程度。 团队规模大就意味着代码会非常频繁地提交到集成队列里，跟踪提交就会比较困难，并且排队进行构建会减慢每个人的工作，如果构建失败，整个开发团队必须停下手里的工作，立刻修复他们的错误。 但是持续集成是可以灵活变通的，不一定要在一天里多次构建，可以配置每天下班前半小时自动构建，有错误的话开发人员可以在下班前进行处理；或者每天凌晨自动构建，第二天早上开发人员一上班就能看到构建的结果报告，然后进行处理。 一天里有多个提交和合并，一个新功能的部分代码能轻易地推送上去，在新功能完成之前，集成测试都是不通过的。 3.2 好处 能快速发现错误和定位错误 避免在发布日期大家都在检查自己有冲突的版本，造成混乱 当单元测试不通过或者出现bug的时候，如果开发人员需要回滚代码，只会造成少量的改动丢失，因为集成是频繁的。 防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。 无论对于测试、demo还是发布的目的或需求，总是有一份当前的构建可用。 频繁的代码检查驱使开发人员编写模块化的、低复杂度的代码。 4 具体实践4.1 工具 名称 授权 价格 Git支持 Docker支持 自动测试 备注 Jenkins MIT 免费 不支持 不支持 需插件支持 GitLab CI MIT 免费 支持 支持 需自配测试服务 Phabricator Apache 2.0 免费 支持 Facebook出品 Travis CI 免费 支持 支持 不支持私有部署 Bamboo 收费 支持 支持 支持 Codeship 免费/收费 关联Github, GitLab 支持 不支持私有部署 CircleCI 免费/收费 关联Github 支持 支持大部分测试框架 不支持私有部署 Hudson Eclipse Public License 1.0 免费 需插件 需插件 其实这里的支持，意思应该是直接的支持，例如Jenkins，其实和git结合也很简单，通过脚本就可以实现。 5 参考资料 Maven实战（五）——自动化Web应用集成测试http://www.infoq.com/cn/news/2011/03/xxb-maven-5-integration-test 单元测试 - 维基百科https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95 Integration testing – Wikipediahttps://en.wikipedia.org/wiki/Integration_testing Continuous integration – Wikipediahttps://en.wikipedia.org/wiki/Continuous_integration 另一种声音：持续集成已死http://www.infoq.com/cn/news/2014/10/continuous-integration 持续集成是什么？http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html 25 best continuous integration tools as of 2017 - Slanthttps://www.slant.co/topics/799/~best-continuous-integration-tools Bamboo vs Jenkins Comparison | Atlassianhttps://www.atlassian.com/software/bamboo/comparison/bamboo-vs-jenkins 通过Docker容器运行持续集成/持续部署http://dockone.io/article/468 Continuous Integration, Deployment &amp; Delivery with Codeshiphttps://codeship.com 谈谈持续集成，持续交付，持续部署之间的区别http://blog.flow.ci/cicd_difference/ Continuous delivery – Wikipediahttps://en.wikipedia.org/wiki/Continuous_delivery Build automation – Wikipediahttps://en.wikipedia.org/wiki/Build_automation List of build automation software – Wikipediahttps://en.wikipedia.org/wiki/List_of_build_automation_software Software development process - Wikipediahttps://en.wikipedia.org/wiki/Software_development_process System integration - Wikipediahttps://en.wikipedia.org/wiki/System_integration","categories":[],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://bungder.github.io/tags/软件工程/"},{"name":"持续集成","slug":"持续集成","permalink":"http://bungder.github.io/tags/持续集成/"}]},{"title":"一种RESTful接口的约定","slug":"REST","date":"2017-07-24T13:05:13.000Z","updated":"2017-07-26T05:27:49.000Z","comments":true,"path":"2017/07/24/REST/","link":"","permalink":"http://bungder.github.io/2017/07/24/REST/","excerpt":"1 概述1.1 撰写目的本文用于定义一种统一的RESTful接口设计方案，希望具有参考价值。本文所描述的方案比较学院派，在上一家公司提出没有被采纳，在所了解到的有限的若干家声称采用了RESTful风格的公司里，发现他们也偏离甚远。当然，他们这么做是有理由的，我也理解，这只是取舍问题。这篇文章其实是旧文了，2016年年底就已经写好，但是一直躺在电脑的硬盘里，不想白费了当时的功夫，因此在此公开。 1.2 为什么采用REST目的是为了服务端与客户端的解耦。SOA仅仅是从结构上将前后端分离，但是实际上数据逻辑还是没有实现解耦，服务端接口升级往往会影响客户端，两者的行为需要严格约定。而REST采用HTTP协议进行约定，客户端仅仅需要按照HTTP协议来理解服务端返回的数据，虽然与业务相关的数据结构还是需要约定，但是这确实进一步解耦了服务端与客户端。 另外，由于严格遵照HTTP协议进行数据返回，对于安全的接口，可以在返回的Header里设置缓存策略（接口安全性的概念在下文会解释）。","text":"1 概述1.1 撰写目的本文用于定义一种统一的RESTful接口设计方案，希望具有参考价值。本文所描述的方案比较学院派，在上一家公司提出没有被采纳，在所了解到的有限的若干家声称采用了RESTful风格的公司里，发现他们也偏离甚远。当然，他们这么做是有理由的，我也理解，这只是取舍问题。这篇文章其实是旧文了，2016年年底就已经写好，但是一直躺在电脑的硬盘里，不想白费了当时的功夫，因此在此公开。 1.2 为什么采用REST目的是为了服务端与客户端的解耦。SOA仅仅是从结构上将前后端分离，但是实际上数据逻辑还是没有实现解耦，服务端接口升级往往会影响客户端，两者的行为需要严格约定。而REST采用HTTP协议进行约定，客户端仅仅需要按照HTTP协议来理解服务端返回的数据，虽然与业务相关的数据结构还是需要约定，但是这确实进一步解耦了服务端与客户端。 另外，由于严格遵照HTTP协议进行数据返回，对于安全的接口，可以在返回的Header里设置缓存策略（接口安全性的概念在下文会解释）。 1.3 文档结构第二部分将阐述关于RESTful的若干个关键的概念，明确第二部分阐述的几个概念有利于设计、实现优雅规范的接口。 第三部分就URL命名的问题进行约定。 第四部分对消息实体进行约定。 第五部分对『向RESTful接口发起请求』进行阐述，约定要实现的方法，约定请求的头部和body的格式。 第六部分对接口的响应格式进行约定，包括响应消息的头部、状态码、JSON实体。 第七部分对版本控制的问题进行约定。 第八部分对RESTful接口的实现提出了实现工具的建议。 2 关键概念明确一些关键的概念是很重要的，虽然RESTful风格的API设计方案并没有统一的标准，但是还是需要符合一定的原则进行设计，否则就不能称为RESTful风格的API。因为许多人并没有对REST进行充分的了解就宣称自己的API是RESTful风格的API，以至于RESTful的提出者Fielding博士本人无法忍受，在2008年为此专门写了一篇博客『REST APIs must be hypertext-driven』，hypertext-driven与HATEOAS是同一个概念的不同表述，在下文会进行阐述。 2.1 RESTfulREST不是一种协议，也不是一种文件格式，更不是一种开发框架。它是一系列的设计约束的集合：无状态性、将超媒体作为应用状态的引擎等。REST是Representation State Transfer的缩写，中文是『表述性状态转移』，这里就涉及到资源的表述与状态两个概念。 简单地说，资源可以看作是服务器上存储的所有数据，资源的表述则是服务器对外提供的指向这些资源的方式，使用JSON、XML等均可，一个资源可以有多种表述；资源的状态则是服务器的数据存储状态，例如在t时刻，服务器中存储了m条数据，这时候客户端向服务端提交了一个创建数据的请求，服务器处理了此请求并创建了一条数据，那么在t+1时刻，服务器中就存储了m+1条数据，这两个时刻的资源状态就是不一样的，t时刻发生的请求导致了资源状态的改变。 2.2 HATEOASHypermedia As The Engine Of Application State，超媒体作为应用程序状态的引擎。这是REST区别于其他SOA风格的主要特点。客户端与服务端进行互动的时候，完全是通过服务端动态提供的超媒体进行的。除了对超媒体的一般理解，客户端不需要知道其他额外的知识。相反，在一些SOA接口的设计中，客户端与服务端的通信是要事先进行约定的，例如通过文档或者接口描述语言（Interface Description Language, IDL）。而基于HTTP协议的REST设计里，一般采用的就是请求与响应的Header来体现HATEOAS原则（具体请参考：https://en.wikipedia.org/wiki/HATEOAS）。这里也隐含这样一层含义：REST应尽可能地利用HTTP标准中现有的东西，例如Header、标准方法与状态码。 从标准的角度看，HTTP标准是一项RFC标准，世界认可；而其他自定义的SOA标准则可能是一项个人标准或者公司标准，最多是一项互联网草案（这对大部分公司来说都不可能），而一项标准越是被广为认可接受，其实现的通用性就越强。个人标准和公司标准都五花八门，这样对每一个标准都要参照其相关文档实现相应的行为逻辑是很麻烦的。 2.3 安全性一个方法被调用1次与被调用0次是一样的，此方法就是安全的，否则就是不安全的。例如，一个方法A仅仅是读取数据，并不创建或者修改数据，不论A方法被调用多少次，都不对数据记录产生任何影响，A方法是安全的。而假如有另一个方法B对数据进行删除，B方法被调用1次后，数据会被删除（或者标识位被修改），系统里的数据发生了变化，那么B方法是不安全的。 2.4 幂等性一个方法被同样地调用1次与被调用多次是一样的，即同样的输入会得到同样的输出，此方法就是幂等的，否则就不是幂等的。 2.3节中A方法与B方法都是幂等的，一个安全的方法一定是幂等的，一个幂等的方法不一定是安全的。 假设一个方法C对某个全局计数器执行自增操作并写入数据库，每次调用C方法都会对系统数据产生影响，那么C方法就不是幂等的。 3 URL命名URL用于标识资源，因此URL应该以名词进行命名，例如/users, /users/children等。 一般URL会内嵌参数，例如要获取id为313的user的信息，那么URL应该为/users/313，前面的user采用复数，如果要列出其所有后代，则URL应为/users/313/children，children为复数形式，如果要获取其id为499的后代，则URL应为/users/313/children/499 4 消息实体消息实体，就是请求和响应消息中的entity-body（也称为body），消息实体采用JSON字符串格式。 5 请求5.1 方法使用HTTP标准定义的请求方法。 5.1.1 get获取资源，单个参数一般写在URL上，多个参数则作为query parameter附在URL后面，例如： 单个参数：/user/123, 表示id为123的user 多个参数：/user?name=tom&amp;phone=13787890987&amp;gender=male get方法应为幂等的，并且不对数据记录产生影响。对于汉字与特殊字符，应该进行urlencode。 5.1.2 post创建资源，请求的headers里设置Content-type为application/json，参数为json类型。 根据约定，在创建成功之后，返回的状态码应该是201（Created），并且在response的Header里设置Location为新创建的资源的URL，例如，创建了一个新的user，该user创建后id为888，那么Header里应该设置Location为/users/888，当然，这应该是一个完整的URL，这里只是给出了一个相对路径的URI以作为说明。返回了这些数据后，客户端可以自定义后续行为，或者查看创建后的user，或者刷新当前的user列表，这些行为服务端并不关心。 如果重复提交了相同的数据，第一次应该返回201，以后则应返回409（Conflict），并且在response的Header里设置Location指向已经存在的资源，说明冲突的来源。 5.1.3 put更新资源，对现有资源进行修改，请求的headers与post一样，参数也是。此方法应该是幂等的。 5.1.4 delete删除资源。此方法应是幂等的。 5.2 HeaderContent-type应设为application/json。 另外应设置一个version，指明所使用的接口版本。这不属于HTTP协议中的一部分，是自定义的，出于版本控制的考量，具体见第七章。 5.3 body采用JSON字符串，具体的结构有待商定，这不属于HTTP协议的一部分，是自定义的。 这里主要放置业务相关的数据。 6 响应6.1 Header根据响应的状态码不同，相应地设置头部，具体见下一节。 但是在我所了解的公司里，做法都是统一返回200，然后在返回的JSON字符串里设置消息码。我是不能理解的。据一位前端同学说，前端代码接收到了请求以后，不方便获取Http状态码。其实我也写过前端，不深入，但是一些基本的知识还是有的，我觉得这并不难做到，估计是他的代码封装的时候没有考虑到这一点，现在要改比较麻烦，所以不想大动干戈、伤筋动骨。 6.2 状态码 状态码 语义 使用场景 200 OK 正常返回消息，什么问题也没有 201 Created 创建资源成功，Header里应设置Location指向新创建的资源 202 Accepted 请求已被接收，但是处理过程较长，不能马上返回结果 304 Not Modified 没有任何修改发生 401 Unauthorized 缺乏权限，指已经登录但是缺乏请求这个资源的权限 403 Forbidden 拒绝访问，可用于未登录时拦截返回的状态码，此时Header里应设置Location为登录页面的URL 404 Not Found 不存在所请求的资源 406 Not Acceptable 请求没有被接收，参数约束校验不通过，或者其他业务类型的错误都可以返回这个状态码，response的body里应有表示错误信息的JSON实体。 409 Conflict 请求的资源有冲突，例如多次提交一样的创建请求，response的Header里应设置Location为产生冲突的资源的URL 500 Internal Server Error 服务器的非业务类错误，response的body里应有表示错误信息的JSON实体 6.3 body采用JSON字符串。JSON的结构分为两种：成功、失败。 一般而言，只有返回200的时候才需要读取成功的JSON，只有返回406和500的时候才需要读取失败的JSON，对于其他的状态码，客户端不需要服务器提供额外的消息。 对于成功的JSON，里面应该只包含一个result对象，而失败的JSON应该使用这样的结构： 1234567&#123; error: &#123; code: xxx, message: \"xxx\", data: &#123;...&#125; &#125;&#125; 失败的JSON只有一个error对象，包含错误码、消息及相关数据，message应该是直接可读的消息，客户端毋需理解发生了什么错误，客户端只需将消息展示出来即可。在收到406的时候，客户端只需知道发生的错误是由客户端造成的即可，具体是什么类型并不需要知道，将消息直接展示出来，让使用的人知道是什么即可，所以message应该是人类可以理解的文本。同理，收到500的时候，只需知道这个错误是服务端的问题即可，客户端也毋需知道具体的错误类型，最多就将错误码和消息展示出来，让使用者有反馈的依据即可。 7 版本控制考虑到接口有可能升级，升级的类型有几种： 新增功能接口 原有接口返回数据增加字段 现有接口返回数据变更现有字段格式或删除现有字段 现有接口变更业务逻辑 删除接口 其中，前两种升级并不会影响客户端，因此毋需处理。而后面三种会导致使用旧接口的客户端不能正常工作。 一般服务端升级与客户端升级都不是同步的，客户端升级往往会滞后，因此在服务端升级后应该保留旧版本的接口继续运行一段时间，让未升级的客户端可以继续工作一段时间，同时可以上线新版本的客户端。过一段时间后再将旧版本的接口下线。 而版本控制应该是向下兼容的，即假设当前版本是1.2，如果客户端请求1.3版本的服务，应当用当前版本提供服务。如果没有注明请求的版本号，应当提供当前版本的服务。 一般情况下，客户端请求需要带版本号，但是服务端并不需要对此进行处理，除非是同时运行新旧版本的同一个接口，才需要做差异处理。 8 实现8.1 Spring HATEOASSpring HATEOAS可以很方便地与Spring MVC结合来开发RESTful接口。具体参照其文档：http://docs.spring.io/spring-hateoas/docs/0.20.0.RELEASE/reference/html/#fundamentals.jaxb-json","categories":[],"tags":[{"name":"REST","slug":"REST","permalink":"http://bungder.github.io/tags/REST/"}]}]}