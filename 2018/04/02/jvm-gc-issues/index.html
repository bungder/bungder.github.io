<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Java,JVM," />





  <link rel="alternate" href="/atom.xml" title="Gordon" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="1. 概念http://blog.csdn.net/u011080472/article/details/51324422 1.0 并发和并行这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，它们可以解释如下。  并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。  并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，">
<meta name="keywords" content="Java,JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="JVM GC相关问题">
<meta property="og:url" content="http://bungder.github.io/2018/04/02/jvm-gc-issues/index.html">
<meta property="og:site_name" content="Gordon">
<meta property="og:description" content="1. 概念http://blog.csdn.net/u011080472/article/details/51324422 1.0 并发和并行这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，它们可以解释如下。  并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。  并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://otlnkjq1m.bkt.clouddn.com/GC-01.png">
<meta property="og:image" content="http://otlnkjq1m.bkt.clouddn.com/GC-02.png">
<meta property="og:image" content="http://otlnkjq1m.bkt.clouddn.com/GC-03.png">
<meta property="og:image" content="http://otlnkjq1m.bkt.clouddn.com/GC-04.png">
<meta property="og:image" content="http://otlnkjq1m.bkt.clouddn.com/GC-05.png">
<meta property="og:image" content="http://otlnkjq1m.bkt.clouddn.com/GC-06.png">
<meta property="og:image" content="http://otlnkjq1m.bkt.clouddn.com/GC-07.png">
<meta property="og:image" content="http://otlnkjq1m.bkt.clouddn.com/GC-08.png">
<meta property="og:image" content="http://otlnkjq1m.bkt.clouddn.com/GC-09.png">
<meta property="og:image" content="http://otlnkjq1m.bkt.clouddn.com/GC-10.png">
<meta property="og:image" content="http://otlnkjq1m.bkt.clouddn.com/GC-11.png">
<meta property="og:image" content="http://otlnkjq1m.bkt.clouddn.com/GC-12.png">
<meta property="og:image" content="http://otlnkjq1m.bkt.clouddn.com/GC-13.png">
<meta property="og:updated_time" content="2018-04-01T20:35:48.679Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JVM GC相关问题">
<meta name="twitter:description" content="1. 概念http://blog.csdn.net/u011080472/article/details/51324422 1.0 并发和并行这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，它们可以解释如下。  并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。  并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，">
<meta name="twitter:image" content="http://otlnkjq1m.bkt.clouddn.com/GC-01.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://bungder.github.io/2018/04/02/jvm-gc-issues/"/>





  <title>JVM GC相关问题 | Gordon</title>
  







  <script type="text/javascript">
    (function() {
      var hm = document.createElement("script");
      hm.src = "//tajs.qq.com/stats?sId=63160470";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Gordon</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://bungder.github.io/2018/04/02/jvm-gc-issues/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Gordon">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://otlnkjq1m.bkt.clouddn.com/3251115.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Gordon">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">JVM GC相关问题</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-02T04:10:21+08:00">
                2018-04-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i> PV
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><p><a href="http://blog.csdn.net/u011080472/article/details/51324422" target="_blank" rel="external">http://blog.csdn.net/u011080472/article/details/51324422</a></p>
<h2 id="1-0-并发和并行"><a href="#1-0-并发和并行" class="headerlink" title="1.0 并发和并行"></a>1.0 并发和并行</h2><p>这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，它们可以解释如下。</p>
<ul>
<li><p>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p>
</li>
<li><p>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</p>
</li>
</ul>
<h2 id="1-1-Minor-GC-和-Full-GC"><a href="#1-1-Minor-GC-和-Full-GC" class="headerlink" title="1.1 Minor GC 和 Full GC"></a>1.1 Minor GC 和 Full GC</h2><ul>
<li><p>新生代GC（Minor GC / Young GC /  YGC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p>
</li>
<li><p>老年代GC（Major GC / Full GC / FGC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</p>
</li>
</ul>
<a id="more"></a>
<h1 id="2-Java中什么样的对象才能作为gc-root，gc-roots有哪些呢？"><a href="#2-Java中什么样的对象才能作为gc-root，gc-roots有哪些呢？" class="headerlink" title="2 Java中什么样的对象才能作为gc root，gc roots有哪些呢？"></a>2 Java中什么样的对象才能作为gc root，gc roots有哪些呢？</h1><p><span id="gcRoot"></span></p>
<p><a href="http://blog.csdn.net/fenglibing/article/details/8928927" target="_blank" rel="external">http://blog.csdn.net/fenglibing/article/details/8928927</a></p>
<blockquote>
<p>常说的GC(Garbage Collector) roots，特指的是垃圾收集器（Garbage Collector）的对象，GC会收集那些不是GC roots且没有被GC roots引用的对象。</p>
<p>一个对象可以属于多个root，GC root有几下种：</p>
<ul>
<li><strong>Class</strong> - 由系统类加载器(system class loader)加载的对象，这些类是不能够被回收的，他们可以以静态字段的方式保存持有其它对象。我们需要注意的一点就是，通过用户自定义的类加载器加载的类，除非相应的java.lang.Class实例以其它的某种（或多种）方式成为roots，否则它们并不是roots，.</li>
<li><strong>Thread</strong> - 活着的线程</li>
<li><strong>Stack Local</strong> - Java方法的local变量或参数</li>
<li><strong>JNI Local</strong> - JNI方法的local变量或参数</li>
<li><strong>JNI Global</strong> - 全局JNI引用</li>
<li><strong>Monitor Used</strong> - 用于同步的监控对象</li>
<li><strong>Held by JVM</strong> - 用于JVM特殊目的由GC保留的对象，但实际上这个与JVM的实现是有关的。可能已知的一些类型是：系统类加载器、一些JVM知道的重要的异常类、一些用于处理异常的预分配对象以及一些自定义的类加载器等。然而，JVM并没有为这些对象提供其它的信息，因此就只有留给分析分员去确定哪些是属于”JVM持有”的了。</li>
</ul>
</blockquote>
<p><a href="http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html&amp;cp=37_2_3" target="_blank" rel="external">Help - Eclipse Platform</a></p>
<blockquote>
<p><strong>Garbage Collection Roots</strong><br>A garbage collection root is an object that is accessible from outside the heap. The following reasons make an object a GC root:</p>
<ul>
<li><strong>System Class</strong><br>Class loaded by bootstrap/system class loader. For example, everything from the rt.jar like java.util.* .</li>
<li><strong>JNI Local</strong><br>Local variable in native code, such as user defined JNI code or JVM internal code.</li>
<li><strong>JNI Global</strong><br>Global variable in native code, such as user defined JNI code or JVM internal code.</li>
<li><strong>Thread Block</strong><br>Object referred to from a currently active thread block.</li>
<li><strong>Thread</strong><br>A started, but not stopped, thread.</li>
<li><strong>Busy Monitor</strong><br>Everything that has called wait() or notify() or that is synchronized. For example, by calling synchronized(Object) or by entering a synchronized method. Static method means class, non-static method means object.</li>
<li><strong>Java Local</strong><br>Local variable. For example, input parameters or locally created objects of methods that are still in the stack of a thread.</li>
<li><strong>Native Stack</strong><br>In or out parameters in native code, such as user defined JNI code or JVM internal code. This is often the case as many methods have native parts and the objects handled as method parameters become GC roots. For example, parameters used for file/network I/O methods or reflection.</li>
<li><strong>Finalizable</strong><br>An object which is in a queue awaiting its finalizer to be run.</li>
<li><strong>Unfinalized</strong><br>An object which has a finalize method, but has not been finalized and is not yet on the finalizer queue.</li>
<li><strong>Unreachable</strong><br>An object which is unreachable from any other root, but has been marked as a root by MAT to retain objects which otherwise would not be included in the analysis.</li>
<li><strong>Java Stack Frame</strong><br>A Java stack frame, holding local variables. Only generated when the dump is parsed with the preference set to treat Java stack frames as objects.</li>
<li><strong>Unknown</strong><br>An object of unknown root type. Some dumps, such as IBM Portable Heap Dump files, do not have root information. For these dumps the MAT parser marks objects which are have no inbound references or are unreachable from any other root as roots of this type. This ensures that MAT retains all the objects in the dump.</li>
</ul>
</blockquote>
<p><a href="https://www.zhihu.com/question/53613423/answer/135743258" target="_blank" rel="external">java的gc为什么要分代？ - 知乎</a></p>
<blockquote>
<p>作者：RednaxelaFX<br>链接：<a href="https://www.zhihu.com/question/53613423/answer/135743258" target="_blank" rel="external">https://www.zhihu.com/question/53613423/answer/135743258</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p><strong>所谓“GC roots”，或者说tracing GC的“根集合”，就是一组必须活跃的引用</strong>。<br>例如说，这些引用可能包括：</p>
<ul>
<li>所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。</li>
<li>VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。</li>
<li>JNI handles，包括global handles和local handles（看情况）</li>
<li>所有当前被加载的Java类（看情况）</li>
<li>Java类的引用类型静态变量（看情况）</li>
<li>Java类的运行时常量池里的引用类型常量（String或Class类型）（看情况）</li>
<li>String常量池（StringTable）里的引用</li>
</ul>
<p>注意，是一组必须<strong>活跃的引用，不是对象</strong>。<br>Tracing GC的根本思路就是：给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，其余对象（也就是没有被遍历到的）就自然被判定为死亡。注意再注意：tracing GC的本质是通过找出所有活对象来把其余空间认定为“无用”，而不是找出所有死掉的对象并回收它们占用的空间。<br>GC roots这组引用是tracing GC的起点。要实现语义正确的tracing GC，就必须要能完整枚举出所有的GC roots，否则就可能会漏扫描应该存活的对象，导致GC错误回收了这些被漏扫的活对象。<br>这就像任何递归定义的关系一样，如果只定义了递推项而不定义初始项的话，关系就无法成立——无从开始；而如果初始项定义漏了内容的话，递推出去也会漏内容。</p>
<p><strong>那么分代式GC对GC roots的定义有什么影响呢？</strong><br>答案是：分代式GC是一种部分收集（partial collection）的做法。在执行部分收集时，从GC堆的非收集部分指向收集部分的引用，也必须作为GC roots的一部分。具体到分两代的分代式GC来说，如果第0代叫做young gen，第1代叫做old gen，那么如果有minor GC / young GC只收集young gen里的垃圾，则young gen属于“收集部分”，而old gen属于“非收集部分”，那么从old gen指向young gen的引用就必须作为minor GC / young GC的GC roots的一部分。</p>
<p>继续具体到HotSpot VM里的分两代式GC来说，除了old gen到young gen的引用之外，有些带有弱引用语义的结构，例如说记录所有当前被加载的类的SystemDictionary、记录字符串常量引用的StringTable等，在young GC时必须要作为strong GC roots，而在收集整堆的full GC时则不会被看作strong GC roots。</p>
<p>换句话说，young GC比full GC的GC roots还要更大一些。</p>
<p><strong>那么分代有什么好处？</strong><span id="goodsForGeneration"><br>对传统的、基本的GC实现来说，由于它们在GC的整个工作过程中都要“stop-the-world”，如果能想办法缩短GC一次工作的时间长度就是件重要的事情。如果说收集整个GC堆耗时太长，那不如只收集其中的一部分？<br>于是就有好几种不同的划分（partition）GC堆的方式来实现部分收集，而分代式GC就是这其中的一个思路。<br>这个思路所基于的基本假设大家都很熟悉了：<strong>weak generational hypothesis</strong>——大部分对象的生命期很短（die young），而没有die young的对象则很可能会存活很长时间（live long）。<br>这是对过往的很多应用行为分析之后得出的一个假设。基于这个假设，如果让新创建的对象都在young gen里创建，然后频繁收集young gen，则大部分垃圾都能在young GC中被收集掉。<strong>由于young gen的大小配置通常只占整个GC堆的较小部分，而且较高的对象死亡率（或者说较低的对象存活率）让它非常适合使用copying算法来收集，这样就不但能降低单次GC的时间长度，还可以提高GC的工作效率</strong>。（参见<a href="#threeComparing">三种基本算法的对比</a>）</span></p>
<p>放几个传送门：</p>
<ul>
<li><a href="https://www.zhihu.com/question/33210180/answer/56348818" target="_blank" rel="external">JVM GC遍历一次新生代所有对象是否可达需要多久？- RednaxelaFX 的回答 - 知乎</a></li>
<li><a href="https://www.zhihu.com/question/42181722/answer/93871206" target="_blank" rel="external">有关 Copying GC 的疑问？- RednaxelaFX 的回答 - 知乎</a></li>
</ul>
<p>但是！有些比较先进的GC算法是增量式（incremental）的，或者部分并发（mostly-concurrent），或者干脆完全并发（fully-concurrent）的。<br>例如鄙司Azul Systems的<strong>Zing JVM里的C4 GC</strong>，就是一个完全并发的GC算法。它不存在“GC整个工作流程中都要把应用stop-the-world”的问题——从算法的设计上就不存在。<br>然而C4却也是一个分两代的分代式GC。为什么呢？<br>C4 GC的前身是Azul System的上一代JVM里的“Pauseless GC”算法，而Pauseless是一个完全并发但是不分代的GC。<br>Oracle的HotSpot VM里的G1 GC，在最初设计的时候是不分代的部分并发+增量式GC，而后来在实际投入生产的时候使用的却也是分两代的分代式GC设计。现在Red Hat正在开发中的Shenandoah GC是一个并发GC，它目前的设计还是不分代的，但根据过往经验看，它后期渐渐发展为分代式的可能性极其高——如果这个项目能活足够久的话。<br>对于这些GC来说，解决stop-the-world时间太长的问题并不是选择分代的主要原因。<br>就Azul的Pauless到C4的发展历程来看，<strong>选择实现分代的最大好处是，GC能够应付的应用内存分配速率（allocation rate）可以得到巨大的提升</strong>。<br>并发GC根本上要跟应用玩追赶游戏：应用一边在分配，GC一边在收集，如果GC收集的速度能跟得上应用分配的速度，那就一切都很完美；一旦GC开始跟不上了，垃圾就会渐渐堆积起来，最终到可用空间彻底耗尽的时候，应用的分配请求就只能暂时等一等了，等GC追赶上来。<br>所以，对于一个并发GC来说，能够尽快回收出越多空间，就能够应付越高的应用内存分配速率，从而更好地保持GC以完美的并发模式工作。<br>虽然并不是所有应用中的对象生命周期都完美吻合weak generational hypothesis的假设，但<strong>这个假设在很大范围内还是适用的</strong>，因而也可以帮助并发GC改善性能。</p>
</blockquote>
<h1 id="3-GC算法"><a href="#3-GC算法" class="headerlink" title="3 GC算法"></a>3 GC算法</h1><h2 id="3-1-判断是否回收"><a href="#3-1-判断是否回收" class="headerlink" title="3.1 判断是否回收"></a>3.1 判断是否回收</h2><h3 id="3-1-1-标记算法"><a href="#3-1-1-标记算法" class="headerlink" title="3.1.1 标记算法"></a>3.1.1 标记算法</h3><h4 id="3-1-1-1-引用计数（Reference-Counting）算法"><a href="#3-1-1-1-引用计数（Reference-Counting）算法" class="headerlink" title="3.1.1.1 引用计数（Reference Counting）算法"></a>3.1.1.1 引用计数（Reference Counting）算法</h4><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<ul>
<li>优点<ul>
<li>实现简单，判断效率高</li>
</ul>
</li>
<li>缺点<ul>
<li>不能解决<strong>循环引用</strong>问题<br>例如a引用了b，同时b又引用了a。</li>
</ul>
</li>
</ul>
<p>主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互<strong>循环引用</strong>的问题。</p>
<h4 id="3-1-1-2-可达性分析（Reachability-Analysis）算法"><a href="#3-1-1-2-可达性分析（Reachability-Analysis）算法" class="headerlink" title="3.1.1.2 可达性分析（Reachability Analysis）算法"></a>3.1.1.2 可达性分析（Reachability Analysis）算法</h4><p>周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）:</p>
<blockquote>
<p>这个算法的基本思路就是通过一系列的称为”<strong>GC Roots</strong>“的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p>
</blockquote>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/GC-01.png" alt=""></p>
<blockquote>
<p>在Java语言中，可作为<a href="#gcRoot">GCRoots</a>的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>
</ul>
</blockquote>
<h3 id="3-1-2-引用"><a href="#3-1-2-引用" class="headerlink" title="3.1.2 引用"></a>3.1.2 引用</h3><p>在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为了4种：</p>
<ul>
<li>强引用（Strong Reference）<ul>
<li>类似 <code>Object obj = new Object()</code>的引用</li>
<li>垃圾回收器永远不会回收被引用的对象</li>
</ul>
</li>
<li>软引用（Soft Reference）<ul>
<li>描述一些还有用但是非必需的对象</li>
<li>在系统将要发生内存溢出异常之前，会将这些被引用对象列入回收范围内</li>
<li>JDK 1.2之后提供了<strong>SoftReference</strong>类来实现</li>
</ul>
</li>
<li>弱引用（Weak Reference）<ul>
<li>也用于描述非必需对象，但强度比软引用更弱</li>
<li>被引用对象只能生存到下一次GC发生之前</li>
<li>JDK 1.2之后提供了<strong>WeakReference</strong>类来实现</li>
</ul>
</li>
<li>虚引用（Phantom Reference）<ul>
<li>也称为幽灵引用或者幻影引用，引用关系最弱</li>
<li>完全不影响生存时间</li>
<li>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li>
<li>在JDK 1.2之后，提供了<strong>PhantomReference</strong>类来实现虚引用。</li>
</ul>
</li>
</ul>
<p>这4种引用强度依次逐渐减弱。</p>
<h3 id="3-1-3-二次标记"><a href="#3-1-3-二次标记" class="headerlink" title="3.1.3 二次标记"></a>3.1.3 二次标记</h3><p>周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）:</p>
<blockquote>
<p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做<strong>F-Queue</strong>的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。</p>
</blockquote>
<h3 id="3-1-4-回收方法区"><a href="#3-1-4-回收方法区" class="headerlink" title="3.1.4 回收方法区"></a>3.1.4 回收方法区</h3><p>周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）:</p>
<blockquote>
<p>很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%～95%的空间，而永久代的垃圾收集效率远低于此。</p>
<p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串”abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做”abc”的，换句话说，就是没有任何String对象引用常量池中的”abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个”abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p>
<p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了<strong>-Xnoclassgc</strong>参数进行控制，还可以使用<strong>-verbose:class</strong>以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息，其中-verbose:class和-XX:+TraceClassLoading可以在Product版的虚拟机中使用，-XX:+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。</p>
<p>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>
</blockquote>
<h2 id="3-2-一般的算法"><a href="#3-2-一般的算法" class="headerlink" title="3.2 一般的算法"></a>3.2 一般的算法</h2><p><span id="gcAlgorithm"></span></p>
<h3 id="3-2-1-标记-清除（Mark-Sweep）算法"><a href="#3-2-1-标记-清除（Mark-Sweep）算法" class="headerlink" title="3.2.1 标记-清除（Mark-Sweep）算法"></a>3.2.1 标记-清除（Mark-Sweep）算法</h3><p>周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）:</p>
<blockquote>
<p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“<strong>标记</strong>”和“<strong>清除</strong>”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以说它是最基础的收集算法，是因为<strong>后续的收集算法都是基于这种思路并对其不足进行改进而得到的</strong>。它的主要不足有两个：</p>
<ul>
<li><strong>效率问题</strong>，标记和清除两个过程的效率都不高；</li>
<li><strong>空间问题</strong>，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ul>
</blockquote>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/GC-02.png" alt=""></p>
<h3 id="3-2-2-复制（Copying）算法"><a href="#3-2-2-复制（Copying）算法" class="headerlink" title="3.2.2 复制（Copying）算法"></a>3.2.2 复制（Copying）算法</h3><p>周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）:</p>
<blockquote>
<p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。</p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/GC-03.png" alt=""></p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为<strong>一块较大的Eden空间</strong>和<strong>两块较小的Survivor空间</strong>，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p>
<p>内存的分配担保就好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。内存的分配担保也一样，如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p>
</blockquote>
<p><a href="https://www.zhihu.com/question/33210180/answer/56348818" target="_blank" rel="external">JVM GC遍历一次新生代所有对象是否可达需要多久？ - 知乎</a>：<br><strong>Copying GC算法的特征之一就是它的开销只跟活对象的多少（live data set）有关系，而跟它所管理的堆空间的大小没关系。</strong></p>
<h3 id="3-2-3-标记-整理（Mark-Compact）算法"><a href="#3-2-3-标记-整理（Mark-Compact）算法" class="headerlink" title="3.2.3 标记-整理（Mark-Compact）算法"></a>3.2.3 标记-整理（Mark-Compact）算法</h3><p>周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）:</p>
<blockquote>
<p>复制收集算法<strong>在对象存活率较高时</strong>就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是<strong>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</strong>。</p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/GC-04.png" alt=""></p>
</blockquote>
<h3 id="3-2-4-分代收集（Generational-Collection）算法"><a href="#3-2-4-分代收集（Generational-Collection）算法" class="headerlink" title="3.2.4 分代收集（Generational Collection）算法"></a>3.2.4 分代收集（Generational Collection）算法</h3><p>周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）:</p>
<blockquote>
<p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为<strong>新生代</strong>和<strong>老年代</strong>，这样就可以<strong>根据各个年代的特点采用最适当的收集算法</strong>。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p>
</blockquote>
<p>分代收集的好处参见<a href="#goodsForGeneration">此处</a>。</p>
<h3 id="3-2-5-三种基本算法对比"><a href="#3-2-5-三种基本算法对比" class="headerlink" title="3.2.5 三种基本算法对比"></a>3.2.5 三种基本算法对比</h3><p><span id="threeComparing"></span></p>
<table>
<thead>
<tr>
<th>-</th>
<th>mark-sweep</th>
<th>mark-compact</th>
<th>copying</th>
</tr>
</thead>
<tbody>
<tr>
<td>速度</td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td>空间开销</td>
<td>少（但会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>通常需要活对象的2倍大小（不堆积碎片）</td>
</tr>
<tr>
<td>移动对象？</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
<blockquote>
<p>关于时间开销：<br>mark-sweep：mark阶段与活对象的数量成正比，sweep阶段与整堆大小成正比<br>mark-compact：mark阶段与活对象的数量成正比，compact阶段与活对象的大小成正比<br>copying：与活对象大小成正比 </p>
<p>如果把mark、sweep、compact、copying这几种动作的耗时放在一起看，大致有这样的关系：<br><strong>compaction &gt;= copying &gt; marking &gt; sweeping </strong><br>还有 <strong>marking + sweeping &gt; copying</strong><br>（虽然compactiont与copying都涉及移动对象，但取决于具体算法，compact可能要先计算一次对象的目标地址，然后修正指针，然后再移动对象；copying则可以把这几件事情合为一体来做，所以可以快一些。<br>另外还需要留意GC带来的开销不能只看collector的耗时，还得看allocator一侧的。如果能保证内存没碎片，分配就可以用pointer bumping方式，只有挪一个指针就完成了分配，非常快；而如果内存有碎片就得用freelist之类的方式管理，分配速度通常会慢一些。） </p>
<p><strong>在分代式假设中，年轻代中的对象在minor GC时的存活率应该很低，这样用copying算法就是最合算的，因为其时间开销与活对象的大小成正比</strong>，如果没多少活对象，它就非常快；而且young gen本身应该比较小，就算需要2倍空间也只会浪费不太多的空间。<br>而年老代被GC时对象存活率可能会很高，而且假定可用剩余空间不太多，这样copying算法就不太合适，于是更可能选用另两种算法，特别是不用移动对象的mark-sweep算法。 </p>
<p>不过HotSpot VM中除了CMS之外的其它收集器都是会移动对象的，也就是要么是copying、要么是mark-compact的变种。 </p>
</blockquote>
<h2 id="3-3-HotSpot的算法实现"><a href="#3-3-HotSpot的算法实现" class="headerlink" title="3.3 HotSpot的算法实现"></a>3.3 HotSpot的算法实现</h2><h3 id="3-3-1-枚举根节点"><a href="#3-3-1-枚举根节点" class="headerlink" title="3.3.1 枚举根节点"></a>3.3.1 枚举根节点</h3><blockquote>
<p>从可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。</p>
<p>另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保<strong>一致性</strong>的快照中进行——这里“一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿所有Java执行线程（Sun将这件事情称为”<strong>Stop The World</strong>“）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p>
<p>由于目前的主流Java虚拟机使用的都是<strong>准确式GC</strong>（这个概念在第1章介绍Exact VM对Classic VM的改进时讲过），所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为<strong>OopMap</strong>的数据结构来达到这个目的的：</p>
<ul>
<li><strong>在类加载完成的时候</strong>，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，</li>
<li><strong>在JIT编译过程中</strong>，也会在特定的位置记录下栈和寄存器中哪些位置是引用。</li>
</ul>
<p>这样，GC在扫描时就可以直接得知这些信息了。</p>
</blockquote>
<h3 id="3-3-2-安全点（Safepoint）"><a href="#3-3-2-安全点（Safepoint）" class="headerlink" title="3.3.2 安全点（Safepoint）"></a>3.3.2 安全点（Safepoint）</h3><blockquote>
<p>在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说<strong>OopMap内容变化的指令非常多</strong>，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。</p>
<p>实际上，HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“<strong>特定的位置</strong>”记录了这些信息，这些位置称为<strong>安全点（Safepoint）</strong>，即程序执行时并非在所有地方都能停顿下来开始GC，<strong>只有在到达安全点时才能暂停</strong>。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“<strong>是否具有让程序长时间执行的特征</strong>”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是<strong>指令序列复用，例如方法调用、循环跳转、异常跳转等</strong>，所以具有这些功能的指令才会产生Safepoint。</p>
<p>对于Sefepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来（<strong>Mutator suspension</strong>）。这里有两种方案可供选择：</p>
<ul>
<li><strong>抢先式中断（Preemptive Suspension）</strong><br>不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。</li>
<li><strong>主动式中断（Voluntary Suspension）</strong><br>思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志（<a href="#pollingPoint"><strong>Polling Point</strong></a>），各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</li>
</ul>
</blockquote>
<p>简单的解释：</p>
<blockquote>
<p>In order to support <strong>precise enumeration</strong>, JIT compiler should do additional work, because only JIT knows exactly stack frame info and register contents. When JIT compiles a method, for every instruction, it can <strong>book-keep the root reference information</strong> in case the execution is suspended at that instruction. </p>
<p>But to remember the info for every instruction is <strong>too expensive</strong>. It requires substantial space to store the information. This is also unnecessary, because <strong>only a few instructions will have the chances to be the suspension points in real execution</strong>. JIT <strong>only needs to book-keep information for those instruction points</strong> – they are called safe-points. Safe-point means it is a safe suspension point for root set enumeration.</p>
</blockquote>
<p>进一步阐述：<br><a href="https://www.zhihu.com/question/29268019/answer/43762165" target="_blank" rel="external">现代JVM中的Safe Region和Safe Point到底是如何定义和划分的?</a></p>
<blockquote>
<p>作者：RednaxelaFX<br>链接：<a href="https://www.zhihu.com/question/29268019/answer/43762165" target="_blank" rel="external">https://www.zhihu.com/question/29268019/answer/43762165</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>其实在高度优化的现代JVM里，safepoint有几种不同的用法。GC safepoint是最常见、大家听说得最多的，但还有deoptimization safepoint也很重要。<br>在HotSpot VM里，这两种safepoint目前实现在一起，但其实概念上它们俩没有直接联系，需要的数据不一样。<br>无论是哪种safepoint，最简洁的定义是<strong>“A point in program where the state of execution is known by the VM”</strong>。这里“state of execution”特意说得模糊，是因为不同种类的safepoint需要的数据不一样。<br><strong>GC safepoint需要知道在那个程序位置上，调用栈、寄存器等一些重要的数据区域里什么地方包含了GC管理的指针；</strong><br>Deoptimization safepoint需要知道在那个程序位置上，原本抽象概念上的JVM的执行状态（所有局部变量、临时变量、锁，等等）到底分配到了什么地方，是在栈帧￼的具体某个slot还是在某个寄存器里，之类的。<br>如果要触发一次GC，那么JVM里的所有Java线程都必须到达GC safepoint；<br>如果要执行一次deoptimization，那么需要执行deoptimization的线程要在到达deoptimization safepoint之后才可以开始deoptimize。<br>不同JVM实现会选用不同的位置放置safepoint。<br>以HotSpot VM为例，<br>在解释器里每条字节码的边界都可以是一个safepoint，因为HotSpot的解释器总是能很容易的找出完整的“state of execution”。<br>而在JIT编译的代码里，HotSpot会在所有方法的临返回之前，以及所有非counted loop的循环的回跳之前放置safepoint。<br>HotSpot的JIT编译器不但会生成机器码，还会额外在每个safepoint生成一些“调试符号信息”，以便VM能找到所需的“state of execution”。<br>为GC生成的符号信息是<strong>OopMap</strong>，指出栈上和寄存器里哪里有GC管理的指针；<br>为deoptimization生成的符号信息是debugInfo，指出如果要把当前栈帧从compiled frame转换为interpreted frame的话，要从哪里把相应的局部变量、临时变量、锁等信息找出来。<br><strong>之所以只在选定的位置放置safepoint是因为：</strong></p>
<ul>
<li><strong>挂在safepoint的调试符号信息要占用空间</strong>。如果允许每条机器码都可以是safepoint的话，需要存储的数据量会很大（当然这有办法解决，例如用delta存储和用压缩）</li>
<li><strong>safepoint会影响优化</strong>。特别是deoptimization safepoint，会迫使JVM保留一些只有解释器可能需要的、JIT编译器认定无用的变量的值。本来JIT编译器可能可以发现某些值不需要而消除它们对应的运算，如果在safepoint需要这些值的话那就只好保留了。这才是更重要的地方，所以要尽量少放置safepoint</li>
<li>像<strong>HotSpot VM</strong>这样，在safepoint会生成polling代码询问VM是否要“进入safepoint”，<strong>polling也有开销</strong>所以要尽量减少。</li>
</ul>
<p>还有一种情况是当某个线程在执行native函数的时候。此时该线程在执行JVM管理之外的代码，不能对JVM的执行状态做任何修改，因而JVM要进入safepoint不需要关心它。所以也<strong>可以把正在执行native函数的线程看作“已经进入了safepoint”，或者把这种情况叫做“在safe-region里”</strong>。<br>JVM外部要对JVM执行状态做修改必须要通过JNI。<strong>所有能修改JVM执行状态的JNI函数在入口处都有safepoint检查，一旦JVM已经发出通知说此时应该已经到达safepoint就会在这些检查的地方停下来把控制权交给JVM。</strong><br>换一个JVM说，JRockit选择放置safepoint的地方在方法的入口以及循环末尾回跳之前，跟HotSpot略为不同。</p>
</blockquote>
<h3 id="3-3-3-Polling-Point"><a href="#3-3-3-Polling-Point" class="headerlink" title="3.3.3 Polling Point"></a>3.3.3 Polling Point</h3><p><span id="pollingPoint"></span></p>
<p><a href="http://xiao-feng.blogspot.com/2008/01/gc-safe-point-and-safe-region.html" target="_blank" rel="external">GC safe-point (or safepoint) and safe-region | Xiao-Feng Li</a></p>
<blockquote>
<p> For voluntary suspension, a more serious problem is the polling overhead. So the basic principles for polling point insertion are: Firstly, <strong>polling points should be frequent enough</strong> so that GC does not wait too long for a mutator to suspend, because other mutators might be waiting for GC to free the space in order to continue. Secondly, <strong>polling points should not be too frequent</strong> to introduce big runtime overhead. </p>
<p>The best result is to have only adequate polling points that are necessary and sufficient. </p>
<ol>
<li>The mandatory polling points are the allocation sites. Allocation can trigger collection, so allocation site has to be a safe point. </li>
<li>Long-time execution are always associated with method call or loop. So call sites and loop back sites are also expected polling points. </li>
</ol>
<p>Those are the sites for polling points in Harmony: <strong>allocation sites</strong>, <strong>call sites</strong> and <strong>loop back sites</strong>. Mostly the runtime overhead is smaller than 1%. </p>
</blockquote>
<h3 id="3-3-4-安全区域（Safe-Region）"><a href="#3-3-4-安全区域（Safe-Region）" class="headerlink" title="3.3.4 安全区域（Safe Region）"></a>3.3.4 安全区域（Safe Region）</h3><blockquote>
<p>使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却并不一定。Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候<strong>线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决</strong>。</p>
<p><strong>安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的safe-point。</strong></p>
<p>在线程执行到SafeRegion中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p>
</blockquote>
<p><a href="http://xiao-feng.blogspot.com/2008/01/gc-safe-point-and-safe-region.html" target="_blank" rel="external">GC safe-point (or safepoint) and safe-region | Xiao-Feng Li</a></p>
<blockquote>
<p>In safe-point design, the mutator polling for GC event will respond <strong>if the event is triggered</strong>. It <strong>responds by setting a ready flag</strong> when it’s sure to suspend. <strong>Then the GC can proceed</strong> with root set enumeration. This is a <strong>hand-shaking</strong> protocol. </p>
<p>Safe-region just follows this protocol. The mutator sets the ready flag when it enters a safe-region. Before it leaves the region, it checks if GC has finished its enumeration (or collection), and no longer needs the mutator under suspension state. If it’s true, it goes ahead and leaves the region; otherwise, it suspends itself as in a safe-point.</p>
<p>In Harmony implementation, we insert <strong>suspend_enable</strong> and <strong>suspend_disable</strong> to delimit the scope of safe-region.</p>
</blockquote>
<h1 id="4-各种垃圾收集器的异同"><a href="#4-各种垃圾收集器的异同" class="headerlink" title="4 各种垃圾收集器的异同"></a>4 各种垃圾收集器的异同</h1><h2 id="4-1-HotSpot"><a href="#4-1-HotSpot" class="headerlink" title="4.1 HotSpot"></a>4.1 HotSpot</h2><ul>
<li><a href="http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf" target="_blank" rel="external">Memory Management in the Java HotSpot™ Virtual Machine</a></li>
<li><img src="http://otlnkjq1m.bkt.clouddn.com/GC-05.png" alt=""></li>
</ul>
<h3 id="4-1-1-GC自适应的调节策略（GC-Ergonomics）"><a href="#4-1-1-GC自适应的调节策略（GC-Ergonomics）" class="headerlink" title="4.1.1 GC自适应的调节策略（GC Ergonomics）"></a>4.1.1 GC自适应的调节策略（GC Ergonomics）</h3><p><span id="GCErgonomics"></span></p>
<p><a href="https://blog.codecentric.de/en/2013/01/useful-jvm-flags-part-6-throughput-collector/" target="_blank" rel="external">Useful JVM Flags - Part 6 (Throughput Collector) - codecentric AG Blog</a></p>
<blockquote>
<p>The throughput collectors offer an interesting (but common, at least on modern JVMs) mechanism to improve user-friendliness of GC configuration. This mechanism is part of what is known as “ergonomics”, a concept <strong>introduced for HotSpot with Java 5</strong>. With ergonomics, <strong>the garbage collector may dynamically apply modifications to the different heap areas sizes as well as the GC settings if it has evidence that these modifications would improve GC performance</strong>. The precise meaning of “improve GC performance” may be specified by the user via the flags <code>-XX:GCTimeRatio</code> and <code>-XX:MaxGCPauseMillis</code> (see below).</p>
<p>It is important to know that <strong>ergonomics is activated by default</strong> – which is fine, as adaptive behavior is one of the biggest strengths of the JVM. Still, sometimes we may have a pretty clear idea of what settings are best for a particular application, and in these cases we might not want the JVM to mess around with our settings. Whenever we find ourselves in such a situation, we may consider deactivating some of the ergonomics by setting <strong><code>-XX:-UseAdaptiveSizePolicy</code></strong>.</p>
</blockquote>
<p><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/vm/gc-ergonomics.html" target="_blank" rel="external">Garbage Collection Ergonomics</a></p>
<blockquote>
<p><strong>Garbage Collector Ergonomics</strong><br>The following changes take effect with J2SE 5.0.</p>
<ul>
<li><p>Implementation of <strong><code>-XX:+UseAdaptiveSizePolicy</code></strong> Used by Parallel Garbage Collector Changed</p>
<p>  <strong>The implementation of -XX:+UseAdaptiveSizePolicy used by default with the -XX:+UseParallelGC garbage collector</strong> has changed to consider <strong>three goals</strong>:</p>
<ul>
<li>a desired maximum GC pause goal</li>
<li>a desired application throughput goal</li>
<li>minimum footprint</li>
</ul>
</li>
<li><p><strong>Suggested strategy</strong><br>Do not choose a maximum value for the heap unless you know that the heap is greater than the default maximum heap size. Choose a throughput goal that is sufficient for your application.</p>
<ul>
<li><p>In an ideal situation the heap will grow to a value (less than the maximum) that will support the chosen throughput goal.</p>
</li>
<li><p>If the heap grows to its maximum, the throughput cannot be met within that maximum. Set the maximum heap as large as you can, but no larger than the size of physical memory on the platform, and execute the application again. If the throughput goal can still not be met, then it is too high for the available memory on the platform.</p>
</li>
<li><p>If the throughput goal can be met but there are pauses that are too long, select a pause time goal. This will likely mean that your throughput goal will not be met, so choose values that are an acceptable compromise for the application.</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="4-1-2-Fast-Allocation"><a href="#4-1-2-Fast-Allocation" class="headerlink" title="4.1.2 Fast Allocation"></a>4.1.2 Fast Allocation</h3><p>这个概念应该不重要，很多地方都没提到，就<a href="http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf" target="_blank" rel="external">Memory Management in the Java HotSpot™ Virtual Machine</a>提到了这个概念。</p>
<h3 id="4-1-3-Serial-Collector"><a href="#4-1-3-Serial-Collector" class="headerlink" title="4.1.3 Serial Collector"></a>4.1.3 Serial Collector</h3><p>单线程的收集器，是JVM在client模式下运行的默认收集器。</p>
<p>Serial收集器新生代垃圾收集器，<strong>采用复制算法</strong>。</p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/GC-06.png" alt=""></p>
<ul>
<li>优点：<ul>
<li>简单而高效<br>对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得较高的收集效率</li>
</ul>
</li>
</ul>
<h3 id="4-1-4-Serial-Old-Collector"><a href="#4-1-4-Serial-Old-Collector" class="headerlink" title="4.1.4 Serial Old Collector"></a>4.1.4 Serial Old Collector</h3><p><strong>Serial Old是Serial收集器的老年代版本</strong>，它同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p>
<h3 id="4-1-5-ParNew收集器"><a href="#4-1-5-ParNew收集器" class="headerlink" title="4.1.5 ParNew收集器"></a>4.1.5 ParNew收集器</h3><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。</p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/GC-07.png" alt=""></p>
<p><strong>ParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处</strong>，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，<strong>除了Serial收集器外，目前只有它能与CMS收集器配合工作</strong>。在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器——CMS收集器（Concurrent Mark Sweep，本节稍后将详细介绍这款收集器），这款收集器是HotSpot虚拟机中第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作，</p>
<p>不幸的是，CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK 1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。ParNew收集器也是使用-XX:+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX:+UseParNewGC选项来强制指定它。<br><strong>ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果</strong>，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC时系统资源的有效利用还是很有好处的。<strong>它默认开启的收集线程数与CPU的数量相同</strong>，在CPU非常多（譬如32个，现在CPU动辄就4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。</p>
<h3 id="4-1-6-Parallel-Scavenge-收集器"><a href="#4-1-6-Parallel-Scavenge-收集器" class="headerlink" title="4.1.6 Parallel Scavenge 收集器"></a>4.1.6 Parallel Scavenge 收集器</h3><p>Parallel Scavenge收集器是新生代垃圾收集器，使用复制算法，也是并行的多线程收集器。与ParNew收集器相比，很多相似之处，但是Parallel Scavenge收集器更关注可控制的吞吐量。吞吐量越大，垃圾收集的时间越短，则用户代码则可以充分利用CPU资源，尽快完成程序的运算任务。</p>
<p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p>
<ul>
<li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li>
<li>XX:GCRatio 直接设置吞吐量的大小。</li>
</ul>
<p>直观上，只要最大的垃圾收集停顿时间越小，吞吐量是越高的，但是GC停顿时间的缩短是以牺牲吞吐量和新生代空间作为代价的。比如原来10秒收集一次，每次停顿100毫秒，现在变成5秒收集一次，每次停顿70毫秒。停顿时间下降的同时，吞吐量也下降了。</p>
<p>除此之外，Parallel Scavenge收集器还可以设置参数-XX:+UseAdaptiveSizePocily来动态调整停顿时间或者最大的吞吐量，这种方式称为<a href="#GCErgonomics">GC自适应调节策略（GC Ergonomics）</a>，这点是ParNew收集器所没有的。</p>
<h3 id="4-1-7-Parallel-Old-收集器"><a href="#4-1-7-Parallel-Old-收集器" class="headerlink" title="4.1.7 Parallel Old 收集器"></a>4.1.7 Parallel Old 收集器</h3><p><strong>Parallel Old是Parallel Scavenge收集器的老年代版本</strong>，使用多线程和“<strong>标记-整理</strong>”算法。这个收集器是在JDK 1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PS MarkSweep）收集器外别无选择（还记得上面说过Parallel Scavenge收集器无法与CMS收集器配合工作吗？）。由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合“给力”。直到Paralle lOld收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。</p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/GC-08.png" alt=""></p>
<h3 id="4-1-8-Concurrent-Mark-Sweep-CMS-Collector"><a href="#4-1-8-Concurrent-Mark-Sweep-CMS-Collector" class="headerlink" title="4.1.8 Concurrent Mark-Sweep (CMS) Collector"></a>4.1.8 Concurrent Mark-Sweep (CMS) Collector</h3><p>CMS收集器（Concurrent Mark Sweep）的目标就是获取最短回收停顿时间。在注重服务器的响应速度，希望停顿时间最短，则CMS收集器是比较好的选择。</p>
<p>整个执行过程分为以下4个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发<strong>清除</strong></li>
</ul>
<p><strong>初始标记和重新标记这两个步骤仍然需要暂停Java执行线程</strong>，初始标记只是标记GC Roots能够直接关联到的对象，并发标记就是执行GC Roots Tracing的过程，而重新标记就是为了修正并发标记期间因用户程序执行而导致标记发生变动使得标记错误的记录。其执行过程如下：</p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/GC-09.png" alt=""></p>
<p><strong>不足：</strong></p>
<ul>
<li>CMS收集器对CPU资源非常敏感。<br>其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个（譬如2个）时，CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”（Incremental Concurrent MarkSweep/i-CMS）的CMS收集器变种，所做的事情和单CPU年代PC机操作系统使用抢占式来模拟多任务机制的思想一样，就是在并发标记、清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些，也就是速度下降没有那么明显。实践证明，增量时的CMS收集器效果很一般，在目前版本中，i-CMS已经被声明为”deprecated”，即不再提倡用户使用。</li>
<li>CMS收集器无法处理<strong>浮动垃圾（Floating Garbage）</strong>，可能出现”Concurrent Mode Failure”失败而导致另一次Full GC的产生。<br>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。在JDK 1.5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，在JDK 1.6中，CMS收集器的启动阈值已经提升至92%。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次”Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置得太高很容易导致大量”Concurrent Mode Failure”失败，性能反而降低。</li>
<li>CMS是一款<strong>基于“标记—清除”算法</strong>实现的收集器，这意味着收集结束时会有大量<strong>空间碎片</strong>产生。<br>空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。<u>为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程</u>，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。</li>
</ul>
<h3 id="4-1-9-Garbage-First（G1）-Collector"><a href="#4-1-9-Garbage-First（G1）-Collector" class="headerlink" title="4.1.9 Garbage-First（G1） Collector"></a>4.1.9 Garbage-First（G1） Collector</h3><p>G1（Garbage-First）收集器是现今收集器技术的最新成果之一，之前一直处于实验阶段，直到jdk 7u4之后，才正式作为商用的收集器。</p>
<p>与前几个收集器相比，G1收集器有以下特点：</p>
<ul>
<li>并行与并发</li>
<li>分代收集（仍然保留了分代的概念）</li>
<li>空间整合（整体上属于“标记-整理”算法，不会导致空间碎片）</li>
<li>可预测的停顿（比CMS更先进的地方在于能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒）</li>
</ul>
<p>此外，G1收集器将Java堆划分为多个大小相等的Region（独立区域），新生代与老年代都是一部分Region的集合，G1的收集范围则是这一个个Region（化整为零）。</p>
<p>G1的工作过程如下：</p>
<ul>
<li>初始标记（Initial Marking）</li>
<li>并发标记（Concurrent Marking）</li>
<li>最终标记（Final Marking）</li>
<li>筛选回收（Live Data Counting and Evacuation）</li>
</ul>
<p>初始标记阶段仅仅只是标记一下GC Roots能够直接关联的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段的用户程序并发运行的时候，能在正确可用的Region中创建对象，这个阶段需要暂停线程。并发标记阶段从GC Roots进行可达性分析，找出存活的对象，这个阶段是由用户线程并发执行的。最终标记阶段则是修正在并发标记阶段因为用户程序的并发执行而导致标记产生变动的那一部分记录，这部分记录被保存在Remembered Set Logs中，最终标记阶段再把Logs中的记录合并到Remembered Set中，这个阶段是并行执行的，仍然需要暂停用户线程。最后在筛选阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间制定回收计划。整个执行过程如下：</p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/GC-10.png" alt=""></p>
<h1 id="5-GC相关参数"><a href="#5-GC相关参数" class="headerlink" title="5 GC相关参数"></a>5 GC相关参数</h1><p><img src="http://otlnkjq1m.bkt.clouddn.com/GC-11.png" alt=""></p>
<ul>
<li><p>client/serrver端不同的GC方式：<br><img src="http://otlnkjq1m.bkt.clouddn.com/GC-12.png" alt=""></p>
</li>
<li><p>Sun JDK HotSpot虚拟机GC组合方式：<br><img src="http://otlnkjq1m.bkt.clouddn.com/GC-13.png" alt=""></p>
</li>
</ul>
<h1 id="6-GC性能指标"><a href="#6-GC性能指标" class="headerlink" title="6 GC性能指标"></a>6 GC性能指标</h1><p><a href="http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf" target="_blank" rel="external">Memory Management in the Java HotSpot™ Virtual Machine</a></p>
<h2 id="6-1-Throughput-吞吐量"><a href="#6-1-Throughput-吞吐量" class="headerlink" title="6.1 Throughput 吞吐量"></a>6.1 Throughput 吞吐量</h2><blockquote>
<p>the percentage of total time not spent in garbage collection, considered over long periods of time</p>
</blockquote>
<p>（在一段长时间内，在垃圾收集中花费的总时间的百分比）</p>
<blockquote>
<p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即：<br>吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。<br>虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
</blockquote>
<h2 id="6-2-Garbage-collection-overhead-GC耗费"><a href="#6-2-Garbage-collection-overhead-GC耗费" class="headerlink" title="6.2 Garbage collection overhead GC耗费"></a>6.2 Garbage collection overhead GC耗费</h2><blockquote>
<p>the inverse of throughput, that is, the percentage of total time spent in garbage collection</p>
</blockquote>
<p>（吞吐量的倒数，也就是垃圾收集总时间的百分比）</p>
<h2 id="6-3-Pause-time-停顿时间"><a href="#6-3-Pause-time-停顿时间" class="headerlink" title="6.3 Pause time 停顿时间"></a>6.3 Pause time 停顿时间</h2><blockquote>
<p>the length of time during which application execution is stopped while garbage collection is occurring.</p>
</blockquote>
<p>（垃圾收集发生时停止应用程序执行的时间）</p>
<h2 id="6-4-Frequency-of-collection（GC的频率）"><a href="#6-4-Frequency-of-collection（GC的频率）" class="headerlink" title="6.4 Frequency of collection（GC的频率）"></a>6.4 Frequency of collection（GC的频率）</h2><h2 id="6-5-Footprint"><a href="#6-5-Footprint" class="headerlink" title="6.5 Footprint"></a>6.5 Footprint</h2><blockquote>
<p>a measure of size, such as heap size</p>
</blockquote>
<h2 id="6-6-Promptness-速度"><a href="#6-6-Promptness-速度" class="headerlink" title="6.6 Promptness 速度"></a>6.6 Promptness 速度</h2><blockquote>
<p>the time between when an object becomes garbage and when the memory becomes<br>available.</p>
</blockquote>
<p>（从对象变为垃圾到内存变为可用的时间可用。）</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf" target="_blank" rel="external">Memory Management in the Java HotSpot™ Virtual Machine</a></li>
<li><a href="http://blog.csdn.net/u011080472/article/details/51324422" target="_blank" rel="external">【深入理解JVM】：HotSpot垃圾收集器 - CSDN博客</a></li>
<li>周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）</li>
<li><a href="http://xiao-feng.blogspot.com/2008/01/gc-safe-point-and-safe-region.html" target="_blank" rel="external">GC safe-point (or safepoint) and safe-region | Xiao-Feng Li</a></li>
<li><a href="https://www.zhihu.com/question/53613423/answer/135743258" target="_blank" rel="external">java的gc为什么要分代？ - 知乎</a></li>
<li><a href="https://www.zhihu.com/question/29268019/answer/43762165" target="_blank" rel="external">现代JVM中的Safe Region和Safe Point到底是如何定义和划分的?</a></li>
<li><a href="http://hllvm.group.iteye.com/group/topic/38223#post-248757" target="_blank" rel="external">并发垃圾收集器（CMS）为什么没有采用标记-整理算法来实现？ - 讨论 - 高级语言虚拟机 - ITeye群组</a></li>
<li><a href="https://www.zhihu.com/question/33210180/answer/56348818" target="_blank" rel="external">JVM GC遍历一次新生代所有对象是否可达需要多久？ - 知乎</a></li>
<li><a href="https://blog.codecentric.de/en/2013/01/useful-jvm-flags-part-6-throughput-collector/" target="_blank" rel="external">Useful JVM Flags - Part 6 (Throughput Collector) - codecentric AG Blog</a></li>
<li><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/vm/gc-ergonomics.html" target="_blank" rel="external">Garbage Collection Ergonomics</a></li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      Gordon
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="http://bungder.github.io/2018/04/02/jvm-gc-issues/" title="JVM GC相关问题">http://bungder.github.io/2018/04/02/jvm-gc-issues/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
    </li>
    <li class="post-copyright-date">
        2018-4-2 04:04
    </li>
  </ul>


      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
            <a href="/tags/JVM/" rel="tag"># JVM</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/03/15/websocket-abstract/" rel="next" title="WebSocket简介">
                <i class="fa fa-chevron-left"></i> WebSocket简介
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/04/19/java-collection/" rel="prev" title="java-collection">
                java-collection <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="http://otlnkjq1m.bkt.clouddn.com/3251115.jpg"
               alt="Gordon" />
          <p class="site-author-name" itemprop="name">Gordon</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">11</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-概念"><span class="nav-number">1.</span> <span class="nav-text">1. 概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-0-并发和并行"><span class="nav-number">1.1.</span> <span class="nav-text">1.0 并发和并行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-Minor-GC-和-Full-GC"><span class="nav-number">1.2.</span> <span class="nav-text">1.1 Minor GC 和 Full GC</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-Java中什么样的对象才能作为gc-root，gc-roots有哪些呢？"><span class="nav-number">2.</span> <span class="nav-text">2 Java中什么样的对象才能作为gc root，gc roots有哪些呢？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-GC算法"><span class="nav-number">3.</span> <span class="nav-text">3 GC算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-判断是否回收"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 判断是否回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-标记算法"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1 标记算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-1-引用计数（Reference-Counting）算法"><span class="nav-number">3.1.1.1.</span> <span class="nav-text">3.1.1.1 引用计数（Reference Counting）算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-2-可达性分析（Reachability-Analysis）算法"><span class="nav-number">3.1.1.2.</span> <span class="nav-text">3.1.1.2 可达性分析（Reachability Analysis）算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-引用"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2 引用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-二次标记"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.1.3 二次标记</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-4-回收方法区"><span class="nav-number">3.1.4.</span> <span class="nav-text">3.1.4 回收方法区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-一般的算法"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 一般的算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-标记-清除（Mark-Sweep）算法"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1 标记-清除（Mark-Sweep）算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-复制（Copying）算法"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2 复制（Copying）算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-标记-整理（Mark-Compact）算法"><span class="nav-number">3.2.3.</span> <span class="nav-text">3.2.3 标记-整理（Mark-Compact）算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4-分代收集（Generational-Collection）算法"><span class="nav-number">3.2.4.</span> <span class="nav-text">3.2.4 分代收集（Generational Collection）算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-5-三种基本算法对比"><span class="nav-number">3.2.5.</span> <span class="nav-text">3.2.5 三种基本算法对比</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-HotSpot的算法实现"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 HotSpot的算法实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-枚举根节点"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1 枚举根节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-安全点（Safepoint）"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2 安全点（Safepoint）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-Polling-Point"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3.3 Polling Point</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-安全区域（Safe-Region）"><span class="nav-number">3.3.4.</span> <span class="nav-text">3.3.4 安全区域（Safe Region）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-各种垃圾收集器的异同"><span class="nav-number">4.</span> <span class="nav-text">4 各种垃圾收集器的异同</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-HotSpot"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 HotSpot</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-1-GC自适应的调节策略（GC-Ergonomics）"><span class="nav-number">4.1.1.</span> <span class="nav-text">4.1.1 GC自适应的调节策略（GC Ergonomics）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-2-Fast-Allocation"><span class="nav-number">4.1.2.</span> <span class="nav-text">4.1.2 Fast Allocation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-3-Serial-Collector"><span class="nav-number">4.1.3.</span> <span class="nav-text">4.1.3 Serial Collector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-4-Serial-Old-Collector"><span class="nav-number">4.1.4.</span> <span class="nav-text">4.1.4 Serial Old Collector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-5-ParNew收集器"><span class="nav-number">4.1.5.</span> <span class="nav-text">4.1.5 ParNew收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-6-Parallel-Scavenge-收集器"><span class="nav-number">4.1.6.</span> <span class="nav-text">4.1.6 Parallel Scavenge 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-7-Parallel-Old-收集器"><span class="nav-number">4.1.7.</span> <span class="nav-text">4.1.7 Parallel Old 收集器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-8-Concurrent-Mark-Sweep-CMS-Collector"><span class="nav-number">4.1.8.</span> <span class="nav-text">4.1.8 Concurrent Mark-Sweep (CMS) Collector</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-9-Garbage-First（G1）-Collector"><span class="nav-number">4.1.9.</span> <span class="nav-text">4.1.9 Garbage-First（G1） Collector</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-GC相关参数"><span class="nav-number">5.</span> <span class="nav-text">5 GC相关参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-GC性能指标"><span class="nav-number">6.</span> <span class="nav-text">6 GC性能指标</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-Throughput-吞吐量"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 Throughput 吞吐量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-Garbage-collection-overhead-GC耗费"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 Garbage collection overhead GC耗费</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-Pause-time-停顿时间"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 Pause time 停顿时间</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-Frequency-of-collection（GC的频率）"><span class="nav-number">6.4.</span> <span class="nav-text">6.4 Frequency of collection（GC的频率）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-Footprint"><span class="nav-number">6.5.</span> <span class="nav-text">6.5 Footprint</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-Promptness-速度"><span class="nav-number">6.6.</span> <span class="nav-text">6.6 Promptness 速度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reference"><span class="nav-number">7.</span> <span class="nav-text">Reference</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Gordon</span>
</div>

<center>
    <a href="mailto:bungderblog@163.com?subject=From GithubPages">联系我</a>
</center>

<!-- 根据页面mathjax变量决定是否加载MathJax数学公式js -->


        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i> UV
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i> PV
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>


        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  






  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->





  

  

  

  

  

  

</body>
</html>
