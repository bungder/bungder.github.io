<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gordon</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bungder.github.io/"/>
  <updated>2017-08-31T02:47:48.000Z</updated>
  <id>http://bungder.github.io/</id>
  
  <author>
    <name>Gordon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Druid连接池监控的一次改造</title>
    <link href="http://bungder.github.io/2017/08/31/druid-monitor-remould/"/>
    <id>http://bungder.github.io/2017/08/31/druid-monitor-remould/</id>
    <published>2017-08-30T17:32:07.000Z</published>
    <updated>2017-08-31T02:47:48.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>druid本身提供了监控功能，具体在我另一篇博文《<a href="/2017/08/27/druid-monitor/">Druid连接池监控</a>》里有介绍。当时提到有以下缺陷：</p>
<ol>
<li>无法灵活监控多个目标</li>
<li>切换环境不方便</li>
<li>JMX重连不会成功</li>
</ol>
<p>因此针对这些问题，对其进行改造。改造后的源码已经放在个人的github上：<br><a href="https://github.com/bungder/druid-aggregated-monitor" target="_blank" rel="external">https://github.com/bungder/druid-aggregated-monitor</a></p>
<p>对应本文的版本，已经打了tag：<br><a href="https://github.com/bungder/druid-aggregated-monitor/releases/tag/0.0.1" target="_blank" rel="external">https://github.com/bungder/druid-aggregated-monitor/releases/tag/0.0.1</a></p>
<a id="more"></a>
<p>对于在同一个工程里进行监控和展示的情况不进行考虑，具体原因见刚刚提到的博文。</p>
<h1 id="2-原理分析"><a href="#2-原理分析" class="headerlink" title="2. 原理分析"></a>2. 原理分析</h1><p>首先，监控数据的展示是通过<code>com.alibaba.druid.support.http.StatViewServlet</code>实现的，将其源码贴上来分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> com.alibaba.druid.support.http;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.management.MBeanServerConnection;</div><div class="line"><span class="keyword">import</span> javax.management.ObjectName;</div><div class="line"><span class="keyword">import</span> javax.management.remote.JMXConnector;</div><div class="line"><span class="keyword">import</span> javax.management.remote.JMXConnectorFactory;</div><div class="line"><span class="keyword">import</span> javax.management.remote.JMXServiceURL;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletException;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.alibaba.druid.stat.DruidStatService;</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.support.logging.Log;</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.support.logging.LogFactory;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 注意：避免直接调用Druid相关对象例如DruidDataSource等，相关调用要到DruidStatManagerFacade里用反射实现</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> sandzhang&lt;sandzhangtoo@gmail.com&gt;</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatViewServlet</span> <span class="keyword">extends</span> <span class="title">ResourceServlet</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Log      LOG                     = LogFactory.getLog(StatViewServlet.class);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span>     serialVersionUID        = <span class="number">1L</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String    PARAM_NAME_RESET_ENABLE = <span class="string">"resetEnable"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String    PARAM_NAME_JMX_URL      = <span class="string">"jmxUrl"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String    PARAM_NAME_JMX_USERNAME = <span class="string">"jmxUsername"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String    PARAM_NAME_JMX_PASSWORD = <span class="string">"jmxPassword"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> DruidStatService      statService             = DruidStatService.getInstance();</div><div class="line"></div><div class="line">    <span class="comment">/** web.xml中配置的jmx的连接地址 */</span></div><div class="line">    <span class="keyword">private</span> String                jmxUrl                  = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">/** web.xml中配置的jmx的用户名 */</span></div><div class="line">    <span class="keyword">private</span> String                jmxUsername             = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">/** web.xml中配置的jmx的密码 */</span></div><div class="line">    <span class="keyword">private</span> String                jmxPassword             = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> MBeanServerConnection conn                    = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StatViewServlet</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>(<span class="string">"support/http/resources"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">        <span class="keyword">super</span>.init();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            String param = getInitParameter(PARAM_NAME_RESET_ENABLE);</div><div class="line">            <span class="keyword">if</span> (param != <span class="keyword">null</span> &amp;&amp; param.trim().length() != <span class="number">0</span>) &#123;</div><div class="line">                param = param.trim();</div><div class="line">                <span class="keyword">boolean</span> resetEnable = Boolean.parseBoolean(param);</div><div class="line">                statService.setResetEnable(resetEnable);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            String msg = <span class="string">"initParameter config error, resetEnable : "</span> + getInitParameter(PARAM_NAME_RESET_ENABLE);</div><div class="line">            LOG.error(msg, e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 获取jmx的连接配置信息</span></div><div class="line">        String param = readInitParam(PARAM_NAME_JMX_URL);</div><div class="line">        <span class="keyword">if</span> (param != <span class="keyword">null</span>) &#123;</div><div class="line">            jmxUrl = param;</div><div class="line">            jmxUsername = readInitParam(PARAM_NAME_JMX_USERNAME);</div><div class="line">            jmxPassword = readInitParam(PARAM_NAME_JMX_PASSWORD);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                initJmxConn();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                LOG.error(<span class="string">"init jmx connection error"</span>, e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 读取servlet中的配置参数.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> key 配置参数名</div><div class="line">     * <span class="doctag">@return</span> 配置参数值，如果不存在当前配置参数，或者为配置参数长度为0，将返回null</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">readInitParam</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        String value = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            String param = getInitParameter(key);</div><div class="line">            <span class="keyword">if</span> (param != <span class="keyword">null</span>) &#123;</div><div class="line">                param = param.trim();</div><div class="line">                <span class="keyword">if</span> (param.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">                    value = param;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            String msg = <span class="string">"initParameter config ["</span> + key + <span class="string">"] error"</span>;</div><div class="line">            LOG.warn(msg, e);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 初始化jmx连接</div><div class="line">     * </div><div class="line">     * <span class="doctag">@throws</span> IOException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initJmxConn</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (jmxUrl != <span class="keyword">null</span>) &#123;</div><div class="line">            JMXServiceURL url = <span class="keyword">new</span> JMXServiceURL(jmxUrl);</div><div class="line">            Map&lt;String, String[]&gt; env = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span> (jmxUsername != <span class="keyword">null</span>) &#123;</div><div class="line">                env = <span class="keyword">new</span> HashMap&lt;String, String[]&gt;();</div><div class="line">                String[] credentials = <span class="keyword">new</span> String[] &#123; jmxUsername, jmxPassword &#125;;</div><div class="line">                env.put(JMXConnector.CREDENTIALS, credentials);</div><div class="line">            &#125;</div><div class="line">            JMXConnector jmxc = JMXConnectorFactory.connect(url, env);</div><div class="line">            conn = jmxc.getMBeanServerConnection();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 根据指定的url来获取jmx服务返回的内容.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> connetion jmx连接</div><div class="line">     * <span class="doctag">@param</span> url url内容</div><div class="line">     * <span class="doctag">@return</span> the jmx返回的内容</div><div class="line">     * <span class="doctag">@throws</span> Exception the exception</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getJmxResult</span><span class="params">(MBeanServerConnection connetion, String url)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ObjectName name = <span class="keyword">new</span> ObjectName(DruidStatService.MBEAN_NAME);</div><div class="line"></div><div class="line">        String result = (String) conn.invoke(name, <span class="string">"service"</span>, <span class="keyword">new</span> String[] &#123; url &#125;,</div><div class="line">                                             <span class="keyword">new</span> String[] &#123; String.class.getName() &#125;);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 程序首先判断是否存在jmx连接地址，如果不存在，则直接调用本地的duird服务； 如果存在，则调用远程jmx服务。在进行jmx通信，首先判断一下jmx连接是否已经建立成功，如果已经</div><div class="line">     * 建立成功，则直接进行通信，如果之前没有成功建立，则会尝试重新建立一遍。.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> url 要连接的服务地址</div><div class="line">     * <span class="doctag">@return</span> 调用服务后返回的json字符串</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">process</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">        String resp = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (jmxUrl == <span class="keyword">null</span>) &#123;</div><div class="line">            resp = statService.service(url);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;<span class="comment">// 连接在初始化时创建失败</span></div><div class="line">                <span class="keyword">try</span> &#123;<span class="comment">// 尝试重新连接</span></div><div class="line">                    initJmxConn();</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    LOG.error(<span class="string">"init jmx connection error"</span>, e);</div><div class="line">                    resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR,</div><div class="line">                                                             <span class="string">"init jmx connection error"</span> + e.getMessage());</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;<span class="comment">// 连接成功</span></div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        resp = getJmxResult(conn, url);</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        LOG.error(<span class="string">"get jmx data error"</span>, e);</div><div class="line">                        resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR, <span class="string">"get data error:"</span></div><div class="line">                                                                                                     + e.getMessage());</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 连接成功</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    resp = getJmxResult(conn, url);</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    LOG.error(<span class="string">"get jmx data error"</span>, e);</div><div class="line">                    resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR,</div><div class="line">                                                             <span class="string">"get data error"</span> + e.getMessage());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> resp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>首先，现在需要搞清楚的问题有：</p>
<ol>
<li>配置信息是如何生效的</li>
<li>监控数据是怎么流动的</li>
<li>权限控制是怎样实现的</li>
<li>为什么重连会失败</li>
</ol>
<p>逐个方法去看，<code>init</code>方法是初始化的，应该能找到『配置信息是如何生效的』的答案。里面调用了<code>readInitparam</code>方法来读取，而这个方法又调用了<code>getInitParameter</code>方法，进入方法后发现此方法是<code>javax.servlet.GenericServlet</code>里的，已经不是druid的代码，意味着读取参数是通过调用容器的api实现的，这个过程无法进行篡改。</p>
<p>这里只是读取参数值，还没使用，让我们一步步回退回<code>init</code>方法，在读取了参数值之后就调用<code>initJmxConn</code>方法，该方法初始化了与监控目标之间的JMX连接，是关键的地方。但是里面也没多少东西，主要就是根据url去获取连接，对于『为什么重连会失败』，应该也是一个切入点。但是一路点进去看都没发现有重试的机制。</p>
<p>接着往下看，剩下<code>getJmxResult</code>和<code>process</code>两个方法，其注释里已经讲得很明白了。可以发现，在<code>process</code>方法里有重连的机制，那么还是没搞清楚为什么无法重连成功。</p>
<p>在看完这个类之后，可以发现请求的调用链并没有体现出来，所以看它的父类<code>ResourceServlet</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Copyright 1999-2011 Alibaba Group Holding Ltd.</div><div class="line"> *</div><div class="line"> * Licensed under the Apache License, Version 2.0 (the "License");</div><div class="line"> * you may not use this file except in compliance with the License.</div><div class="line"> * You may obtain a copy of the License at</div><div class="line"> *</div><div class="line"> *      http://www.apache.org/licenses/LICENSE-2.0</div><div class="line"> *</div><div class="line"> * Unless required by applicable law or agreed to in writing, software</div><div class="line"> * distributed under the License is distributed on an "AS IS" BASIS,</div><div class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</div><div class="line"> * See the License for the specific language governing permissions and</div><div class="line"> * limitations under the License.</div><div class="line"> */</div><div class="line"><span class="keyword">package</span> com.alibaba.druid.support.http;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.util.IPAddress;</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.util.IPRange;</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.support.logging.Log;</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.support.logging.LogFactory;</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.util.StringUtils;</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.util.Utils;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.ServletException;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Log   LOG                 = LogFactory.getLog(ResourceServlet.class);</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SESSION_USER_KEY    = <span class="string">"druid-user"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAM_NAME_USERNAME = <span class="string">"loginUsername"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAM_NAME_PASSWORD = <span class="string">"loginPassword"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAM_NAME_ALLOW    = <span class="string">"allow"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAM_NAME_DENY     = <span class="string">"deny"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAM_REMOTE_ADDR   = <span class="string">"remoteAddress"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> String           username            = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">protected</span> String           password            = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> List&lt;IPRange&gt;    allowList           = <span class="keyword">new</span> ArrayList&lt;IPRange&gt;();</div><div class="line">    <span class="keyword">protected</span> List&lt;IPRange&gt;    denyList            = <span class="keyword">new</span> ArrayList&lt;IPRange&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String     resourcePath;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> String           remoteAddressHeader = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResourceServlet</span><span class="params">(String resourcePath)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.resourcePath = resourcePath;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">        initAuthEnv();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initAuthEnv</span><span class="params">()</span> </span>&#123;</div><div class="line">        String paramUserName = getInitParameter(PARAM_NAME_USERNAME);</div><div class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(paramUserName)) &#123;</div><div class="line">            <span class="keyword">this</span>.username = paramUserName;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String paramPassword = getInitParameter(PARAM_NAME_PASSWORD);</div><div class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(paramPassword)) &#123;</div><div class="line">            <span class="keyword">this</span>.password = paramPassword;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String paramRemoteAddressHeader = getInitParameter(PARAM_REMOTE_ADDR);</div><div class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(paramRemoteAddressHeader)) &#123;</div><div class="line">            <span class="keyword">this</span>.remoteAddressHeader = paramRemoteAddressHeader;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            String param = getInitParameter(PARAM_NAME_ALLOW);</div><div class="line">            <span class="keyword">if</span> (param != <span class="keyword">null</span> &amp;&amp; param.trim().length() != <span class="number">0</span>) &#123;</div><div class="line">                param = param.trim();</div><div class="line">                String[] items = param.split(<span class="string">","</span>);</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (String item : items) &#123;</div><div class="line">                    <span class="keyword">if</span> (item == <span class="keyword">null</span> || item.length() == <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    IPRange ipRange = <span class="keyword">new</span> IPRange(item);</div><div class="line">                    allowList.add(ipRange);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            String msg = <span class="string">"initParameter config error, allow : "</span> + getInitParameter(PARAM_NAME_ALLOW);</div><div class="line">            LOG.error(msg, e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            String param = getInitParameter(PARAM_NAME_DENY);</div><div class="line">            <span class="keyword">if</span> (param != <span class="keyword">null</span> &amp;&amp; param.trim().length() != <span class="number">0</span>) &#123;</div><div class="line">                param = param.trim();</div><div class="line">                String[] items = param.split(<span class="string">","</span>);</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (String item : items) &#123;</div><div class="line">                    <span class="keyword">if</span> (item == <span class="keyword">null</span> || item.length() == <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    IPRange ipRange = <span class="keyword">new</span> IPRange(item);</div><div class="line">                    denyList.add(ipRange);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            String msg = <span class="string">"initParameter config error, deny : "</span> + getInitParameter(PARAM_NAME_DENY);</div><div class="line">            LOG.error(msg, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPermittedRequest</span><span class="params">(String remoteAddress)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> ipV6 = remoteAddress != <span class="keyword">null</span> &amp;&amp; remoteAddress.indexOf(<span class="string">':'</span>) != -<span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (ipV6) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"0:0:0:0:0:0:0:1"</span>.equals(remoteAddress) || (denyList.size() == <span class="number">0</span> &amp;&amp; allowList.size() == <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        IPAddress ipAddress = <span class="keyword">new</span> IPAddress(remoteAddress);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (IPRange range : denyList) &#123;</div><div class="line">            <span class="keyword">if</span> (range.isIPAddressInRange(ipAddress)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (allowList.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (IPRange range : allowList) &#123;</div><div class="line">                <span class="keyword">if</span> (range.isIPAddressInRange(ipAddress)) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getFilePath</span><span class="params">(String fileName)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> resourcePath + fileName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">returnResourceFile</span><span class="params">(String fileName, String uri, HttpServletResponse response)</span></span></div><div class="line">                                                                                                <span class="keyword">throws</span> ServletException,</div><div class="line">                                                                                                IOException &#123;</div><div class="line"></div><div class="line">        String filePath = getFilePath(fileName);</div><div class="line">        <span class="keyword">if</span> (fileName.endsWith(<span class="string">".jpg"</span>)) &#123;</div><div class="line">            <span class="keyword">byte</span>[] bytes = Utils.readByteArrayFromResource(filePath);</div><div class="line">            <span class="keyword">if</span> (bytes != <span class="keyword">null</span>) &#123;</div><div class="line">                response.getOutputStream().write(bytes);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String text = Utils.readFromResource(filePath);</div><div class="line">        <span class="keyword">if</span> (text == <span class="keyword">null</span>) &#123;</div><div class="line">            response.sendRedirect(uri + <span class="string">"/index.html"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (fileName.endsWith(<span class="string">".css"</span>)) &#123;</div><div class="line">            response.setContentType(<span class="string">"text/css;charset=utf-8"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fileName.endsWith(<span class="string">".js"</span>)) &#123;</div><div class="line">            response.setContentType(<span class="string">"text/javascript;charset=utf-8"</span>);</div><div class="line">        &#125;</div><div class="line">        response.getWriter().write(text);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line">        String contextPath = request.getContextPath();</div><div class="line">        String servletPath = request.getServletPath();</div><div class="line">        String requestURI = request.getRequestURI();</div><div class="line"></div><div class="line">        response.setCharacterEncoding(<span class="string">"utf-8"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (contextPath == <span class="keyword">null</span>) &#123; <span class="comment">// root context</span></div><div class="line">            contextPath = <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        String uri = contextPath + servletPath;</div><div class="line">        String path = requestURI.substring(contextPath.length() + servletPath.length());</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!isPermittedRequest(request)) &#123;</div><div class="line">            path = <span class="string">"/nopermit.html"</span>;</div><div class="line">            returnResourceFile(path, uri, response);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="string">"/submitLogin"</span>.equals(path)) &#123;</div><div class="line">            String usernameParam = request.getParameter(PARAM_NAME_USERNAME);</div><div class="line">            String passwordParam = request.getParameter(PARAM_NAME_PASSWORD);</div><div class="line">            <span class="keyword">if</span> (username.equals(usernameParam) &amp;&amp; password.equals(passwordParam)) &#123;</div><div class="line">                request.getSession().setAttribute(SESSION_USER_KEY, username);</div><div class="line">                response.getWriter().print(<span class="string">"success"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                response.getWriter().print(<span class="string">"error"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (isRequireAuth() <span class="comment">//</span></div><div class="line">            &amp;&amp; !ContainsUser(request)<span class="comment">//</span></div><div class="line">            &amp;&amp; !(<span class="string">"/login.html"</span>.equals(path) <span class="comment">//</span></div><div class="line">                 || path.startsWith(<span class="string">"/css"</span>)<span class="comment">//</span></div><div class="line">                 || path.startsWith(<span class="string">"/js"</span>) <span class="comment">//</span></div><div class="line">            || path.startsWith(<span class="string">"/img"</span>))) &#123;</div><div class="line">            <span class="keyword">if</span> (contextPath.equals(<span class="string">""</span>) || contextPath.equals(<span class="string">"/"</span>)) &#123;</div><div class="line">                response.sendRedirect(<span class="string">"/druid/login.html"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="string">""</span>.equals(path)) &#123;</div><div class="line">                    response.sendRedirect(<span class="string">"druid/login.html"</span>);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    response.sendRedirect(<span class="string">"login.html"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="string">""</span>.equals(path)) &#123;</div><div class="line">            <span class="keyword">if</span> (contextPath.equals(<span class="string">""</span>) || contextPath.equals(<span class="string">"/"</span>)) &#123;</div><div class="line">                response.sendRedirect(<span class="string">"/druid/index.html"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                response.sendRedirect(<span class="string">"druid/index.html"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="string">"/"</span>.equals(path)) &#123;</div><div class="line">            response.sendRedirect(<span class="string">"index.html"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (path.contains(<span class="string">".json"</span>)) &#123;</div><div class="line">            String fullUrl = path;</div><div class="line">            <span class="keyword">if</span> (request.getQueryString() != <span class="keyword">null</span> &amp;&amp; request.getQueryString().length() &gt; <span class="number">0</span>) &#123;</div><div class="line">                fullUrl += <span class="string">"?"</span> + request.getQueryString();</div><div class="line">            &#125;</div><div class="line">            response.getWriter().print(process(fullUrl));</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// find file in resources path</span></div><div class="line">        returnResourceFile(path, uri, response);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ContainsUser</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line">        HttpSession session = request.getSession(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">return</span> session != <span class="keyword">null</span> &amp;&amp; session.getAttribute(SESSION_USER_KEY) != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRequireAuth</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.username != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPermittedRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line">        String remoteAddress = getRemoteAddress(request);</div><div class="line">        <span class="keyword">return</span> isPermittedRequest(remoteAddress);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getRemoteAddress</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line">        String remoteAddress = <span class="keyword">null</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (remoteAddressHeader != <span class="keyword">null</span>) &#123;</div><div class="line">            remoteAddress = request.getHeader(remoteAddressHeader);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (remoteAddress == <span class="keyword">null</span>) &#123;</div><div class="line">            remoteAddress = request.getRemoteAddr();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> remoteAddress;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">process</span><span class="params">(String url)</span></span>;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>其中，<code>service</code>方法里有URL的判断，方法里有request和response，看上去就是流程的起点，但是一般我们写servlet都是从<code>doGet</code>和<code>doPost</code>入手的，这里面不知道做了什么封装，于是继续往父类去看，然后发现其父类是<code>javax.servlet.http.HttpServlet</code>，已经是J2EE定义的类了，我用的是tomcat容器，所以这个类由tomcat提供。里面有常见的<code>doPost</code>和<code>doGet</code>方法</p>
<p>可以看到，<code>doGet</code>和<code>doPost</code>方法默认都是不通的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">        <span class="keyword">throws</span> ServletException, IOException</div><div class="line">&#123;</div><div class="line">    String protocol = req.getProtocol();</div><div class="line">    String msg = lStrings.getString(<span class="string">"http.method_get_not_supported"</span>);</div><div class="line">    <span class="keyword">if</span> (protocol.endsWith(<span class="string">"1.1"</span>)) &#123;</div><div class="line">        resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line"></div><div class="line">    String protocol = req.getProtocol();</div><div class="line">    String msg = lStrings.getString(<span class="string">"http.method_post_not_supported"</span>);</div><div class="line">    <span class="keyword">if</span> (protocol.endsWith(<span class="string">"1.1"</span>)) &#123;</div><div class="line">        resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>赶紧去看注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Called by the server (via the &lt;code&gt;service&lt;/code&gt; method) to</div><div class="line"> * allow a servlet to handle a GET request.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;Overriding this method to support a GET request also</div><div class="line"> * automatically supports an HTTP HEAD request. A HEAD</div><div class="line"> * request is a GET request that returns no body in the</div><div class="line"> * response, only the request header fields.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;When overriding this method, read the request data,</div><div class="line"> * write the response headers, get the response's writer or...</div><div class="line"> * /</div><div class="line">protected void doGet(HttpServletRequest req, HttpServletResponse resp)</div><div class="line">        throws ServletException, IOException</div><div class="line">&#123;</div><div class="line">    //...</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * Called by the server (via the &lt;code&gt;service&lt;/code&gt; method)</div><div class="line"> * to allow a servlet to handle a POST request.</div><div class="line"> * </div><div class="line"> * ...</div><div class="line"> * </div><div class="line"> * &lt;p&gt;When overriding this method, read the request data,</div><div class="line"> * write the response headers...</div><div class="line"> * </div><div class="line"> */</div><div class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">	<span class="comment">//...</span></div><div class="line">&#125;</div><div class="line">     </div></pre></td></tr></table></figure>     
<p>原来是需要自己覆盖的，很符合我们一贯的经验。再看看<code>service</code>方法是怎么回事：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Receives standard HTTP requests from the public</div><div class="line"> * &lt;code&gt;service&lt;/code&gt; method and dispatches</div><div class="line"> * them to the &lt;code&gt;do&lt;/code&gt;&lt;i&gt;Method&lt;/i&gt; methods defined in</div><div class="line"> * this class. This method is an HTTP-specific version of the</div><div class="line"> * &#123;<span class="doctag">@link</span> javax.servlet.Servlet#service&#125; method. There's no</div><div class="line"> * need to override this method.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> req   the &#123;<span class="doctag">@link</span> HttpServletRequest&#125; object that</div><div class="line"> *                  contains the request the client made of</div><div class="line"> *                  the servlet</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> resp  the &#123;<span class="doctag">@link</span> HttpServletResponse&#125; object that</div><div class="line"> *                  contains the response the servlet returns</div><div class="line"> *                  to the client</div><div class="line"> *</div><div class="line"> * <span class="doctag">@exception</span> IOException   if an input or output error occurs</div><div class="line"> *                              while the servlet is handling the</div><div class="line"> *                              HTTP request</div><div class="line"> *</div><div class="line"> * <span class="doctag">@exception</span> ServletException  if the HTTP request</div><div class="line"> *                                  cannot be handled</div><div class="line"> *</div><div class="line"> * <span class="doctag">@see</span> javax.servlet.Servlet#service</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">	<span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>这个方法是请求的统一接收入口，然后将请求分发到<code>doGet</code>、<code>doPost</code>、<code>doHead</code>等对应标准HTTP请求方法的方法去。注释里特地说明了没有必要覆盖这个方法，druid的开发者可能是图方便就将它覆盖了。总之，现在我们知道了，<code>service</code>方法就是请求的入口，这样我们再回去看看<code>com.alibaba.druid.support.http.ResourceServlet</code>的<code>service</code>方法，通过这个方法应该就能理顺整个流程。</p>
<p>将其方法代码加上我自己的注释贴出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 整个方法其实做的还是路由分发的工作，根据请求的地址，分别返回不同的资源，并且进行访问控制。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line">    String contextPath = request.getContextPath();</div><div class="line">    String servletPath = request.getServletPath();</div><div class="line">    String requestURI = request.getRequestURI();</div><div class="line"></div><div class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (contextPath == <span class="keyword">null</span>) &#123; <span class="comment">// root context</span></div><div class="line">        contextPath = <span class="string">""</span>;</div><div class="line">    &#125;</div><div class="line">    String uri = contextPath + servletPath;</div><div class="line">    String path = requestURI.substring(contextPath.length() + servletPath.length());</div><div class="line"></div><div class="line">	<span class="comment">// 禁止访问的时候返回nopermit.html，returnResourceFile这个方法很关键，下文说说</span></div><div class="line">    <span class="keyword">if</span> (!isPermittedRequest(request)) &#123;</div><div class="line">        path = <span class="string">"/nopermit.html"</span>;</div><div class="line">        returnResourceFile(path, uri, response);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	 <span class="comment">/* 从名字看来，这是接收登录请求的</span></div><div class="line">	  * 很明显，校验就是匹配username和password是否都与配置的匹配，如果匹配就在session里塞点标识</div><div class="line">	  * 很原始的做法，但是对于一个内部使用的线程池监控来说也不用做得太复杂</div><div class="line">	  */</div><div class="line">    <span class="keyword">if</span> (<span class="string">"/submitLogin"</span>.equals(path)) &#123;</div><div class="line">        String usernameParam = request.getParameter(PARAM_NAME_USERNAME);</div><div class="line">        String passwordParam = request.getParameter(PARAM_NAME_PASSWORD);</div><div class="line">        <span class="keyword">if</span> (username.equals(usernameParam) &amp;&amp; password.equals(passwordParam)) &#123;</div><div class="line">            request.getSession().setAttribute(SESSION_USER_KEY, username);</div><div class="line">            response.getWriter().print(<span class="string">"success"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            response.getWriter().print(<span class="string">"error"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	 <span class="comment">/* 拦截登录 */</span></div><div class="line">    <span class="keyword">if</span> (isRequireAuth() <span class="comment">//</span></div><div class="line">        &amp;&amp; !ContainsUser(request)<span class="comment">//</span></div><div class="line">        &amp;&amp; !(<span class="string">"/login.html"</span>.equals(path) <span class="comment">//</span></div><div class="line">             || path.startsWith(<span class="string">"/css"</span>)<span class="comment">//</span></div><div class="line">             || path.startsWith(<span class="string">"/js"</span>) <span class="comment">//</span></div><div class="line">        || path.startsWith(<span class="string">"/img"</span>))) &#123;</div><div class="line">        <span class="keyword">if</span> (contextPath.equals(<span class="string">""</span>) || contextPath.equals(<span class="string">"/"</span>)) &#123;</div><div class="line">            response.sendRedirect(<span class="string">"/druid/login.html"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="string">""</span>.equals(path)) &#123;</div><div class="line">                response.sendRedirect(<span class="string">"druid/login.html"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                response.sendRedirect(<span class="string">"login.html"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	 <span class="comment">// 缺省首页的跳转</span></div><div class="line">    <span class="keyword">if</span> (<span class="string">""</span>.equals(path)) &#123;</div><div class="line">        <span class="keyword">if</span> (contextPath.equals(<span class="string">""</span>) || contextPath.equals(<span class="string">"/"</span>)) &#123;</div><div class="line">            response.sendRedirect(<span class="string">"/druid/index.html"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            response.sendRedirect(<span class="string">"druid/index.html"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="string">"/"</span>.equals(path)) &#123;</div><div class="line">        response.sendRedirect(<span class="string">"index.html"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">	 <span class="comment">/* </span></div><div class="line">	  * 在不改造的时候，正常监控一个druid实例，会发现页面的数据都是异步刷新的，</div><div class="line">	  * 通过浏览器的开发者工具能发现取数据的请求都是json后缀的，所以这里就是监控数据流动的节点</div><div class="line">	  * process方法是关键，而这个方法是一个抽象方法，由具体的实现类来实现，下文将回到&#123;@link com.alibaba.druid.support.http.StatViewServlet#process(String)&#125;方法里看</div><div class="line">	  * /</div><div class="line">    if (path.contains(".json")) &#123;</div><div class="line">        String fullUrl = path;</div><div class="line">        if (request.getQueryString() != null &amp;&amp; request.getQueryString().length() &gt; 0) &#123;</div><div class="line">            fullUrl += "?" + request.getQueryString();</div><div class="line">        &#125;</div><div class="line">        response.getWriter().print(process(fullUrl));</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	 // 在以上情况都不匹配的时候，返回资源文件</div><div class="line">    // find file in resources path</div><div class="line">    returnResourceFile(path, uri, response);</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>有两个方法需要看：</p>
<ol>
<li>returnResourceFile</li>
<li>process</li>
</ol>
<p><code>returnResourceFile</code>方法在<code>ResourceServlet</code>里面实现了（注释是我加的）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">returnResourceFile</span><span class="params">(String fileName, String uri, HttpServletResponse response)</span></span></div><div class="line">                                                                                                <span class="keyword">throws</span> ServletException,</div><div class="line">                                                                                                IOException &#123;</div><div class="line"></div><div class="line">    String filePath = getFilePath(fileName);</div><div class="line">    <span class="comment">// 如果是jpg，则返回流</span></div><div class="line">    <span class="keyword">if</span> (fileName.endsWith(<span class="string">".jpg"</span>)) &#123;</div><div class="line">        <span class="keyword">byte</span>[] bytes = Utils.readByteArrayFromResource(filePath);</div><div class="line">        <span class="keyword">if</span> (bytes != <span class="keyword">null</span>) &#123;</div><div class="line">            response.getOutputStream().write(bytes);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	 <span class="comment">/* </span></div><div class="line">	  * 否则读取文件，返回文件内的文本</div><div class="line">	  * 其中，Utils.readFromResource有这么关键的一行</div><div class="line">	  * Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);</div><div class="line">	  * 这和servlet初始化的时候是有关的</div><div class="line">	  * ResourceServlet本身也是一个抽象类，其子类StatViewServlet初始化的时候指定了资源目录的路径：</div><div class="line">	  * public StatViewServlet()&#123;</div><div class="line">     *     super("support/http/resources");</div><div class="line">     * &#125;</div><div class="line">     * /</div><div class="line">    String text = Utils.readFromResource(filePath);</div><div class="line">    if (text == null) &#123;</div><div class="line">        // 如果请求的路径映射不到资源文件，则调到默认首页（其实就是将404指向了index.html）</div><div class="line">        response.sendRedirect(uri + "/index.html");</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    // 如果是css或者是js文件，则还需要设置相应的响应头部</div><div class="line">    if (fileName.endsWith(".css")) &#123;</div><div class="line">        response.setContentType("text/css;charset=utf-8");</div><div class="line">    &#125; else if (fileName.endsWith(".js")) &#123;</div><div class="line">        response.setContentType("text/javascript;charset=utf-8");</div><div class="line">    &#125;</div><div class="line">    response.getWriter().write(text);</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>接着看process方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 程序首先判断是否存在jmx连接地址，如果不存在，则直接调用本地的duird服务； 如果存在，则调用远程jmx服务。在进行jmx通信，首先判断一下jmx连接是否已经建立成功，如果已经</div><div class="line"> * 建立成功，则直接进行通信，如果之前没有成功建立，则会尝试重新建立一遍。.</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> url 要连接的服务地址</div><div class="line"> * <span class="doctag">@return</span> 调用服务后返回的json字符串</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">process</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">    String resp = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (jmxUrl == <span class="keyword">null</span>) &#123;</div><div class="line">        resp = statService.service(url);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;<span class="comment">// 连接在初始化时创建失败</span></div><div class="line">            <span class="keyword">try</span> &#123;<span class="comment">// 尝试重新连接</span></div><div class="line">                initJmxConn();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                LOG.error(<span class="string">"init jmx connection error"</span>, e);</div><div class="line">                resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR,</div><div class="line">                                                         <span class="string">"init jmx connection error"</span> + e.getMessage());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;<span class="comment">// 连接成功</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    resp = getJmxResult(conn, url);</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    LOG.error(<span class="string">"get jmx data error"</span>, e);</div><div class="line">                    resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR, <span class="string">"get data error:"</span></div><div class="line">                                                                                                 + e.getMessage());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 连接成功</span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                resp = getJmxResult(conn, url);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                LOG.error(<span class="string">"get jmx data error"</span>, e);</div><div class="line">                resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR,</div><div class="line">                                                         <span class="string">"get data error"</span> + e.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> resp;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>可见它是有重连的，而保证了连接成功之后，获取数据的方法是<code>getJmxResult</code>，这个是在<code>StatViewServlet</code>里面实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getJmxResult</span><span class="params">(MBeanServerConnection connetion, String url)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    ObjectName name = <span class="keyword">new</span> ObjectName(DruidStatService.MBEAN_NAME);</div><div class="line"></div><div class="line">    String result = (String) conn.invoke(name, <span class="string">"service"</span>, <span class="keyword">new</span> String[] &#123; url &#125;,</div><div class="line">                                         <span class="keyword">new</span> String[] &#123; String.class.getName() &#125;);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>所以实际上就是用MBeanServer的连接去直接取数据然后原样返回，所有的监控数据其实是缓存在被监控的目标处的，web的监控只是一个请求转发与展示的作用。</p>
<p>所以现在总结StatViewServlet整个工作过程：</p>
<ol>
<li>记录用户名和密码</li>
<li>根据配置的jmxUrl初始化jmx连接</li>
<li>接收请求，分发请求</li>
<li>如果请求是json数据请求，则通过jmx连接到被监控对象处取数据，然后返回</li>
</ol>
<h1 id="3-改进思路"><a href="#3-改进思路" class="headerlink" title="3. 改进思路"></a>3. 改进思路</h1><h2 id="3-1-思路一：动态创建并注册StatViewServlet"><a href="#3-1-思路一：动态创建并注册StatViewServlet" class="headerlink" title="3.1 思路一：动态创建并注册StatViewServlet"></a>3.1 思路一：动态创建并注册StatViewServlet</h2><p>这是首先想到的思路，因为使用这种办法不需要对druid的web监控细节了解多少。要实现这个目标，需要做到以下两点之一：</p>
<ol>
<li>对于Java Web容器的启动过程很了解，并且深入细节</li>
<li>Google能找到相似的例子</li>
</ol>
<p>第一点我还做不到，短时间内也做不到，所以只能往第二点去努力。找到了一个最贴切的办法是：<br><a href="http://javaevangelist.blogspot.co.id/2012/11/dynamic-servlet-registration-example.html" target="_blank" rel="external">Dynamic Servlet Registration Example</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletRegistration;</div><div class="line"><span class="keyword">import</span> javax.servlet.annotation.WebListener;</div><div class="line"></div><div class="line"><span class="meta">@WebListener</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletContextListenerImpl</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(<span class="keyword">final</span> ServletContextEvent sce)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> ServletContext servletContext = sce.getServletContext();</div><div class="line">        <span class="keyword">final</span> ServletRegistration.Dynamic dynamic = servletContext.addServlet(<span class="string">"Example Servlet"</span>, ExampleServlet.class);</div><div class="line">        dynamic.addMapping(<span class="string">"/"</span>);</div><div class="line"> </div><div class="line">        <span class="keyword">final</span> Map&lt;String, ? extends ServletRegistration&gt; map = servletContext.getServletRegistrations();</div><div class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</div><div class="line">            servletContext.log(<span class="string">"Registered Servlet: "</span> + map.get(key).getName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(<span class="keyword">final</span> ServletContextEvent sce)</span> </span>&#123;</div><div class="line">        <span class="comment">//NO-OP</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>主要就是实现<code>javax.servlet.ServletContextListener</code>，通过<code>javax.servlet.ServletContextEvent</code>实例获取<code>javax.servlet.ServletContext</code>实例，然后调用它的方法去注册新的servlet。</p>
<p>看上去好像可行的样子，但是在实际运行起来之后，在这一行报错了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> ServletRegistration.Dynamic dynamic = servletContext.addServlet(<span class="string">"Example Servlet"</span>, ExampleServlet.class);</div></pre></td></tr></table></figure>
<p>错误信息没有记录下来，但是意思就是说这个操作是不支持的，反正就是没戏。具体为什么，还需要进一步了解。</p>
<h2 id="3-2-思路二：修改StatViewServlet的机制"><a href="#3-2-思路二：修改StatViewServlet的机制" class="headerlink" title="3.2 思路二：修改StatViewServlet的机制"></a>3.2 思路二：修改StatViewServlet的机制</h2><p>在第一个思路走不通之后，只能从其工作机制上入手。其原理分析已经在上文给出。</p>
<p>因为只要有JMX的连接就可以获取数据了，所以关键在于以下几点：</p>
<ol>
<li>持有多个jmx连接并且与不同的请求关联起来</li>
<li>根据配置去动态创建连接</li>
<li>将原本固定的几个页面与配置的多个监控对象动态地对应起来</li>
<li>配置能根据部署环境的不同而改变，并且发生变更的时候能轻易修改</li>
<li>列出所有被监控对象</li>
</ol>
<p>对于第一点，创建jmx连接只要有jmxUrl就够了，所以很容易做到，至于与请求关联起来，其实就是从请求的url里提取特征，用于表示不同的监控对象，然后将此特征映射到对应的jmx连接即可。</p>
<p>对于第二点，这其实就是普通的读取、解析配置，然后用配置信息去初始化jmx连接（当然还有登录名、密码和黑白名单等）。</p>
<p>第三点，转下弯，原有的逻辑是将url直接映射为资源文件，只要在这中间加一层解析即可。</p>
<p>第四点，简单的方案是配置多个配置文件，根据不同的环境打不同的包。但是这种做法不灵活，最好还是做成注册中心的形式，被监控对象启动的时候网注册中心写入信息，这边从注册中心读，还有下线机制。但是这种做法工作量大，而且要改被监控的一方，容易引入bug。要不就与配置中心集成，这样就只需改动web监控一端即可。这里的配置方案有多重，很适合采用SPI。</p>
<p>第五点，根据配置信息做个汇总，然后给个页面列出来就可以。</p>
<h1 id="4-实现"><a href="#4-实现" class="headerlink" title="4 实现"></a>4 实现</h1><p>请移步我github的仓库：<a href="https://github.com/bungder/druid-aggregated-monitor" target="_blank" rel="external">https://github.com/bungder/druid-aggregated-monitor</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h1&gt;&lt;p&gt;druid本身提供了监控功能，具体在我另一篇博文《&lt;a href=&quot;/2017/08/27/druid-monitor/&quot;&gt;Druid连接池监控&lt;/a&gt;》里有介绍。当时提到有以下缺陷：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无法灵活监控多个目标&lt;/li&gt;
&lt;li&gt;切换环境不方便&lt;/li&gt;
&lt;li&gt;JMX重连不会成功&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此针对这些问题，对其进行改造。改造后的源码已经放在个人的github上：&lt;br&gt;&lt;a href=&quot;https://github.com/bungder/druid-aggregated-monitor&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/bungder/druid-aggregated-monitor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应本文的版本，已经打了tag：&lt;br&gt;&lt;a href=&quot;https://github.com/bungder/druid-aggregated-monitor/releases/tag/0.0.1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/bungder/druid-aggregated-monitor/releases/tag/0.0.1&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="druid" scheme="http://bungder.github.io/tags/druid/"/>
    
      <category term="连接池" scheme="http://bungder.github.io/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
      <category term="监控" scheme="http://bungder.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Druid连接池监控</title>
    <link href="http://bungder.github.io/2017/08/27/druid-monitor/"/>
    <id>http://bungder.github.io/2017/08/27/druid-monitor/</id>
    <published>2017-08-27T09:43:32.000Z</published>
    <updated>2017-08-31T02:39:50.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-普通的web监控"><a href="#1-普通的web监控" class="headerlink" title="1. 普通的web监控"></a>1. 普通的web监控</h1><p>阿里开源的连接池Druid自带了web监控的功能，具体的操作在其github的wiki上可以找到：<a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatViewServlet%E9%85%8D%E7%BD%AE" target="_blank" rel="external">配置_StatViewServlet配置 · alibaba/driud wiki</a></p>
<p>其实主要就是配置一个Servlet，但是github wiki上的做法只能在druid所在的项目中启用web服务的做法，在如今盛行的微服务架构中，很多时候druid所在的服务里并不提供web服务，这就需要额外的配置。其实druid本身也提供了这种功能，只是wiki里没有说。</p>
<p>druid本身可以通过启用JMX端口来将监控数据传输到远端进行处理，具体做法是：</p>
<ol>
<li>在启动服务的时候加上JVM启动参数（下文说）</li>
<li>在远端启用web服务，配置StatViewServlet，在initParam中指定JMX地址</li>
</ol>
<a id="more"></a>
<h2 id="1-1-JVM启动参数："><a href="#1-1-JVM启动参数：" class="headerlink" title="1.1 JVM启动参数："></a>1.1 JVM启动参数：</h2><blockquote>
<p>-Djava.net.preferIPv4Stack=true<br>-Dcom.sun.management.jmxremote<br>-Djava.rmi.server.hostname=192.168.199.123<br>-Dcom.sun.management.jmxremote.port=9876<br>-Dcom.sun.management.jmxremote.authenticate=false<br>-Dcom.sun.management.jmxremote.ssl=false</p>
</blockquote>
<p>其中，<code>-Djava.rmi.server.hostname</code>一项指定了服务所在的IP地址，<code>-Dcom.sun.management.jmxremote.port</code>一项指定了JMX端口。</p>
<h2 id="1-2-远程web工程Servlet配置"><a href="#1-2-远程web工程Servlet配置" class="headerlink" title="1.2 远程web工程Servlet配置"></a>1.2 远程web工程Servlet配置</h2><p>在web.xml里添加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DruidStatView<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.alibaba.druid.support.http.StatViewServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 远程访问JavaSE项目使用jmx连接 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>jmxUrl<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>service:jmx:rmi:///jndi/rmi://192.168.199.123:9876/jmxrmi<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>loginUsername<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>loginPassword<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DruidStatView<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/druid/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果想快速打包启动，不依赖外部web容器，可以采用SpringBoot，用嵌入式的web容器启动，原理也是一样。具体做法是：</p>
<ol>
<li>创建Servlet：</li>
</ol>
<figure class="highlight java"><figcaption><span>DruidStatViewServlet.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.tansc.test.springboot.config.druid;</div><div class="line">	</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.StatViewServlet;</div><div class="line">	</div><div class="line"><span class="keyword">import</span> javax.servlet.annotation.WebInitParam;</div><div class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</div><div class="line">	</div><div class="line"><span class="comment">/**</span></div><div class="line"> * StatViewServlet</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</div><div class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/druid/*"</span>,</div><div class="line">    initParams=&#123;</div><div class="line">            <span class="meta">@WebInitParam</span>(name=<span class="string">"loginUsername"</span>,value=<span class="string">"admin"</span>),<span class="comment">// 用户名</span></div><div class="line">            <span class="meta">@WebInitParam</span>(name=<span class="string">"loginPassword"</span>,value=<span class="string">"admin"</span>),<span class="comment">// 密码</span></div><div class="line">            <span class="meta">@WebInitParam</span>(name=<span class="string">"jmxUrl"</span>,value=<span class="string">"service:jmx:rmi:///jndi/rmi://192.168.199.123:9876/jmxrmi"</span>),</div><div class="line">            <span class="meta">@WebInitParam</span>(name=<span class="string">"resetEnable"</span>,value=<span class="string">"false"</span>)<span class="comment">// 禁用HTML页面上的“Reset All”功能</span></div><div class="line">    &#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidStatViewServlet</span> <span class="keyword">extends</span> <span class="title">StatViewServlet</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>在启动类上加上注解<code>@ServletComponentScan(&quot;com.tansc.test.springboot&quot;)</code>以扫描Servlet。</li>
</ol>
<h2 id="1-3-查看监控数据"><a href="#1-3-查看监控数据" class="headerlink" title="1.3 查看监控数据"></a>1.3 查看监控数据</h2><p>上面的都配置好之后，启动服务，等服务启动成功之后，启动远端的web服务，然后访问web服务的<code>/druid</code>目录（与上面配置的匹配即可），例如在我本地起的：<code>http://127.0.0.1:8080/druid</code></p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/druid-monitor.png" alt=""></p>
<h2 id="1-4-缺陷"><a href="#1-4-缺陷" class="headerlink" title="1.4 缺陷"></a>1.4 缺陷</h2><ol>
<li>这种做法是一对一的，也就是一个druid连接池实例必须对应一个StatViewServlet，一个StatViewServlet也只能队一行一个druid实例。</li>
<li>切换环境不方便</li>
<li>JMX重连不会成功<ul>
<li>虽然远端会有重连机制，但是在服务重启之后，重连总是报Connection refused，只能将远端的web服务重启才能成功连上</li>
</ul>
</li>
</ol>
<h2 id="1-5-改进"><a href="#1-5-改进" class="headerlink" title="1.5 改进"></a>1.5 改进</h2><p>对于上面提到的两点缺陷，可以用以下两个思路去改进：</p>
<ol>
<li>动态创建servlet，模仿分布式服务的注册中心的形式来改造<ul>
<li>Servlet本身不提供这样的API，但是应该是可以做到的，具体要继续探索。</li>
</ul>
</li>
<li>使用配置文件<ul>
<li>web.xml里面本身不能读取配置文件的值，但是可以通过继承StatViewServlet来实现。</li>
</ul>
</li>
<li>需要分析源码</li>
</ol>
<p>（2017-08-31 目前已经改造了，见我下一篇博文：<a href="/2017/08/31/druid-monitor-remould/">Druid连接池监控的一次改造</a>）</p>
<h2 id="1-6-性能损耗"><a href="#1-6-性能损耗" class="headerlink" title="1.6 性能损耗"></a>1.6 性能损耗</h2><p>当远程的web服务启动并且在浏览器里访问统计页面之后，该服务的内存变化如下：<br><img src="http://otlnkjq1m.bkt.clouddn.com/JProfiler8-RecordedObjects.jpg" alt=""></p>
<h1 id="2-持久化-自定义传输监控记录"><a href="#2-持久化-自定义传输监控记录" class="headerlink" title="2. 持久化/自定义传输监控记录"></a>2. 持久化/自定义传输监控记录</h1><p>可以通过定制StatLogger实现，具体见其github的wiki：<br><a href="https://github.com/alibaba/druid/wiki/%E6%80%8E%E4%B9%88%E4%BF%9D%E5%AD%98Druid%E7%9A%84%E7%9B%91%E6%8E%A7%E8%AE%B0%E5%BD%95" target="_blank" rel="external">怎么保存Druid的监控记录 · alibaba/driud wiki</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>配置StatFilter · alibaba/driud wiki<br><a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatFilter" target="_blank" rel="external">https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatFilter</a></li>
<li>非web项目如何配置Druid监控 - 若鱼的专栏 - CSDN博客<br><a href="http://blog.csdn.net/goldenfish1919/article/details/68941237" target="_blank" rel="external">http://blog.csdn.net/goldenfish1919/article/details/68941237</a></li>
<li>Spring Boot 使用 Druid 和监控配置 - 小单的博客专栏 - CSDN博客<br><a href="http://blog.csdn.net/catoop/article/details/50925337" target="_blank" rel="external">http://blog.csdn.net/catoop/article/details/50925337</a></li>
<li>怎么保存Druid的监控记录 · alibaba/driud wiki<br><a href="https://github.com/alibaba/druid/wiki/%E6%80%8E%E4%B9%88%E4%BF%9D%E5%AD%98Druid%E7%9A%84%E7%9B%91%E6%8E%A7%E8%AE%B0%E5%BD%95" target="_blank" rel="external">https://github.com/alibaba/druid/wiki/%E6%80%8E%E4%B9%88%E4%BF%9D%E5%AD%98Druid%E7%9A%84%E7%9B%91%E6%8E%A7%E8%AE%B0%E5%BD%95</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-普通的web监控&quot;&gt;&lt;a href=&quot;#1-普通的web监控&quot; class=&quot;headerlink&quot; title=&quot;1. 普通的web监控&quot;&gt;&lt;/a&gt;1. 普通的web监控&lt;/h1&gt;&lt;p&gt;阿里开源的连接池Druid自带了web监控的功能，具体的操作在其github的wiki上可以找到：&lt;a href=&quot;https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatViewServlet%E9%85%8D%E7%BD%AE&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;配置_StatViewServlet配置 · alibaba/driud wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实主要就是配置一个Servlet，但是github wiki上的做法只能在druid所在的项目中启用web服务的做法，在如今盛行的微服务架构中，很多时候druid所在的服务里并不提供web服务，这就需要额外的配置。其实druid本身也提供了这种功能，只是wiki里没有说。&lt;/p&gt;
&lt;p&gt;druid本身可以通过启用JMX端口来将监控数据传输到远端进行处理，具体做法是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在启动服务的时候加上JVM启动参数（下文说）&lt;/li&gt;
&lt;li&gt;在远端启用web服务，配置StatViewServlet，在initParam中指定JMX地址&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="druid" scheme="http://bungder.github.io/tags/druid/"/>
    
      <category term="连接池" scheme="http://bungder.github.io/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
      <category term="监控" scheme="http://bungder.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>持续集成简述</title>
    <link href="http://bungder.github.io/2017/07/24/CI/"/>
    <id>http://bungder.github.io/2017/07/24/CI/</id>
    <published>2017-07-24T13:51:48.000Z</published>
    <updated>2017-08-28T12:47:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1    概述"></a>1    概述</h1><p>互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration, CI）。持续集成也被认为是敏捷开发的最重要实践之一。</p>
<p>本文主要介绍持续集成的概念以及一些工具与实践。</p>
<h1 id="2-概念"><a href="#2-概念" class="headerlink" title="2    概念"></a>2    概念</h1><p><img src="http://otlnkjq1m.bkt.clouddn.com/CI-notion-relation.png" alt="图2.1 持续集成概念示意图之一"><br>图2.1 持续集成概念示意图之一</p>
<p>上图来源于<a href="http://blog.flow.ci/cicd_difference/" target="_blank" rel="external">谈谈持续集成，持续交付，持续部署之间的区别</a>，这图很直观地描述了持续集成相关的概念之间的关系，与持续集成密切相关的概念还有持续交付、持续部署，因此在下文将会就这三个概念进行阐述。</p>
<a id="more"></a>
<h2 id="2-1-持续集成"><a href="#2-1-持续集成" class="headerlink" title="2.1    持续集成"></a>2.1    持续集成</h2><p>维基百科的定义（<a href="https://en.wikipedia.org/wiki/Continuous_integration" target="_blank" rel="external">Continuous integration - Wikipedia</a>）：</p>
<blockquote>
<p>在软件工程里，持续集成（Continuous Integration, CI）是指这样的一种实践：在一天里多次将所有开发人员的代码合并到一个共享的主干里，每次合并都会触发持续集成服务器进行自动构建，这个过程包括了编译、单元测试、集成测试、质量分析等步骤，结果只有两个：成功或者失败。如果得到失败的结果，说明有人提交了不合格的代码，这就能及时发现问题。</p>
</blockquote>
<p>在瀑布模型中，软件的开发过程被分为以下几个阶段：</p>
<ul>
<li>需求分析</li>
<li>系统设计</li>
<li>编码实现</li>
<li>测试</li>
<li>集成</li>
<li>部署</li>
<li>维护</li>
</ul>
<p>而一般在实际的开发中，基本也就遵循这些步骤进行开发，大部分情况下，不会完全按照瀑布流的方式执行，但是这些步骤都是有的，无非就是在文档的落实、步骤的次序与侧重有所变化。其中，所谓的集成，在平时的开发过程中很少直接提到这个名词，其含义是（见：<a href="https://en.wikipedia.org/wiki/System_integration" target="_blank" rel="external">System integration - Wikipedia</a>）：</p>
<blockquote>
<p>将子系统的组件整合到一个系统中并且确保子系统的功能可以组合为一个系统的过程。</p>
</blockquote>
<p>所以，所谓的『集成』就是在存在多个系统协作的情况下，将子系统集成为一个大系统的过程，这个概念与『集成测试』中的『集成』是同一个概念。但是有些文章在解释『持续集成』这个概念的时候，将其解释为『将代码集成到主干分支』，目前也没见到有人说这是错的。</p>
<p>如果只有一个系统，那么就不存在『系统集成』这一个步骤，但是『持续集成』这个做法还是可以应用其中的，因为『持续集成』的精髓不在于『集成』，而在于『持续』，而我所理解的『持续』，就是将一些重复的操作自动化，然后频繁地触发这个自动化过程。</p>
<p>所以，结合上面提到的瀑布模型的几个阶段，以及『持续集成』这个名字，图2.1应该改为这样：</p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/CI-notion-relation-2.png" alt="图2.2 持续集成概念示意图之二"><br>图2.2 持续集成概念示意图之二</p>
<p>从上图中看来，持续集成应该至少包括以下几部分:</p>
<ul>
<li>自动化构建</li>
<li>自动化测试</li>
<li>自动发布</li>
</ul>
<p><img src="http://7xsn88.com1.z0.glb.clouddn.com/image/f/82/6ce32afc227588c4b60b143501dcd.png" alt="图2.3 持续集成阶段示意图"><br>图2.3 持续集成阶段示意图</p>
<p>每一次的构建与测试，都应该得到一个结果：通过或者不通过，开发人员应该都能看到每一次构建与测试的结果，得到不通过的结果时应该能马上修复相关的缺陷，这就需要有一种合适的反馈渠道。</p>
<h3 id="2-1-1-自动化构建"><a href="#2-1-1-自动化构建" class="headerlink" title="2.1.1 自动化构建"></a>2.1.1 自动化构建</h3><p>自动化构建包括以下过程：</p>
<ul>
<li>将源码编译成为二进制码</li>
<li>打包二进制码</li>
<li>运行自动化测试</li>
<li>生成文档</li>
<li>生成分发媒体（例如：Debian DEB、Red Hat RPM或者Windows MSI文件）</li>
</ul>
<p>自动化构建可以通过两类工具实现：</p>
<ol>
<li>构建自动化软件（Build automation utility）<ul>
<li>例如Make、Ant、Maven、Gradle，目的是通过编译等活动来生成构建产物（build artifact）。</li>
</ul>
</li>
<li>构建自动化服务器（Build automation servers）<ul>
<li>一般是基于web的工具，通过计划任务或者是事件触发的方式调用构建自动化软件。一个CI服务器就是一类构建自动化服务器。</li>
</ul>
</li>
</ol>
<h3 id="2-1-2-自动化测试"><a href="#2-1-2-自动化测试" class="headerlink" title="2.1.2    自动化测试"></a>2.1.2    自动化测试</h3><p>自动化测试是持续集成必不可少的一部分，基本上，没有自动化测试的持续集成，都很难称之为真正的持续集成。我们希望持续集成能够尽早的暴露问题，但这远非配置一个 Hudson/Jenkins服务器那么简单，只有真正用心编写了较为完整的测试用例，并一直维护它们，持续集成才能孜孜不倦地运行测试并第一时间报告问题。</p>
<p>测试自动化是使用特定的软件（独立于被测试的软件）来控制测试的执行以及比较实际输出与预期输出。测试自动化可以将某些重复但必要的任务自动化，或者执行某些难以手动执行的额外测试。</p>
<p>自动化测试还包括单元测试、集成测试、系统测试、验收测试、性能测试等，在不同的场景下，它们都能为软件开发带来极大的价值。</p>
<h4 id="2-1-2-1-单元测试"><a href="#2-1-2-1-单元测试" class="headerlink" title="2.1.2.1    单元测试"></a>2.1.2.1    单元测试</h4><p>单元测试（Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</p>
<p>通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到预期的工作目标，没有程序错误。</p>
<h4 id="2-1-2-2-集成测试"><a href="#2-1-2-2-集成测试" class="headerlink" title="2.1.2.2    集成测试"></a>2.1.2.2    集成测试</h4><p>集成测试（Integration Testing，有时也叫Integration and Testing, I&amp;T）即对独立的软件模块组装起来看成是一个整体进行测试。集成测试一般在单元测试之后、系统测试之前进行。实践表明，有时模块虽然可以单独工作，但是并不能保证组装起来也可以同时工作。</p>
<p>集成与单元测试最大的区别是它需要尽可能的测试整个功能及相关环境，对于测试Web应用而言，通常有这么几步：</p>
<ol>
<li>启动Web容器</li>
<li>部署待测试Web应用</li>
<li>以Web客户端的角色运行测试用例</li>
<li>停止Web容器</li>
</ol>
<p>通常有三种手段实现集成测试：</p>
<ol>
<li><p>大爆炸（Big Bang）<br>将所有单元组合到一起一次性测试一遍。</p>
</li>
<li><p>自上而下（Top Down）<br>先测试高层次的单元，然后逐渐测试低层次的单元。</p>
</li>
<li><p>自下而上（Bottom Up）<br>先测试低层次的单元，然后逐渐测试高层次的单元。</p>
</li>
</ol>
<h2 id="2-2-持续交付"><a href="#2-2-持续交付" class="headerlink" title="2.2    持续交付"></a>2.2    持续交付</h2><p><img src="http://7xsn88.com1.z0.glb.clouddn.com/image/e/bd/d757dd642e93e33fede310325b155.png" alt=""><br>图2.4 持续交付示意图</p>
<p>持续交付（Continuous Delivery, CD）是一种软件工程的手段，让软件在短周期内产出，确保软件随时可以被可靠地发布。其目的在于更快、更频繁地构建、测试以及发布软件。通过加强对生产环境的应用进行渐进式更新，这种手段可以降低交付变更的成本与风险。一个简单直观的与可重复的部署过程对于持续交付来说是很重要的。</p>
<h3 id="2-2-1-与DevOps的关系"><a href="#2-2-1-与DevOps的关系" class="headerlink" title="2.2.1 与DevOps的关系"></a>2.2.1 与DevOps的关系</h3><p>持续交付与DevOps的含义很相似，所以经常被混淆。但是它们是不同的两个概念。DevOps的范围更广，它以文化变迁为中心，特别是软件交付过程所涉及的多个团队之间的合作（开发、运维、QA、管理部门等），并且将软件交付的过程自动化。另一方面，持续交付是一种自动化交付的手段，关注点在于将不同的过程集中起来，并且更快、更频繁地执行这些过程。因此，DevOps可以是持续交付的一个产物，持续交付直接汇入DevOps。</p>
<h3 id="2-2-2-与持续部署的关系"><a href="#2-2-2-与持续部署的关系" class="headerlink" title="2.2.2 与持续部署的关系"></a>2.2.2 与持续部署的关系</h3><p>有时候，持续交付也与持续部署混淆。持续部署意味着所有的变更都会被自动部署到生产环境中。持续交付意味着所有的变更都可以被部署到生产环境中，但是出于业务考虑，可以选择不部署。如果要实施持续部署，必须先实施持续交付。</p>
<h3 id="2-2-3-原则"><a href="#2-2-3-原则" class="headerlink" title="2.2.3 原则"></a>2.2.3 原则</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c3/Continuous_Delivery_process_diagram.svg" alt=""><br>图2.5 持续交付流水线示意图</p>
<p>持续交付将部署流水线（<strong>deployment pipeline</strong>）这个老生常谈的概念看作一种简单的防错方法：一系列的确认。通过这些确认，一款软件必须遵循特定的路径来发布。每当有变更被提交到源码控制仓库中时，代码要首先进行编译（有必要的话），然后由构建服务器进行打包，接着由一些不同的技术来进行测试，最后才可以将代码标记为可发布的（releasable）。</p>
<p>在一个持续交付环境中工作时，习惯了漫长开发周期的开发人员或许需要改变他们心态。任何代码提交在任何时间点都可能会向客户发布，明白这一点是很重要的。对于在早期提交尚未准备好让用户使用的代码，类似功能开关这样的模式是很有用的。使用NoSQL可以消除持续交付工作流中的数据迁移和模式变更的步骤、手工操作步骤以及异常情况。对于代码隔离的其他有用的技术——例如代码分支——在持续交付工作流中并未过时，但是必须加以修改以适应持续交付的原则。例如，运行多个长生命周期的代码分支是不实际的，因为一个可发布的产物如果要经历流水线的所有阶段，它必须从一个单独的分支中构建而来。</p>
<h2 id="2-3-持续部署"><a href="#2-3-持续部署" class="headerlink" title="2.3    持续部署"></a>2.3    持续部署</h2><p><img src="http://7xsn88.com1.z0.glb.clouddn.com/image/0/3a/6b241b45b65eb7d77927619015d84.png" alt=""><br>图2.6 持续部署示意图</p>
<p>如图所示，持续部署与持续交付之间的差异就是前者将部署自动化了。</p>
<p>在持续交付的实践中，交付的目标是QA，但是实际上，软件最终是要交付到客户手上的。在SaaS领域里，持续部署采用得比较广泛，因为服务比较容易做到静默升级。</p>
<p>采用持续部署的前提是自动化测试的覆盖率足够高。</p>
<p>采用持续部署的好处是能减少运维的工作量，缩短新特性从开发到实际交付的周期。</p>
<h1 id="3-代价与好处"><a href="#3-代价与好处" class="headerlink" title="3    代价与好处"></a>3    代价与好处</h1><h2 id="3-1-代价"><a href="#3-1-代价" class="headerlink" title="3.1    代价"></a>3.1    代价</h2><ol>
<li>构造自动测试用例会耗费大量的工作，而且要去覆盖不断增加的新功能点，也要随着代码的改动去修改测试用例。<ul>
<li>测试被视为软件开发的一种最佳实践。无论是否采用持续集成，在一些方法论里——例如测试驱动开发——自动化测试都是必不可少的一部分。</li>
<li>采用持续集成的时候也可以不使用任何测试用例，但是在发布一个产品之前的质量保证（Quality Assurance）成本就会变得很高，因为一切都要频繁地采用人手操作。</li>
</ul>
</li>
<li>要花费精力去部署一个构建系统，这有时候会比较复杂，难以灵活地修改<ul>
<li>然而，有大量的开源的持续集成软件项目，选择很多</li>
</ul>
</li>
<li>如果项目比较小，或者包含了未经测试的遗留代码，持续集成的价值就并不是那么大</li>
<li>持续集成所增加的价值依赖于测试的质量以及代码实际上的可测试程度。</li>
<li>团队规模大就意味着代码会非常频繁地提交到集成队列里，跟踪提交就会比较困难，并且排队进行构建会减慢每个人的工作，如果构建失败，整个开发团队必须停下手里的工作，立刻修复他们的错误。<ul>
<li>但是持续集成是可以灵活变通的，不一定要在一天里多次构建，可以配置每天下班前半小时自动构建，有错误的话开发人员可以在下班前进行处理；或者每天凌晨自动构建，第二天早上开发人员一上班就能看到构建的结果报告，然后进行处理。</li>
</ul>
</li>
<li>一天里有多个提交和合并，一个新功能的部分代码能轻易地推送上去，在新功能完成之前，集成测试都是不通过的。</li>
</ol>
<h2 id="3-2-好处"><a href="#3-2-好处" class="headerlink" title="3.2    好处"></a>3.2    好处</h2><ol>
<li>能快速发现错误和定位错误</li>
<li>避免在发布日期大家都在检查自己有冲突的版本，造成混乱</li>
<li>当单元测试不通过或者出现bug的时候，如果开发人员需要回滚代码，只会造成少量的改动丢失，因为集成是频繁的。</li>
<li>防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。</li>
<li>无论对于测试、demo还是发布的目的或需求，总是有一份当前的构建可用。</li>
<li>频繁的代码检查驱使开发人员编写模块化的、低复杂度的代码。</li>
</ol>
<h1 id="4-具体实践"><a href="#4-具体实践" class="headerlink" title="4    具体实践"></a>4    具体实践</h1><h2 id="4-1-工具"><a href="#4-1-工具" class="headerlink" title="4.1    工具"></a>4.1    工具</h2><table>
<thead>
<tr>
<th>名称</th>
<th>授权</th>
<th>价格</th>
<th>Git支持</th>
<th>Docker支持</th>
<th>自动测试</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Jenkins</td>
<td>MIT</td>
<td>免费</td>
<td>不支持</td>
<td>不支持</td>
<td>需插件支持</td>
<td></td>
</tr>
<tr>
<td>GitLab CI</td>
<td>MIT</td>
<td>免费</td>
<td>支持</td>
<td>支持</td>
<td>需自配测试服务</td>
<td></td>
</tr>
<tr>
<td>Phabricator</td>
<td>Apache 2.0</td>
<td>免费</td>
<td>支持</td>
<td></td>
<td></td>
<td>Facebook出品</td>
</tr>
<tr>
<td>Travis CI</td>
<td></td>
<td>免费</td>
<td>支持</td>
<td>支持</td>
<td></td>
<td>不支持私有部署</td>
</tr>
<tr>
<td>Bamboo</td>
<td></td>
<td>收费</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>Codeship</td>
<td></td>
<td>免费/收费</td>
<td>关联Github, GitLab</td>
<td>支持</td>
<td></td>
<td>不支持私有部署</td>
</tr>
<tr>
<td>CircleCI</td>
<td></td>
<td>免费/收费</td>
<td>关联Github</td>
<td>支持</td>
<td>支持大部分测试框架</td>
<td>不支持私有部署</td>
</tr>
<tr>
<td>Hudson</td>
<td>Eclipse Public License 1.0</td>
<td>免费</td>
<td>需插件</td>
<td>需插件</td>
<td></td>
</tr>
</tbody>
</table>
<p>其实这里的支持，意思应该是直接的支持，例如Jenkins，其实和git结合也很简单，通过脚本就可以实现。</p>
<h1 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5    参考资料"></a>5    参考资料</h1><ol>
<li>Maven实战（五）——自动化Web应用集成测试<br><a href="http://www.infoq.com/cn/news/2011/03/xxb-maven-5-integration-test" target="_blank" rel="external">http://www.infoq.com/cn/news/2011/03/xxb-maven-5-integration-test</a></li>
<li>单元测试 - 维基百科<br><a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95</a></li>
<li>Integration testing – Wikipedia<br><a href="https://en.wikipedia.org/wiki/Integration_testing" target="_blank" rel="external">https://en.wikipedia.org/wiki/Integration_testing</a></li>
<li>Continuous integration – Wikipedia<br><a href="https://en.wikipedia.org/wiki/Continuous_integration" target="_blank" rel="external">https://en.wikipedia.org/wiki/Continuous_integration</a></li>
<li>Continuous integration | ThoughtWorks<br><a href="https://www.thoughtworks.com/continuous-integration" target="_blank" rel="external">https://www.thoughtworks.com/continuous-integration</a></li>
<li>另一种声音：持续集成已死<br><a href="http://www.infoq.com/cn/news/2014/10/continuous-integration" target="_blank" rel="external">http://www.infoq.com/cn/news/2014/10/continuous-integration</a></li>
<li>持续集成是什么？<br><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html</a></li>
<li>25 best continuous integration tools as of 2017 - Slant<br><a href="https://www.slant.co/topics/799/~best-continuous-integration-tools" target="_blank" rel="external">https://www.slant.co/topics/799/~best-continuous-integration-tools</a></li>
<li>Bamboo vs Jenkins Comparison | Atlassian<br><a href="https://www.atlassian.com/software/bamboo/comparison/bamboo-vs-jenkins" target="_blank" rel="external">https://www.atlassian.com/software/bamboo/comparison/bamboo-vs-jenkins</a></li>
<li>通过Docker容器运行持续集成/持续部署<br><a href="http://dockone.io/article/468" target="_blank" rel="external">http://dockone.io/article/468</a></li>
<li>Continuous Integration, Deployment &amp; Delivery with Codeship<br><a href="https://codeship.com" target="_blank" rel="external">https://codeship.com</a></li>
<li>谈谈持续集成，持续交付，持续部署之间的区别<br><a href="http://blog.flow.ci/cicd_difference/" target="_blank" rel="external">http://blog.flow.ci/cicd_difference/</a></li>
<li>Continuous delivery – Wikipedia<br><a href="https://en.wikipedia.org/wiki/Continuous_delivery" target="_blank" rel="external">https://en.wikipedia.org/wiki/Continuous_delivery</a></li>
<li>Build automation – Wikipedia<br><a href="https://en.wikipedia.org/wiki/Build_automation" target="_blank" rel="external">https://en.wikipedia.org/wiki/Build_automation</a></li>
<li>List of build automation software – Wikipedia<br><a href="https://en.wikipedia.org/wiki/List_of_build_automation_software" target="_blank" rel="external">https://en.wikipedia.org/wiki/List_of_build_automation_software</a></li>
<li>Software development process - Wikipedia<br><a href="https://en.wikipedia.org/wiki/Software_development_process" target="_blank" rel="external">https://en.wikipedia.org/wiki/Software_development_process</a></li>
<li>System integration - Wikipedia<br><a href="https://en.wikipedia.org/wiki/System_integration" target="_blank" rel="external">https://en.wikipedia.org/wiki/System_integration</a></li>
<li>Continuous Integration - Martin Fowler<br><a href="https://martinfowler.com/articles/continuousIntegration.html#PracticesOfContinuousIntegration" target="_blank" rel="external">https://martinfowler.com/articles/continuousIntegration.html#PracticesOfContinuousIntegration</a></li>
<li>Integration Testing - Software Testing Fundamentals<br><a href="http://softwaretestingfundamentals.com/integration-testing/" target="_blank" rel="external">http://softwaretestingfundamentals.com/integration-testing/</a></li>
<li>Practical continuous deployment: a guide to automated software delivery<br><a href="https://www.atlassian.com/blog/continuous-delivery/practical-continuous-deployment" target="_blank" rel="external">https://www.atlassian.com/blog/continuous-delivery/practical-continuous-deployment</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1    概述&quot;&gt;&lt;/a&gt;1    概述&lt;/h1&gt;&lt;p&gt;互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration, CI）。持续集成也被认为是敏捷开发的最重要实践之一。&lt;/p&gt;
&lt;p&gt;本文主要介绍持续集成的概念以及一些工具与实践。&lt;/p&gt;
&lt;h1 id=&quot;2-概念&quot;&gt;&lt;a href=&quot;#2-概念&quot; class=&quot;headerlink&quot; title=&quot;2    概念&quot;&gt;&lt;/a&gt;2    概念&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://otlnkjq1m.bkt.clouddn.com/CI-notion-relation.png&quot; alt=&quot;图2.1 持续集成概念示意图之一&quot;&gt;&lt;br&gt;图2.1 持续集成概念示意图之一&lt;/p&gt;
&lt;p&gt;上图来源于&lt;a href=&quot;http://blog.flow.ci/cicd_difference/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;谈谈持续集成，持续交付，持续部署之间的区别&lt;/a&gt;，这图很直观地描述了持续集成相关的概念之间的关系，与持续集成密切相关的概念还有持续交付、持续部署，因此在下文将会就这三个概念进行阐述。&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件工程" scheme="http://bungder.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="持续集成" scheme="http://bungder.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>一种RESTful接口的约定</title>
    <link href="http://bungder.github.io/2017/07/24/REST/"/>
    <id>http://bungder.github.io/2017/07/24/REST/</id>
    <published>2017-07-24T13:05:13.000Z</published>
    <updated>2017-08-20T14:08:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h2 id="1-1-撰写目的"><a href="#1-1-撰写目的" class="headerlink" title="1.1 撰写目的"></a>1.1 撰写目的</h2><p>本文用于定义一种统一的RESTful接口设计方案，希望具有参考价值。本文所描述的方案比较学院派（死板），在上一家公司提出没有被采纳，在所了解到的有限的若干家声称采用了RESTful风格的公司里，发现他们也偏离甚远，而在书本以及网上大部分介绍RESTful的资料里，却都是这样的方案（URL命名风格、请求与响应的设计）。当然，他们这么做是有理由的，我也理解，这只是取舍问题。这篇文章其实是旧文了，2016年年底就已经写好，但是一直躺在电脑的硬盘里，不想白费了当时的功夫，因此在此公开。</p>
<h2 id="1-2-为什么采用REST"><a href="#1-2-为什么采用REST" class="headerlink" title="1.2    为什么采用REST"></a>1.2    为什么采用REST</h2><p>目的是为了服务端与客户端的解耦。SOA仅仅是从结构上将前后端分离，但是实际上数据逻辑还是没有实现解耦，服务端接口升级往往会影响客户端，两者的行为需要严格约定。而REST采用HTTP协议进行约定，客户端仅仅需要按照HTTP协议来理解服务端返回的数据，虽然与业务相关的数据结构还是需要约定，但是这确实进一步解耦了服务端与客户端。</p>
<p>另外，由于严格遵照HTTP协议进行数据返回，对于安全的接口，可以在返回的Header里设置缓存策略（接口安全性的概念在下文会解释）。</p>
<a id="more"></a>
<h2 id="1-3-文档结构"><a href="#1-3-文档结构" class="headerlink" title="1.3 文档结构"></a>1.3 文档结构</h2><p>第二部分将阐述关于RESTful的若干个关键的概念，明确第二部分阐述的几个概念有利于设计、实现优雅规范的接口。</p>
<p>第三部分就URL命名的问题进行约定。</p>
<p>第四部分对消息实体进行约定。</p>
<p>第五部分对『向RESTful接口发起请求』进行阐述，约定要实现的方法，约定请求的头部和body的格式。</p>
<p>第六部分对接口的响应格式进行约定，包括响应消息的头部、状态码、JSON实体。</p>
<p>第七部分对版本控制的问题进行约定。</p>
<p>第八部分对RESTful接口的实现提出了实现工具的建议。</p>
<h1 id="2-关键概念"><a href="#2-关键概念" class="headerlink" title="2    关键概念"></a>2    关键概念</h1><p>明确一些关键的概念是很重要的，虽然RESTful风格的API设计方案并没有统一的标准，但是还是需要符合一定的原则进行设计，否则就不能称为RESTful风格的API。因为许多人并没有对REST进行充分的了解就宣称自己的API是RESTful风格的API，以至于RESTful的提出者Fielding博士本人无法忍受，在2008年为此专门写了一篇博客『<strong>REST APIs must be hypertext-driven</strong>』，hypertext-driven与HATEOAS是同一个概念的不同表述，在下文会进行阐述。</p>
<h2 id="2-1-RESTful"><a href="#2-1-RESTful" class="headerlink" title="2.1     RESTful"></a>2.1     RESTful</h2><p><strong>REST</strong>不是一种协议，也不是一种文件格式，更不是一种开发框架。它是一系列的设计约束的集合：无状态性、将超媒体作为应用状态的引擎等。REST是<strong>Representation State Transfer</strong>的缩写，中文是『表述性状态转移』，这里就涉及到资源的表述与状态两个概念。</p>
<p>简单地说，资源可以看作是服务器上存储的所有数据，资源的表述则是服务器对外提供的指向这些资源的方式，使用JSON、XML等均可，一个资源可以有多种表述；资源的状态则是服务器的数据存储状态，例如在t时刻，服务器中存储了m条数据，这时候客户端向服务端提交了一个创建数据的请求，服务器处理了此请求并创建了一条数据，那么在t+1时刻，服务器中就存储了m+1条数据，这两个时刻的资源状态就是不一样的，t时刻发生的请求导致了资源状态的改变。</p>
<h2 id="2-2-HATEOAS"><a href="#2-2-HATEOAS" class="headerlink" title="2.2    HATEOAS"></a>2.2    HATEOAS</h2><p><strong>Hypermedia As The Engine Of Application State</strong>，超媒体作为应用程序状态的引擎。这是REST区别于其他SOA风格的主要特点。客户端与服务端进行互动的时候，完全是通过服务端动态提供的超媒体进行的。除了对超媒体的一般理解，客户端不需要知道其他额外的知识。相反，在一些SOA接口的设计中，客户端与服务端的通信是要事先进行约定的，例如通过文档或者接口描述语言（Interface Description Language, IDL）。而基于HTTP协议的REST设计里，一般采用的就是请求与响应的Header来体现HATEOAS原则（具体请参考：<a href="https://en.wikipedia.org/wiki/HATEOAS" target="_blank" rel="external">https://en.wikipedia.org/wiki/HATEOAS</a>）。这里也隐含这样一层含义：REST应尽可能地利用HTTP标准中现有的东西，例如Header、标准方法与状态码。</p>
<p>从标准的角度看，HTTP标准是一项RFC标准，世界认可；而其他自定义的SOA标准则可能是一项个人标准或者公司标准，最多是一项互联网草案（这对大部分公司来说都不可能），而一项标准越是被广为认可接受，其实现的通用性就越强。个人标准和公司标准都五花八门，这样对每一个标准都要参照其相关文档实现相应的行为逻辑是很麻烦的。</p>
<h2 id="2-3-安全性"><a href="#2-3-安全性" class="headerlink" title="2.3    安全性"></a>2.3    安全性</h2><p>一个方法被调用1次与被调用0次是一样的，此方法就是安全的，否则就是不安全的。例如，一个方法A仅仅是读取数据，并不创建或者修改数据，不论A方法被调用多少次，都不对数据记录产生任何影响，A方法是安全的。而假如有另一个方法B对数据进行删除，B方法被调用1次后，数据会被删除（或者标识位被修改），系统里的数据发生了变化，那么B方法是不安全的。</p>
<h2 id="2-4-幂等性"><a href="#2-4-幂等性" class="headerlink" title="2.4    幂等性"></a>2.4    幂等性</h2><p>一个方法被同样地调用1次与被调用多次是一样的，即同样的输入会得到同样的输出，此方法就是幂等的，否则就不是幂等的。</p>
<p>2.3节中A方法与B方法都是幂等的，一个安全的方法一定是幂等的，一个幂等的方法不一定是安全的。</p>
<p>假设一个方法C对某个全局计数器执行自增操作并写入数据库，每次调用C方法都会对系统数据产生影响，那么C方法就不是幂等的。</p>
<h1 id="3-URL命名"><a href="#3-URL命名" class="headerlink" title="3 URL命名"></a>3 URL命名</h1><p>URL用于标识资源，因此URL应该以名词进行命名，例如<code>/users</code>, <code>/users/children</code>等。</p>
<p>一般URL会内嵌参数，例如要获取id为313的user的信息，那么URL应该为<code>/users/313</code>，前面的user采用复数，如果要列出其所有后代，则URL应为<code>/users/313/children</code>，children为复数形式，如果要获取其id为499的后代，则URL应为<code>/users/313/children/499</code></p>
<h1 id="4-消息实体"><a href="#4-消息实体" class="headerlink" title="4    消息实体"></a>4    消息实体</h1><p>消息实体，就是请求和响应消息中的<code>entity-body</code>（也称为body），消息实体采用JSON字符串格式。</p>
<h1 id="5-请求"><a href="#5-请求" class="headerlink" title="5 请求"></a>5 请求</h1><h2 id="5-1-方法"><a href="#5-1-方法" class="headerlink" title="5.1    方法"></a>5.1    方法</h2><p>使用HTTP标准定义的请求方法。</p>
<h3 id="5-1-1-get"><a href="#5-1-1-get" class="headerlink" title="5.1.1    get"></a>5.1.1    get</h3><p>获取资源，单个参数一般写在URL上，多个参数则作为query parameter附在URL后面，例如：</p>
<ul>
<li>单个参数：/user/123, 表示id为123的user</li>
<li>多个参数：/user?name=tom&amp;phone=13787890987&amp;gender=male</li>
</ul>
<p>get方法应为幂等的，并且不对数据记录产生影响。对于汉字与特殊字符，应该进行urlencode。</p>
<h3 id="5-1-2-post"><a href="#5-1-2-post" class="headerlink" title="5.1.2    post"></a>5.1.2    post</h3><p>创建资源，请求的headers里设置<code>Content-type</code>为<code>application/json</code>，参数为json类型。</p>
<p>根据约定，在创建成功之后，返回的状态码应该是201（Created），并且在response的Header里设置Location为新创建的资源的URL，例如，创建了一个新的user，该user创建后id为888，那么Header里应该设置<code>Location</code>为<code>/users/888</code>，当然，这应该是一个完整的URL，这里只是给出了一个相对路径的URI以作为说明。返回了这些数据后，客户端可以自定义后续行为，或者查看创建后的user，或者刷新当前的user列表，这些行为服务端并不关心。</p>
<p>如果重复提交了相同的数据，第一次应该返回201，以后则应返回409（Conflict），并且在response的Header里设置Location指向已经存在的资源，说明冲突的来源。</p>
<h3 id="5-1-3-put"><a href="#5-1-3-put" class="headerlink" title="5.1.3    put"></a>5.1.3    put</h3><p>更新资源，对现有资源进行修改，请求的headers与post一样，参数也是。此方法应该是幂等的。</p>
<h3 id="5-1-4-delete"><a href="#5-1-4-delete" class="headerlink" title="5.1.4    delete"></a>5.1.4    delete</h3><p>删除资源。此方法应是幂等的。</p>
<h2 id="5-2-Header"><a href="#5-2-Header" class="headerlink" title="5.2    Header"></a>5.2    Header</h2><p>Content-type应设为application/json。</p>
<p>另外应设置一个version，指明所使用的接口版本。这不属于HTTP协议中的一部分，是自定义的，出于版本控制的考量，具体见第七章。</p>
<h2 id="5-3-body"><a href="#5-3-body" class="headerlink" title="5.3    body"></a>5.3    body</h2><p>采用JSON字符串，具体的结构有待商定，这不属于HTTP协议的一部分，是自定义的。</p>
<p>这里主要放置业务相关的数据。</p>
<p>借用<a href="http://www.infoq.com/cn/articles/rest-introduction" target="_blank" rel="external">一篇10年前的文章</a>的一张图：<br><img src="http://otlnkjq1m.bkt.clouddn.com/REST_resources.jpg" alt=""></p>
<h1 id="6-响应"><a href="#6-响应" class="headerlink" title="6    响应"></a>6    响应</h1><h2 id="6-1-Header"><a href="#6-1-Header" class="headerlink" title="6.1    Header"></a>6.1    Header</h2><p>根据响应的状态码不同，相应地设置头部，具体见下一节。</p>
<p>但是在我所了解的公司里，做法都是统一返回200，然后在返回的JSON字符串里设置消息码。我是不能理解的。据一位前端同学说，前端代码接收到了请求以后，不方便获取Http状态码。其实我也写过前端，不深入，但是一些基本的知识还是有的，我觉得这并不难做到，估计是他的代码封装的时候没有考虑到这一点，现在要改比较麻烦，所以不想大动干戈、伤筋动骨。</p>
<h2 id="6-2-状态码"><a href="#6-2-状态码" class="headerlink" title="6.2    状态码"></a>6.2    状态码</h2><table>
<thead>
<tr>
<th>状态码</th>
<th>语义</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>OK</td>
<td>正常返回消息，什么问题也没有</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>创建资源成功，Header里应设置Location指向新创建的资源</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>请求已被接收，但是处理过程较长，不能马上返回结果</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>没有任何修改发生</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>缺乏权限，指已经登录但是缺乏请求这个资源的权限</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>拒绝访问，可用于未登录时拦截返回的状态码，此时Header里应设置Location为登录页面的URL</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>不存在所请求的资源</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>请求没有被接收，参数约束校验不通过，或者其他业务类型的错误都可以返回这个状态码，response的body里应有表示错误信息的JSON实体。</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>请求的资源有冲突，例如多次提交一样的创建请求，response的Header里应设置Location为产生冲突的资源的URL</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器的非业务类错误，response的body里应有表示错误信息的JSON实体</td>
</tr>
</tbody>
</table>
<h2 id="6-3-body采用JSON字符串。"><a href="#6-3-body采用JSON字符串。" class="headerlink" title="6.3    body采用JSON字符串。"></a>6.3    body采用JSON字符串。</h2><p>JSON的结构分为两种：成功、失败。</p>
<p>一般而言，只有返回200的时候才需要读取成功的JSON，只有返回406和500的时候才需要读取失败的JSON，对于其他的状态码，客户端不需要服务器提供额外的消息。</p>
<p>对于成功的JSON，里面应该只包含一个result对象，而失败的JSON应该使用这样的结构：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    error: &#123;</div><div class="line">        code: xxx,</div><div class="line">        message: <span class="string">"xxx"</span>,</div><div class="line">        data: <span class="meta">&#123;...&#125;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>失败的JSON只有一个error对象，包含错误码、消息及相关数据，message应该是直接可读的消息，客户端毋需理解发生了什么错误，客户端只需将消息展示出来即可。在收到406的时候，客户端只需知道发生的错误是由客户端造成的即可，具体是什么类型并不需要知道，将消息直接展示出来，让使用的人知道是什么即可，所以message应该是人类可以理解的文本。同理，收到500的时候，只需知道这个错误是服务端的问题即可，客户端也毋需知道具体的错误类型，最多就将错误码和消息展示出来，让使用者有反馈的依据即可。</p>
<h1 id="7-版本控制"><a href="#7-版本控制" class="headerlink" title="7 版本控制"></a>7 版本控制</h1><p>考虑到接口有可能升级，升级的类型有几种：</p>
<ol>
<li>新增功能接口</li>
<li>原有接口返回数据增加字段</li>
<li>现有接口返回数据变更现有字段格式或删除现有字段</li>
<li>现有接口变更业务逻辑</li>
<li>删除接口</li>
</ol>
<p>其中，前两种升级并不会影响客户端，因此毋需处理。而后面三种会导致使用旧接口的客户端不能正常工作。</p>
<p>一般服务端升级与客户端升级都不是同步的，客户端升级往往会滞后，因此在服务端升级后应该保留旧版本的接口继续运行一段时间，让未升级的客户端可以继续工作一段时间，同时可以上线新版本的客户端。过一段时间后再将旧版本的接口下线。</p>
<p>而版本控制应该是向下兼容的，即假设当前版本是1.2，如果客户端请求1.3版本的服务，应当用当前版本提供服务。如果没有注明请求的版本号，应当提供当前版本的服务。</p>
<p>一般情况下，客户端请求需要带版本号，但是服务端并不需要对此进行处理，除非是同时运行新旧版本的同一个接口，才需要做差异处理。</p>
<h1 id="8-实现工具"><a href="#8-实现工具" class="headerlink" title="8 实现工具"></a>8 实现工具</h1><h2 id="8-1-Spring-HATEOAS"><a href="#8-1-Spring-HATEOAS" class="headerlink" title="8.1    Spring HATEOAS"></a>8.1    Spring HATEOAS</h2><p>Spring HATEOAS可以很方便地与Spring MVC结合来开发RESTful接口。具体参照其文档：<br><a href="http://docs.spring.io/spring-hateoas/docs/0.20.0.RELEASE/reference/html/#fundamentals.jaxb-json" target="_blank" rel="external">http://docs.spring.io/spring-hateoas/docs/0.20.0.RELEASE/reference/html/#fundamentals.jaxb-json</a></p>
<h1 id="9-缺陷"><a href="#9-缺陷" class="headerlink" title="9 缺陷"></a>9 缺陷</h1><p>其实这个方案基本就是网上一些被大部分人认可的做法的汇总，但是缺乏细节，例如分页，但是其实这些可以灵活变通，例如在查询字符串里加上分页参数。《<a href="https://ruby-china.org/topics/31822" target="_blank" rel="external">一次无后端的供应链系统开发实践 (上篇)： 前后端分离的 Restful 接口设计</a>》这篇文章的设计就比较全面，但是两者考量的问题范畴不同，他这个是serverless的设计，将业务逻辑都压在前端，后端仅仅作为前端与数据源之间的代理（数据源、客户端都在自己控制范围内的话其实没必要这样搞），这样的话，接口要表达的逻辑就比较复杂，而本文还是从传统的抽象思想去考虑，逻辑都在后端封装，因此接口并不需要表达多么复杂的逻辑。</p>
<h1 id="10-参考文献"><a href="#10-参考文献" class="headerlink" title="10 参考文献"></a>10 参考文献</h1><p>当时写的时候没记下来，所以就不列出来了，在此不保证来源的权威性，请读者自行鉴别。^_^</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-撰写目的&quot;&gt;&lt;a href=&quot;#1-1-撰写目的&quot; class=&quot;headerlink&quot; title=&quot;1.1 撰写目的&quot;&gt;&lt;/a&gt;1.1 撰写目的&lt;/h2&gt;&lt;p&gt;本文用于定义一种统一的RESTful接口设计方案，希望具有参考价值。本文所描述的方案比较学院派（死板），在上一家公司提出没有被采纳，在所了解到的有限的若干家声称采用了RESTful风格的公司里，发现他们也偏离甚远，而在书本以及网上大部分介绍RESTful的资料里，却都是这样的方案（URL命名风格、请求与响应的设计）。当然，他们这么做是有理由的，我也理解，这只是取舍问题。这篇文章其实是旧文了，2016年年底就已经写好，但是一直躺在电脑的硬盘里，不想白费了当时的功夫，因此在此公开。&lt;/p&gt;
&lt;h2 id=&quot;1-2-为什么采用REST&quot;&gt;&lt;a href=&quot;#1-2-为什么采用REST&quot; class=&quot;headerlink&quot; title=&quot;1.2    为什么采用REST&quot;&gt;&lt;/a&gt;1.2    为什么采用REST&lt;/h2&gt;&lt;p&gt;目的是为了服务端与客户端的解耦。SOA仅仅是从结构上将前后端分离，但是实际上数据逻辑还是没有实现解耦，服务端接口升级往往会影响客户端，两者的行为需要严格约定。而REST采用HTTP协议进行约定，客户端仅仅需要按照HTTP协议来理解服务端返回的数据，虽然与业务相关的数据结构还是需要约定，但是这确实进一步解耦了服务端与客户端。&lt;/p&gt;
&lt;p&gt;另外，由于严格遵照HTTP协议进行数据返回，对于安全的接口，可以在返回的Header里设置缓存策略（接口安全性的概念在下文会解释）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="REST" scheme="http://bungder.github.io/tags/REST/"/>
    
  </entry>
  
</feed>
