<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gordon</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bungder.github.io/"/>
  <updated>2018-05-06T10:07:18.237Z</updated>
  <id>http://bungder.github.io/</id>
  
  <author>
    <name>Gordon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>几种开源的媒体服务器对比</title>
    <link href="http://bungder.github.io/2018/05/06/compare-of-some-open-source-media-server/"/>
    <id>http://bungder.github.io/2018/05/06/compare-of-some-open-source-media-server/</id>
    <published>2018-05-06T09:52:27.000Z</published>
    <updated>2018-05-06T10:07:18.237Z</updated>
    
    <content type="html"><![CDATA[<p>本文对几种开源的流媒体服务器做对比。</p>
<a id="more"></a>
<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h1><h2 id="1-1-RTP"><a href="#1-1-RTP" class="headerlink" title="1.1 RTP"></a>1.1 RTP</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%AE%9E%E6%97%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">实时传输协议 - 维基百科，自由的百科全书</a></p>
<blockquote>
<p><strong>实时传输协议（Real-time Transport Protocol或简写RTP）</strong>是一个网络传输协议，它是由IETF的多媒体传输工作小组1996年在RFC 1889中公布的。</p>
<p>RTP协议详细说明了在互联网上传递音频和视频的标准数据包格式。它一开始被设计为一个多播协议，但后来被用在很多单播应用中。RTP协议常用于流媒体系统（配合RTSP协议），视频会议和一键通（Push to Talk）系统（配合H.323或SIP），使它成为IP电话产业的技术基础。RTP协议和RTP控制协议RTCP一起使用，而且它是创建在<strong>UDP</strong>协议上的。</p>
</blockquote>
<h2 id="1-2-RTMP"><a href="#1-2-RTMP" class="headerlink" title="1.2 RTMP"></a>1.2 RTMP</h2><p><a href="https://zh.wikipedia.org/wiki/%E5%AE%9E%E6%97%B6%E6%B6%88%E6%81%AF%E5%8D%8F%E8%AE%AE" target="_blank" rel="external">实时消息协议 - 维基百科，自由的百科全书</a></p>
<blockquote>
<p><strong>实时消息协议（英语：Real-Time Messaging Protocol，缩写RTMP）</strong>也称实时消息传输协议，是最初由Macromedia为通过互联网在Flash播放器与一个服务器之间传输流媒体音频、视频和数据而开发的一个专有协议。Macromedia后被Adobe Systems收购，该协议也已发布了不完整的规范供公众使用。</p>
<p>RTMP协议有许多变种：</p>
<ol>
<li>默认使用TCP端口1935的纯粹（plain）协议。</li>
<li><strong>RTMPS</strong>，通过一个TLS/SSL连接传输RTMP。</li>
<li><strong>RTMPE</strong>，使用Adobe自有安全机制加密的RTMP。虽然实现的细节为专有，但该机制使用行业标准的密码学原函数。</li>
<li><strong>RTMPT</strong>，用HTTP封装以穿透防火墙。RTMPT通常在TCP通信端口80和443上使用明文请求来绕过大多数的公司流量过滤。封装的会话中可能携带纯粹的RTMP、RTMPS或RTMPE数据包。</li>
<li><strong>RTMFP</strong>, 使用UDP而非TCP的RTMP，取代RTMP Chunk Stream。Adobe Systems开发了安全的实时媒体流协议包，可以让最终用户直接地相互连接（P2P）。</li>
</ol>
</blockquote>
<h2 id="1-3-WebRTC"><a href="#1-3-WebRTC" class="headerlink" title="1.3 WebRTC"></a>1.3 WebRTC</h2><p><a href="https://webrtc.org/" target="_blank" rel="external">https://webrtc.org/</a></p>
<blockquote>
<p><strong>WebRTC is a free, open project</strong> that provides browsers and mobile applications with <em>Real-Time Communications (RTC)</em> capabilities via simple APIs. The WebRTC components have been optimized to best serve this purpose.</p>
<p><strong>Our mission</strong>: To enable rich, high-quality RTC applications to be developed for the browser, mobile platforms, and IoT devices, and allow them all to communicate via a common set of protocols.</p>
<p>The WebRTC initiative is a project supported by <strong>Google</strong>, <strong>Mozilla</strong> and <strong>Opera</strong>, amongst others.</p>
</blockquote>
<p>支持的浏览器和平台：</p>
<ul>
<li>Chrome</li>
<li>Firefox</li>
<li>Opera</li>
<li>Android</li>
<li>iOS</li>
</ul>
<p>特点：</p>
<ul>
<li>基于浏览器，且主流浏览器都支持，跨平台能力强</li>
<li>默认P2P，但是需要TURN服务器作为fallback</li>
<li>自适应码率<ul>
<li><a href="http://www.newrtc.com/2017/10/15/webrtc-openh264-1/" target="_blank" rel="external">webrtc 视频编码之 h264 自动调节分辨率 — newrtc</a></li>
<li><a href="https://stackoverflow.com/questions/37128928/does-webrtc-support-adaptive-bitrate-streaming-for-video" target="_blank" rel="external">webm - Does WebRTC support Adaptive Bitrate Streaming for video? - Stack Overflow</a></li>
</ul>
</li>
</ul>
<p>相关资料：</p>
<ul>
<li><a href="http://io13webrtc.appspot.com" target="_blank" rel="external">2013 Google I/O 大会上WebRTC的幻灯片</a></li>
<li><a href="https://www.html5rocks.com/en/tutorials/webrtc/basics" target="_blank" rel="external">Getting Started with WebRTC - Sam Dutton</a></li>
<li><a href="https://www.html5rocks.com/en/tutorials/webrtc/infrastructure" target="_blank" rel="external">WebRTC in the real world: STUN, TURN and signaling - Sam Dutton</a></li>
<li><a href="https://tools.ietf.org/wg/rtcweb/" target="_blank" rel="external">IETF Real-Time Communication in WEB-browsers (rtcweb) Working Group</a></li>
<li><a href="https://tools.ietf.org/html/rfc7742" target="_blank" rel="external">RFC7742 - WebRTC Video Processing and Codec Requirements</a></li>
</ul>
<h2 id="1-4-HLS"><a href="#1-4-HLS" class="headerlink" title="1.4 HLS"></a>1.4 HLS</h2><p><a href="https://zh.wikipedia.org/wiki/HTTP_Live_Streaming" target="_blank" rel="external">HTTP Live Streaming - 维基百科，自由的百科全书</a></p>
<blockquote>
<p><strong>HTTP Live Streaming</strong>（缩写是HLS）是一个由苹果公司提出的基于HTTP的流媒体网络传输协议。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的extended M3U (m3u8) playlist文件，用于寻找可用的媒体流。</p>
<p>HLS只请求基本的HTTP报文，与实时传输协议（RTP）不同，HLS可以穿过任何允许HTTP数据通过的防火墙或者代理服务器。它也很容易使用内容分发网络（CDN）来传输媒体流。</p>
<p>2017年8月，<a href="https://tools.ietf.org/html/rfc8216" target="_blank" rel="external">RFC 8216</a>发布，描述了HLS协议第7版的定义</p>
</blockquote>
<p><a href="https://tools.ietf.org/html/rfc8216" target="_blank" rel="external">RFC 8216</a></p>
<h1 id="2-开源方案"><a href="#2-开源方案" class="headerlink" title="2 开源方案"></a>2 开源方案</h1><h2 id="2-0-开源方案选型要考虑的因素："><a href="#2-0-开源方案选型要考虑的因素：" class="headerlink" title="2.0 开源方案选型要考虑的因素："></a>2.0 开源方案选型要考虑的因素：</h2><p><a href="https://bloggeek.me/choosing-webrtc-open-source-media-server/" target="_blank" rel="external"><br>10 Tips for Choosing the Right WebRTC Open Source Media Server Framework</a></p>
<ol>
<li>你是否深刻理解其代码？</li>
<li>代码版本是否足够新？</li>
<li>有谁在使用它？</li>
<li>它的文档是否齐全？</li>
<li>它可以debug吗？</li>
<li>它可以伸缩吗？</li>
<li>它使用哪种语言？<ul>
<li>对于媒体服务器而言，这种语言的性能是否足够？</li>
<li>团队是否足够了解这门语言？</li>
</ul>
</li>
<li>是否适应你现有的Signaling范式？<ul>
<li>你在看的Media Server是否容易与你决定使用的STUN/TURN服务器集成</li>
</ul>
</li>
<li>许可证是否适合你？</li>
<li>谁在提供支持？<ul>
<li>很多成功的、被良好维护的开源项目背后都有一个商业模式，尤其是中小型的项目，这意味着有一个团队以此为谋生手段。</li>
<li>具备可选的付费支持意味着：<ul>
<li>有人愿意全职来改善这东西，而不是作为爱好来维护。 </li>
<li>如果你需要紧急帮助，只要花钱就能得到。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="2-1-Red5"><a href="#2-1-Red5" class="headerlink" title="2.1 Red5"></a>2.1 Red5</h2><p>官网 <a href="http://red5.org/" target="_blank" rel="external">http://red5.org/</a><br>Github <a href="https://github.com/Red5" target="_blank" rel="external">https://github.com/Red5</a></p>
<p>非官方资料：</p>
<ul>
<li><a href="https://github.com/rajdeeprath/red5-development-series" target="_blank" rel="external">red5-development-series</a></li>
</ul>
<p>特性：</p>
<ul>
<li>Server<ul>
<li>自动伸缩集群</li>
<li>Adaptive Stream Rebuffering</li>
<li>支持多协议：<ul>
<li>WebRTC</li>
<li>RTMP</li>
<li>RTSP</li>
<li>HLS</li>
<li>FLV</li>
<li>MP4</li>
</ul>
</li>
<li>实时流录制</li>
<li>离线部署</li>
</ul>
</li>
<li>Browser<ul>
<li>定制化HTML5播放器，支持旋转</li>
<li>实时HLS流</li>
<li>支持Flash作为后备方案</li>
</ul>
</li>
<li>移动端SDK（iOS, Android）<ul>
<li>自适应比特率发布</li>
<li>硬件编码和解码</li>
<li>定制视频源</li>
<li>直播摄像头切换</li>
<li>双路视频聊天</li>
<li>多方视频会议</li>
<li>Adaptive Stream Rebuffering</li>
<li>低延迟播放器</li>
<li>高级通知API</li>
<li>消息与RPC</li>
<li>HD h.264, AAC编码高达4k</li>
</ul>
</li>
</ul>
<p>粗略的特性收费情况调查结果：</p>
<table>
<thead>
<tr>
<th style="text-align:center">-</th>
<th style="text-align:center">开源版本</th>
<th style="text-align:center">付费版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">自动伸缩集群</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">\$279/MO</td>
</tr>
<tr>
<td style="text-align:center">多协议支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center">转码</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">\$109/MO</td>
</tr>
<tr>
<td style="text-align:center">离线部署</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">\$999+/MO</td>
</tr>
</tbody>
</table>
<p>来自<a href="https://github.com/rajdeeprath/red5-development-series/wiki/Red5-open-source-vs-Red5pro" target="_blank" rel="external">Red5 open source vs Red5pro · rajdeeprath/red5-development-series Wiki</a> 的数据</p>
<table>
<thead>
<tr>
<th style="text-align:center">FEATURES</th>
<th style="text-align:center">RED5 OS</th>
<th style="text-align:center">RED5 PRO</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">实时流</td>
<td style="text-align:center">&#10004;</td>
<td style="text-align:center">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">视频录制</td>
<td style="text-align:center">&#10004;</td>
<td style="text-align:center">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">WebSockets</td>
<td style="text-align:center">&#10004;</td>
<td style="text-align:center">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">移动端回放(HLS)</td>
<td style="text-align:center">Community</td>
<td style="text-align:center">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">Adobe Flash 支持</td>
<td style="text-align:center">&#10004;</td>
<td style="text-align:center">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">WebRTC</td>
<td style="text-align:center">&#10006;</td>
<td style="text-align:center">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">第二屏</td>
<td style="text-align:center">&#10006;</td>
<td style="text-align:center">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">自动伸缩</td>
<td style="text-align:center">&#10006;</td>
<td style="text-align:center">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">集群</td>
<td style="text-align:center">&#10006;</td>
<td style="text-align:center">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">移动端SDK</td>
<td style="text-align:center">&#10006;</td>
<td style="text-align:center">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">扩展文档</td>
<td style="text-align:center">&#10006;</td>
<td style="text-align:center">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">客户支持</td>
<td style="text-align:center">Community</td>
<td style="text-align:center">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">管理API (RESTful)</td>
<td style="text-align:center">&#10006;</td>
<td style="text-align:center">&#10004;</td>
</tr>
</tbody>
</table>
<p>缺点：</p>
<ul>
<li>开源版本很难用，官方几乎没有文档，即使有，也是几年前的了，也没有教程。</li>
</ul>
<p>考察点总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">考察点</th>
<th style="text-align:left">OS</th>
<th style="text-align:left">PRO</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">语言</td>
<td style="text-align:left">Java</td>
<td style="text-align:left">Java</td>
</tr>
<tr>
<td style="text-align:center">最新发布日期</td>
<td style="text-align:left">2017-01-12</td>
<td style="text-align:left">?</td>
</tr>
<tr>
<td style="text-align:center">谁在用</td>
<td style="text-align:left">?</td>
<td style="text-align:left">Intel, LimeLight,…,etc（最经典的方案）</td>
</tr>
<tr>
<td style="text-align:center">文档</td>
<td style="text-align:left">&#10006;</td>
<td style="text-align:left">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">伸缩</td>
<td style="text-align:left">&#10006;</td>
<td style="text-align:left">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">debug</td>
<td style="text-align:left">?</td>
<td style="text-align:left">?</td>
</tr>
<tr>
<td style="text-align:center">许可证</td>
<td style="text-align:left">Apache License v2</td>
<td style="text-align:left">付费</td>
</tr>
<tr>
<td style="text-align:center">网络协议</td>
<td style="text-align:left">HLS, WebSockets, RTSP, RTMP, RTMPT, RTMPS, RTMPE</td>
<td style="text-align:left">HLS, WebSockets, RTSP, RTMP, RTMPT, RTMPS, RTMPE, WebRTC</td>
</tr>
<tr>
<td style="text-align:center">自适应码率</td>
<td style="text-align:left">?</td>
<td style="text-align:left">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">流控</td>
<td style="text-align:left">?</td>
<td style="text-align:left">?</td>
</tr>
<tr>
<td style="text-align:center">录制</td>
<td style="text-align:left">?</td>
<td style="text-align:left">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">回放</td>
<td style="text-align:left">?</td>
<td style="text-align:left">&#10004;</td>
</tr>
</tbody>
</table>
<h2 id="2-2-kurento"><a href="#2-2-kurento" class="headerlink" title="2.2 kurento"></a>2.2 kurento</h2><p>主页：<a href="http://www.kurento.org/" target="_blank" rel="external">http://www.kurento.org/</a><br>github：<a href="https://github.com/kurento" target="_blank" rel="external">https://github.com/kurento</a></p>
<p>服务端采用C++实现：<a href="https://github.com/Kurento/kurento-media-server" target="_blank" rel="external">https://github.com/Kurento/kurento-media-server</a></p>
<p>特性：</p>
<ul>
<li>支持HTTP、RTP和WebRTC</li>
<li>集成OpenCV，支持分析图像抽取信息</li>
<li>转码（这个是刚需了）</li>
<li>广播</li>
<li>提供Kurento API，可以在此基础上构建服务器的高层逻辑，并提供了Java和NodeJS的实现，基于此可以实现权限校验等业务逻辑</li>
<li>支持NAT穿越</li>
</ul>
<p>文档地址：<a href="http://readthedocs.org/projects/doc-kurento/downloads/pdf/stable/" target="_blank" rel="external">http://readthedocs.org/projects/doc-kurento/downloads/pdf/stable/</a></p>
<p>考察点总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">考察点</th>
<th style="text-align:left">情况</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">语言</td>
<td style="text-align:left">C++</td>
</tr>
<tr>
<td style="text-align:center">最新发布日期</td>
<td style="text-align:left">2018-03-21</td>
</tr>
<tr>
<td style="text-align:center">谁在用</td>
<td style="text-align:left">没有业界权威在用，Github 800+Star</td>
</tr>
<tr>
<td style="text-align:center">文档</td>
<td style="text-align:left">比较全</td>
</tr>
<tr>
<td style="text-align:center">伸缩</td>
<td style="text-align:left">&#10006;</td>
</tr>
<tr>
<td style="text-align:center">debug</td>
<td style="text-align:left">？</td>
</tr>
<tr>
<td style="text-align:center">许可证</td>
<td style="text-align:left">LGPL v2.1</td>
</tr>
<tr>
<td style="text-align:center">网络协议</td>
<td style="text-align:left">HTTP, RTP, WebRTC</td>
</tr>
<tr>
<td style="text-align:center">自适应码率</td>
<td style="text-align:left">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">流控</td>
<td style="text-align:left">?</td>
</tr>
<tr>
<td style="text-align:center">录制</td>
<td style="text-align:left">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">回放</td>
<td style="text-align:left">&#10004;</td>
</tr>
</tbody>
</table>
<h2 id="2-3-RestComm"><a href="#2-3-RestComm" class="headerlink" title="2.3 RestComm"></a>2.3 RestComm</h2><p>官网 <a href="https://www.restcomm.com/" target="_blank" rel="external">https://www.restcomm.com/</a><br>GitHub <a href="https://github.com/RestComm" target="_blank" rel="external">https://github.com/RestComm</a><br>文档 <a href="https://www.restcomm.com/docs/" target="_blank" rel="external">https://www.restcomm.com/docs/</a></p>
<p>免费版本功能受限<br><img src="http://otlnkjq1m.bkt.clouddn.com/WechatIMG1467.jpeg" alt=""></p>
<p>考察点总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">考察点</th>
<th style="text-align:left">情况</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">语言</td>
<td style="text-align:left">Java</td>
</tr>
<tr>
<td style="text-align:center">最新发布日期</td>
<td style="text-align:left">2018-04-20</td>
</tr>
<tr>
<td style="text-align:center">谁在用</td>
<td style="text-align:left">?</td>
</tr>
<tr>
<td style="text-align:center">文档</td>
<td style="text-align:left">齐全</td>
</tr>
<tr>
<td style="text-align:center">伸缩</td>
<td style="text-align:left">付费</td>
</tr>
<tr>
<td style="text-align:center">debug</td>
<td style="text-align:left">？</td>
</tr>
<tr>
<td style="text-align:center">许可证</td>
<td style="text-align:left">AGPL-3.0</td>
</tr>
<tr>
<td style="text-align:center">网络协议</td>
<td style="text-align:left">WebRTC</td>
</tr>
<tr>
<td style="text-align:center">自适应码率</td>
<td style="text-align:left">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">流控</td>
<td style="text-align:left">?</td>
</tr>
<tr>
<td style="text-align:center">录制</td>
<td style="text-align:left">?</td>
</tr>
<tr>
<td style="text-align:center">回放</td>
<td style="text-align:left">?</td>
</tr>
</tbody>
</table>
<h2 id="2-4-Ant-Media-Server"><a href="#2-4-Ant-Media-Server" class="headerlink" title="2.4 Ant Media Server"></a>2.4 Ant Media Server</h2><p>官网 <a href="https://antmedia.io/" target="_blank" rel="external">https://antmedia.io/</a><br>文档 <a href="https://antmedia.io/documentation" target="_blank" rel="external">https://antmedia.io/documentation</a><br>Github <a href="https://github.com/ant-media/ant-media-server" target="_blank" rel="external">https://github.com/ant-media/ant-media-server</a></p>
<p><a class="github-button" href="https://github.com/ant-media/Ant-Media-Server" data-size="large" data-show-count="true" aria-label="Star ant-media/Ant-Media-Server on GitHub" target="_blank" rel="external">Star</a>  <a class="github-button" href="https://github.com/ant-media/Ant-Media-Server/fork" data-size="large" data-show-count="true" aria-label="Fork ant-media/Ant-Media-Server on GitHub" target="_blank" rel="external">Fork</a></p>
<p>服务端采用Java实现，是Red5-server的分叉版本</p>
<p>特性：</p>
<ul>
<li>实时流发布</li>
<li>支持RTMP、RTSP、WebRTC、HLS</li>
<li>WebRTC转RTMP适配器</li>
<li>IP摄像头支持</li>
<li>录制实时流（FLV、MP4和HLS容器）</li>
<li>同步重制流到社交媒体（企业版里Facebook和Youtube）</li>
<li>低延迟1:N WebRTC实时流（企业版）</li>
<li>实时流自适应比特率转换（FLV、MP4、HLS）（企业版）</li>
</ul>
<p>考察点总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">考察点</th>
<th style="text-align:left">情况</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">语言</td>
<td style="text-align:left">Java</td>
</tr>
<tr>
<td style="text-align:center">最新发布日期</td>
<td style="text-align:left">2018-05-01</td>
</tr>
<tr>
<td style="text-align:center">谁在用</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">文档</td>
<td style="text-align:left">齐全</td>
</tr>
<tr>
<td style="text-align:center">伸缩</td>
<td style="text-align:left">收费</td>
</tr>
<tr>
<td style="text-align:center">debug</td>
<td style="text-align:left">?</td>
</tr>
<tr>
<td style="text-align:center">许可证</td>
<td style="text-align:left">Apache License v2</td>
</tr>
<tr>
<td style="text-align:center">网络协议</td>
<td style="text-align:left">RTMP、RTSP、WebRTC、HLS</td>
</tr>
<tr>
<td style="text-align:center">自适应码率</td>
<td style="text-align:left">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">流控</td>
<td style="text-align:left">?</td>
</tr>
<tr>
<td style="text-align:center">录制</td>
<td style="text-align:left">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">回放</td>
<td style="text-align:left">&#10004;</td>
</tr>
</tbody>
</table>
<h2 id="2-5-BigBlueButton"><a href="#2-5-BigBlueButton" class="headerlink" title="2.5 BigBlueButton"></a>2.5 BigBlueButton</h2><p>官网 <a href="https://bigbluebutton.org/" target="_blank" rel="external">https://bigbluebutton.org/</a><br>文档 <a href="http://docs.bigbluebutton.org/" target="_blank" rel="external">http://docs.bigbluebutton.org/</a><br>github <a href="https://github.com/bigbluebutton/bigbluebutton" target="_blank" rel="external">https://github.com/bigbluebutton/bigbluebutton</a><br><a class="github-button" href="https://github.com/bigbluebutton/bigbluebutton" data-size="large" data-show-count="true" aria-label="Star bigbluebutton/bigbluebutton on GitHub" target="_blank" rel="external">Star</a> <a class="github-button" href="https://github.com/bigbluebutton/bigbluebutton/fork" data-size="large" data-show-count="true" aria-label="Fork bigbluebutton/bigbluebutton on GitHub" target="_blank" rel="external">Fork</a></p>
<p>采用Java开发，主要针对场景是授课</p>
<p>特性：</p>
<ul>
<li>实时添加字幕</li>
<li>屏幕共享</li>
<li>分组讨论室</li>
<li>录制与回放</li>
</ul>
<p>考察点总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">考察点</th>
<th style="text-align:left">情况</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">语言</td>
<td style="text-align:left">Java</td>
</tr>
<tr>
<td style="text-align:center">最新发布日期</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">谁在用</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">文档</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">伸缩</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">debug</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">许可证</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">网络协议</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">自适应码率</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">流控</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">录制</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center">回放</td>
</tr>
</tbody>
</table>
<h2 id="2-6-NextRTC"><a href="#2-6-NextRTC" class="headerlink" title="2.6 NextRTC"></a>2.6 NextRTC</h2><p>主页 <a href="https://nextrtc.org/" target="_blank" rel="external">https://nextrtc.org/</a><br>Github <a href="https://github.com/mslosarz/nextrtc-signaling-server" target="_blank" rel="external">https://github.com/mslosarz/nextrtc-signaling-server</a></p>
<p>考察点总结：</p>
<table>
<thead>
<tr>
<th style="text-align:center">考察点</th>
<th style="text-align:left">情况</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">语言</td>
<td style="text-align:left">Java</td>
</tr>
<tr>
<td style="text-align:center">最新发布日期</td>
<td style="text-align:left">2018-04-05</td>
</tr>
<tr>
<td style="text-align:center">谁在用</td>
<td style="text-align:left">（估计没人）</td>
</tr>
<tr>
<td style="text-align:center">文档</td>
<td style="text-align:left">简单</td>
</tr>
<tr>
<td style="text-align:center">伸缩</td>
<td style="text-align:left">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">debug</td>
<td style="text-align:left">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">许可证</td>
<td style="text-align:left">MIT</td>
</tr>
<tr>
<td style="text-align:center">网络协议</td>
<td style="text-align:left">WebRTC</td>
</tr>
<tr>
<td style="text-align:center">自适应码率</td>
<td style="text-align:left">&#10004;</td>
</tr>
<tr>
<td style="text-align:center">流控</td>
<td style="text-align:left">&#10006;</td>
</tr>
<tr>
<td style="text-align:center">录制</td>
<td style="text-align:left">&#10006;</td>
</tr>
<tr>
<td style="text-align:center">回放</td>
<td style="text-align:left">&#10006;</td>
</tr>
</tbody>
</table>
<h2 id="2-7-OpenBroadcaster"><a href="#2-7-OpenBroadcaster" class="headerlink" title="2.7 OpenBroadcaster"></a>2.7 OpenBroadcaster</h2><p><a href="https://obsproject.com/" target="_blank" rel="external">https://obsproject.com/</a><br><a href="https://github.com/obsproject" target="_blank" rel="external">https://github.com/obsproject</a></p>
<p>TBD</p>
<hr>
<p><a href="https://en.wikipedia.org/wiki/Comparison_of_streaming_media_systems" target="_blank" rel="external">Comparison of streaming media systems - Wikipedia</a></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>创建者</th>
<th>最新稳定版(发布日期)</th>
<th>最新发布日期</th>
<th>价钱 (USD)</th>
<th>许可证</th>
<th>支持媒体</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cameleon</td>
<td>Yatko</td>
<td>1.0.7 (2016-11-11)</td>
<td>2016-11-11</td>
<td>Free</td>
<td>专有</td>
<td>Audio/Video</td>
</tr>
<tr>
<td>Helix Universal Server</td>
<td>RealNetworks</td>
<td>15.2.1 (2014-09-16)</td>
<td>2014-09-16</td>
<td>Free for 12 months (Basic) and \$1,000-\$10,000</td>
<td>专有</td>
<td>Audio/Video</td>
</tr>
<tr>
<td>IIS Media Services</td>
<td>Microsoft</td>
<td>4.1 (2011-11-09)</td>
<td>2011-11-09</td>
<td>Free</td>
<td>专有</td>
<td>Audio/Video/Data</td>
</tr>
<tr>
<td>Nimble Streamer</td>
<td>WMSPanel</td>
<td>2.15.1-3 (2016-03-21)</td>
<td>2016-03-21</td>
<td>Free</td>
<td>专有</td>
<td>Audio/Video</td>
</tr>
<tr>
<td>Open Broadcaster Software</td>
<td>OBS Project</td>
<td>0.657 (2015-11-24)</td>
<td>2015-11-24</td>
<td>Free</td>
<td>GPL v2</td>
<td>Audio/Video</td>
</tr>
<tr>
<td>OpenBroadcaster</td>
<td>OpenBroadcaster</td>
<td>5.0.0 (2018-01-27)</td>
<td>2018-01-27</td>
<td>Free</td>
<td>AGPLv3</td>
<td>Audio/Video</td>
</tr>
<tr>
<td>Plex (software)</td>
<td>Plex Media Server</td>
<td>1.0.3.2461-35f0caa (2016-07-28)</td>
<td>2016-07-28</td>
<td>Free</td>
<td>GPL</td>
<td>Audio/Video</td>
</tr>
<tr>
<td>Red5 (open source)</td>
<td>Infrared5/community</td>
<td>1.0.6 (2015-09-08)</td>
<td>2015-09-08</td>
<td>Free</td>
<td>Apache License v2</td>
<td>Audio/Video/Data</td>
</tr>
<tr>
<td>Unified Streaming Platform</td>
<td>Unified Streaming</td>
<td>1.7.18 (2016-04-11)</td>
<td>2016-04-11</td>
<td>Free Trial license; Perpetual License; Amazon EC2 with embedded license; Microsoft Azure</td>
<td>专有</td>
<td>Audio/Video</td>
</tr>
<tr>
<td>Unreal Media Server</td>
<td>Unreal Streaming Technologies</td>
<td>12.0 (2017-04-03)</td>
<td>2017-04-03</td>
<td>\$995 perpetual license</td>
<td>专有</td>
<td>Audio/Video</td>
</tr>
<tr>
<td>VLC media player</td>
<td>VideoLAN</td>
<td>2.2.4 (2016-06-05)</td>
<td>2016-06-05</td>
<td>Free</td>
<td>GPL v2</td>
<td>Audio/Video</td>
</tr>
<tr>
<td>Wowza Streaming Engine</td>
<td>Wowza Media Systems</td>
<td>4.5.0 build 18676 (2016-06-23)[2]</td>
<td>2016-06-23</td>
<td>Free Developer and Trial licenses; Subscription Licenses at \$65/month; Perpetual Pro License at \$1995; Amazon EC2 with embedded license starting at \$0.15/hour</td>
<td>专有</td>
<td>Audio/Video/Data</td>
</tr>
</tbody>
</table>
<!-- Place this tag in your head or just before your close body tag. -->
<script async defer src="https://buttons.github.io/buttons.js"></script>


<p>-</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文对几种开源的流媒体服务器做对比。&lt;/p&gt;
    
    </summary>
    
    
      <category term="直播" scheme="http://bungder.github.io/tags/%E7%9B%B4%E6%92%AD/"/>
    
      <category term="流媒体" scheme="http://bungder.github.io/tags/%E6%B5%81%E5%AA%92%E4%BD%93/"/>
    
  </entry>
  
  <entry>
    <title>JVM GC相关问题</title>
    <link href="http://bungder.github.io/2018/04/02/jvm-gc-issues/"/>
    <id>http://bungder.github.io/2018/04/02/jvm-gc-issues/</id>
    <published>2018-04-01T20:10:21.000Z</published>
    <updated>2018-04-01T20:35:48.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1. 概念"></a>1. 概念</h1><p><a href="http://blog.csdn.net/u011080472/article/details/51324422" target="_blank" rel="external">http://blog.csdn.net/u011080472/article/details/51324422</a></p>
<h2 id="1-0-并发和并行"><a href="#1-0-并发和并行" class="headerlink" title="1.0 并发和并行"></a>1.0 并发和并行</h2><p>这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，它们可以解释如下。</p>
<ul>
<li><p>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</p>
</li>
<li><p>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。</p>
</li>
</ul>
<h2 id="1-1-Minor-GC-和-Full-GC"><a href="#1-1-Minor-GC-和-Full-GC" class="headerlink" title="1.1 Minor GC 和 Full GC"></a>1.1 Minor GC 和 Full GC</h2><ul>
<li><p>新生代GC（Minor GC / Young GC /  YGC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p>
</li>
<li><p>老年代GC（Major GC / Full GC / FGC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</p>
</li>
</ul>
<a id="more"></a>
<h1 id="2-Java中什么样的对象才能作为gc-root，gc-roots有哪些呢？"><a href="#2-Java中什么样的对象才能作为gc-root，gc-roots有哪些呢？" class="headerlink" title="2 Java中什么样的对象才能作为gc root，gc roots有哪些呢？"></a>2 Java中什么样的对象才能作为gc root，gc roots有哪些呢？</h1><p><span id="gcRoot"></span></p>
<p><a href="http://blog.csdn.net/fenglibing/article/details/8928927" target="_blank" rel="external">http://blog.csdn.net/fenglibing/article/details/8928927</a></p>
<blockquote>
<p>常说的GC(Garbage Collector) roots，特指的是垃圾收集器（Garbage Collector）的对象，GC会收集那些不是GC roots且没有被GC roots引用的对象。</p>
<p>一个对象可以属于多个root，GC root有几下种：</p>
<ul>
<li><strong>Class</strong> - 由系统类加载器(system class loader)加载的对象，这些类是不能够被回收的，他们可以以静态字段的方式保存持有其它对象。我们需要注意的一点就是，通过用户自定义的类加载器加载的类，除非相应的java.lang.Class实例以其它的某种（或多种）方式成为roots，否则它们并不是roots，.</li>
<li><strong>Thread</strong> - 活着的线程</li>
<li><strong>Stack Local</strong> - Java方法的local变量或参数</li>
<li><strong>JNI Local</strong> - JNI方法的local变量或参数</li>
<li><strong>JNI Global</strong> - 全局JNI引用</li>
<li><strong>Monitor Used</strong> - 用于同步的监控对象</li>
<li><strong>Held by JVM</strong> - 用于JVM特殊目的由GC保留的对象，但实际上这个与JVM的实现是有关的。可能已知的一些类型是：系统类加载器、一些JVM知道的重要的异常类、一些用于处理异常的预分配对象以及一些自定义的类加载器等。然而，JVM并没有为这些对象提供其它的信息，因此就只有留给分析分员去确定哪些是属于”JVM持有”的了。</li>
</ul>
</blockquote>
<p><a href="http://help.eclipse.org/luna/index.jsp?topic=%2Forg.eclipse.mat.ui.help%2Fconcepts%2Fgcroots.html&amp;cp=37_2_3" target="_blank" rel="external">Help - Eclipse Platform</a></p>
<blockquote>
<p><strong>Garbage Collection Roots</strong><br>A garbage collection root is an object that is accessible from outside the heap. The following reasons make an object a GC root:</p>
<ul>
<li><strong>System Class</strong><br>Class loaded by bootstrap/system class loader. For example, everything from the rt.jar like java.util.* .</li>
<li><strong>JNI Local</strong><br>Local variable in native code, such as user defined JNI code or JVM internal code.</li>
<li><strong>JNI Global</strong><br>Global variable in native code, such as user defined JNI code or JVM internal code.</li>
<li><strong>Thread Block</strong><br>Object referred to from a currently active thread block.</li>
<li><strong>Thread</strong><br>A started, but not stopped, thread.</li>
<li><strong>Busy Monitor</strong><br>Everything that has called wait() or notify() or that is synchronized. For example, by calling synchronized(Object) or by entering a synchronized method. Static method means class, non-static method means object.</li>
<li><strong>Java Local</strong><br>Local variable. For example, input parameters or locally created objects of methods that are still in the stack of a thread.</li>
<li><strong>Native Stack</strong><br>In or out parameters in native code, such as user defined JNI code or JVM internal code. This is often the case as many methods have native parts and the objects handled as method parameters become GC roots. For example, parameters used for file/network I/O methods or reflection.</li>
<li><strong>Finalizable</strong><br>An object which is in a queue awaiting its finalizer to be run.</li>
<li><strong>Unfinalized</strong><br>An object which has a finalize method, but has not been finalized and is not yet on the finalizer queue.</li>
<li><strong>Unreachable</strong><br>An object which is unreachable from any other root, but has been marked as a root by MAT to retain objects which otherwise would not be included in the analysis.</li>
<li><strong>Java Stack Frame</strong><br>A Java stack frame, holding local variables. Only generated when the dump is parsed with the preference set to treat Java stack frames as objects.</li>
<li><strong>Unknown</strong><br>An object of unknown root type. Some dumps, such as IBM Portable Heap Dump files, do not have root information. For these dumps the MAT parser marks objects which are have no inbound references or are unreachable from any other root as roots of this type. This ensures that MAT retains all the objects in the dump.</li>
</ul>
</blockquote>
<p><a href="https://www.zhihu.com/question/53613423/answer/135743258" target="_blank" rel="external">java的gc为什么要分代？ - 知乎</a></p>
<blockquote>
<p>作者：RednaxelaFX<br>链接：<a href="https://www.zhihu.com/question/53613423/answer/135743258" target="_blank" rel="external">https://www.zhihu.com/question/53613423/answer/135743258</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p><strong>所谓“GC roots”，或者说tracing GC的“根集合”，就是一组必须活跃的引用</strong>。<br>例如说，这些引用可能包括：</p>
<ul>
<li>所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。</li>
<li>VM的一些静态数据结构里指向GC堆里的对象的引用，例如说HotSpot VM里的Universe里有很多这样的引用。</li>
<li>JNI handles，包括global handles和local handles（看情况）</li>
<li>所有当前被加载的Java类（看情况）</li>
<li>Java类的引用类型静态变量（看情况）</li>
<li>Java类的运行时常量池里的引用类型常量（String或Class类型）（看情况）</li>
<li>String常量池（StringTable）里的引用</li>
</ul>
<p>注意，是一组必须<strong>活跃的引用，不是对象</strong>。<br>Tracing GC的根本思路就是：给定一个集合的引用作为根出发，通过引用关系遍历对象图，能被遍历到的（可到达的）对象就被判定为存活，其余对象（也就是没有被遍历到的）就自然被判定为死亡。注意再注意：tracing GC的本质是通过找出所有活对象来把其余空间认定为“无用”，而不是找出所有死掉的对象并回收它们占用的空间。<br>GC roots这组引用是tracing GC的起点。要实现语义正确的tracing GC，就必须要能完整枚举出所有的GC roots，否则就可能会漏扫描应该存活的对象，导致GC错误回收了这些被漏扫的活对象。<br>这就像任何递归定义的关系一样，如果只定义了递推项而不定义初始项的话，关系就无法成立——无从开始；而如果初始项定义漏了内容的话，递推出去也会漏内容。</p>
<p><strong>那么分代式GC对GC roots的定义有什么影响呢？</strong><br>答案是：分代式GC是一种部分收集（partial collection）的做法。在执行部分收集时，从GC堆的非收集部分指向收集部分的引用，也必须作为GC roots的一部分。具体到分两代的分代式GC来说，如果第0代叫做young gen，第1代叫做old gen，那么如果有minor GC / young GC只收集young gen里的垃圾，则young gen属于“收集部分”，而old gen属于“非收集部分”，那么从old gen指向young gen的引用就必须作为minor GC / young GC的GC roots的一部分。</p>
<p>继续具体到HotSpot VM里的分两代式GC来说，除了old gen到young gen的引用之外，有些带有弱引用语义的结构，例如说记录所有当前被加载的类的SystemDictionary、记录字符串常量引用的StringTable等，在young GC时必须要作为strong GC roots，而在收集整堆的full GC时则不会被看作strong GC roots。</p>
<p>换句话说，young GC比full GC的GC roots还要更大一些。</p>
<p><strong>那么分代有什么好处？</strong><span id="goodsForGeneration"><br>对传统的、基本的GC实现来说，由于它们在GC的整个工作过程中都要“stop-the-world”，如果能想办法缩短GC一次工作的时间长度就是件重要的事情。如果说收集整个GC堆耗时太长，那不如只收集其中的一部分？<br>于是就有好几种不同的划分（partition）GC堆的方式来实现部分收集，而分代式GC就是这其中的一个思路。<br>这个思路所基于的基本假设大家都很熟悉了：<strong>weak generational hypothesis</strong>——大部分对象的生命期很短（die young），而没有die young的对象则很可能会存活很长时间（live long）。<br>这是对过往的很多应用行为分析之后得出的一个假设。基于这个假设，如果让新创建的对象都在young gen里创建，然后频繁收集young gen，则大部分垃圾都能在young GC中被收集掉。<strong>由于young gen的大小配置通常只占整个GC堆的较小部分，而且较高的对象死亡率（或者说较低的对象存活率）让它非常适合使用copying算法来收集，这样就不但能降低单次GC的时间长度，还可以提高GC的工作效率</strong>。（参见<a href="#threeComparing">三种基本算法的对比</a>）</span></p>
<p>放几个传送门：</p>
<ul>
<li><a href="https://www.zhihu.com/question/33210180/answer/56348818" target="_blank" rel="external">JVM GC遍历一次新生代所有对象是否可达需要多久？- RednaxelaFX 的回答 - 知乎</a></li>
<li><a href="https://www.zhihu.com/question/42181722/answer/93871206" target="_blank" rel="external">有关 Copying GC 的疑问？- RednaxelaFX 的回答 - 知乎</a></li>
</ul>
<p>但是！有些比较先进的GC算法是增量式（incremental）的，或者部分并发（mostly-concurrent），或者干脆完全并发（fully-concurrent）的。<br>例如鄙司Azul Systems的<strong>Zing JVM里的C4 GC</strong>，就是一个完全并发的GC算法。它不存在“GC整个工作流程中都要把应用stop-the-world”的问题——从算法的设计上就不存在。<br>然而C4却也是一个分两代的分代式GC。为什么呢？<br>C4 GC的前身是Azul System的上一代JVM里的“Pauseless GC”算法，而Pauseless是一个完全并发但是不分代的GC。<br>Oracle的HotSpot VM里的G1 GC，在最初设计的时候是不分代的部分并发+增量式GC，而后来在实际投入生产的时候使用的却也是分两代的分代式GC设计。现在Red Hat正在开发中的Shenandoah GC是一个并发GC，它目前的设计还是不分代的，但根据过往经验看，它后期渐渐发展为分代式的可能性极其高——如果这个项目能活足够久的话。<br>对于这些GC来说，解决stop-the-world时间太长的问题并不是选择分代的主要原因。<br>就Azul的Pauless到C4的发展历程来看，<strong>选择实现分代的最大好处是，GC能够应付的应用内存分配速率（allocation rate）可以得到巨大的提升</strong>。<br>并发GC根本上要跟应用玩追赶游戏：应用一边在分配，GC一边在收集，如果GC收集的速度能跟得上应用分配的速度，那就一切都很完美；一旦GC开始跟不上了，垃圾就会渐渐堆积起来，最终到可用空间彻底耗尽的时候，应用的分配请求就只能暂时等一等了，等GC追赶上来。<br>所以，对于一个并发GC来说，能够尽快回收出越多空间，就能够应付越高的应用内存分配速率，从而更好地保持GC以完美的并发模式工作。<br>虽然并不是所有应用中的对象生命周期都完美吻合weak generational hypothesis的假设，但<strong>这个假设在很大范围内还是适用的</strong>，因而也可以帮助并发GC改善性能。</p>
</blockquote>
<h1 id="3-GC算法"><a href="#3-GC算法" class="headerlink" title="3 GC算法"></a>3 GC算法</h1><h2 id="3-1-判断是否回收"><a href="#3-1-判断是否回收" class="headerlink" title="3.1 判断是否回收"></a>3.1 判断是否回收</h2><h3 id="3-1-1-标记算法"><a href="#3-1-1-标记算法" class="headerlink" title="3.1.1 标记算法"></a>3.1.1 标记算法</h3><h4 id="3-1-1-1-引用计数（Reference-Counting）算法"><a href="#3-1-1-1-引用计数（Reference-Counting）算法" class="headerlink" title="3.1.1.1 引用计数（Reference Counting）算法"></a>3.1.1.1 引用计数（Reference Counting）算法</h4><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<ul>
<li>优点<ul>
<li>实现简单，判断效率高</li>
</ul>
</li>
<li>缺点<ul>
<li>不能解决<strong>循环引用</strong>问题<br>例如a引用了b，同时b又引用了a。</li>
</ul>
</li>
</ul>
<p>主流的Java虚拟机里面没有选用引用计数算法来管理内存，其中最主要的原因是它很难解决对象之间相互<strong>循环引用</strong>的问题。</p>
<h4 id="3-1-1-2-可达性分析（Reachability-Analysis）算法"><a href="#3-1-1-2-可达性分析（Reachability-Analysis）算法" class="headerlink" title="3.1.1.2 可达性分析（Reachability Analysis）算法"></a>3.1.1.2 可达性分析（Reachability Analysis）算法</h4><p>周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）:</p>
<blockquote>
<p>这个算法的基本思路就是通过一系列的称为”<strong>GC Roots</strong>“的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p>
</blockquote>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/GC-01.png" alt=""></p>
<blockquote>
<p>在Java语言中，可作为<a href="#gcRoot">GCRoots</a>的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>
</ul>
</blockquote>
<h3 id="3-1-2-引用"><a href="#3-1-2-引用" class="headerlink" title="3.1.2 引用"></a>3.1.2 引用</h3><p>在JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为了4种：</p>
<ul>
<li>强引用（Strong Reference）<ul>
<li>类似 <code>Object obj = new Object()</code>的引用</li>
<li>垃圾回收器永远不会回收被引用的对象</li>
</ul>
</li>
<li>软引用（Soft Reference）<ul>
<li>描述一些还有用但是非必需的对象</li>
<li>在系统将要发生内存溢出异常之前，会将这些被引用对象列入回收范围内</li>
<li>JDK 1.2之后提供了<strong>SoftReference</strong>类来实现</li>
</ul>
</li>
<li>弱引用（Weak Reference）<ul>
<li>也用于描述非必需对象，但强度比软引用更弱</li>
<li>被引用对象只能生存到下一次GC发生之前</li>
<li>JDK 1.2之后提供了<strong>WeakReference</strong>类来实现</li>
</ul>
</li>
<li>虚引用（Phantom Reference）<ul>
<li>也称为幽灵引用或者幻影引用，引用关系最弱</li>
<li>完全不影响生存时间</li>
<li>为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。</li>
<li>在JDK 1.2之后，提供了<strong>PhantomReference</strong>类来实现虚引用。</li>
</ul>
</li>
</ul>
<p>这4种引用强度依次逐渐减弱。</p>
<h3 id="3-1-3-二次标记"><a href="#3-1-3-二次标记" class="headerlink" title="3.1.3 二次标记"></a>3.1.3 二次标记</h3><p>周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）:</p>
<blockquote>
<p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</p>
<p>如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做<strong>F-Queue</strong>的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环（更极端的情况），将很可能会导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移除出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。</p>
</blockquote>
<h3 id="3-1-4-回收方法区"><a href="#3-1-4-回收方法区" class="headerlink" title="3.1.4 回收方法区"></a>3.1.4 回收方法区</h3><p>周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）:</p>
<blockquote>
<p>很多人认为方法区（或者HotSpot虚拟机中的永久代）是没有垃圾收集的，Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾收集，而且在方法区中进行垃圾收集的“性价比”一般比较低：在堆中，尤其是在新生代中，常规应用进行一次垃圾收集一般可以回收70%～95%的空间，而永久代的垃圾收集效率远低于此。</p>
<p>永久代的垃圾收集主要回收两部分内容：废弃常量和无用的类。回收废弃常量与回收Java堆中的对象非常类似。以常量池中字面量的回收为例，假如一个字符串”abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做”abc”的，换句话说，就是没有任何String对象引用常量池中的”abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个”abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p>
<p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是“无用的类”：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样，不使用了就必然会回收。是否对类进行回收，HotSpot虚拟机提供了<strong>-Xnoclassgc</strong>参数进行控制，还可以使用<strong>-verbose:class</strong>以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息，其中-verbose:class和-XX:+TraceClassLoading可以在Product版的虚拟机中使用，-XX:+TraceClassUnLoading参数需要FastDebug版的虚拟机支持。</p>
<p>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>
</blockquote>
<h2 id="3-2-一般的算法"><a href="#3-2-一般的算法" class="headerlink" title="3.2 一般的算法"></a>3.2 一般的算法</h2><p><span id="gcAlgorithm"></span></p>
<h3 id="3-2-1-标记-清除（Mark-Sweep）算法"><a href="#3-2-1-标记-清除（Mark-Sweep）算法" class="headerlink" title="3.2.1 标记-清除（Mark-Sweep）算法"></a>3.2.1 标记-清除（Mark-Sweep）算法</h3><p>周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）:</p>
<blockquote>
<p>最基础的收集算法是“标记-清除”（Mark-Sweep）算法，如同它的名字一样，算法分为“<strong>标记</strong>”和“<strong>清除</strong>”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。之所以说它是最基础的收集算法，是因为<strong>后续的收集算法都是基于这种思路并对其不足进行改进而得到的</strong>。它的主要不足有两个：</p>
<ul>
<li><strong>效率问题</strong>，标记和清除两个过程的效率都不高；</li>
<li><strong>空间问题</strong>，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ul>
</blockquote>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/GC-02.png" alt=""></p>
<h3 id="3-2-2-复制（Copying）算法"><a href="#3-2-2-复制（Copying）算法" class="headerlink" title="3.2.2 复制（Copying）算法"></a>3.2.2 复制（Copying）算法</h3><p>周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）:</p>
<blockquote>
<p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。</p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/GC-03.png" alt=""></p>
<p>现在的商业虚拟机都采用这种收集算法来回收新生代，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以并不需要按照1:1的比例来划分内存空间，而是将内存分为<strong>一块较大的Eden空间</strong>和<strong>两块较小的Survivor空间</strong>，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”。当然，98%的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于10%的对象存活，当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。</p>
<p>内存的分配担保就好比我们去银行借款，如果我们信誉很好，在98%的情况下都能按时偿还，于是银行可能会默认我们下一次也能按时按量地偿还贷款，只需要有一个担保人能保证如果我不能还款时，可以从他的账户扣钱，那银行就认为没有风险了。内存的分配担保也一样，如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</p>
</blockquote>
<p><a href="https://www.zhihu.com/question/33210180/answer/56348818" target="_blank" rel="external">JVM GC遍历一次新生代所有对象是否可达需要多久？ - 知乎</a>：<br><strong>Copying GC算法的特征之一就是它的开销只跟活对象的多少（live data set）有关系，而跟它所管理的堆空间的大小没关系。</strong></p>
<h3 id="3-2-3-标记-整理（Mark-Compact）算法"><a href="#3-2-3-标记-整理（Mark-Compact）算法" class="headerlink" title="3.2.3 标记-整理（Mark-Compact）算法"></a>3.2.3 标记-整理（Mark-Compact）算法</h3><p>周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）:</p>
<blockquote>
<p>复制收集算法<strong>在对象存活率较高时</strong>就要进行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p>
<p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是<strong>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</strong>。</p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/GC-04.png" alt=""></p>
</blockquote>
<h3 id="3-2-4-分代收集（Generational-Collection）算法"><a href="#3-2-4-分代收集（Generational-Collection）算法" class="headerlink" title="3.2.4 分代收集（Generational Collection）算法"></a>3.2.4 分代收集（Generational Collection）算法</h3><p>周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）:</p>
<blockquote>
<p>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为<strong>新生代</strong>和<strong>老年代</strong>，这样就可以<strong>根据各个年代的特点采用最适当的收集算法</strong>。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记—清理”或者“标记—整理”算法来进行回收。</p>
</blockquote>
<p>分代收集的好处参见<a href="#goodsForGeneration">此处</a>。</p>
<h3 id="3-2-5-三种基本算法对比"><a href="#3-2-5-三种基本算法对比" class="headerlink" title="3.2.5 三种基本算法对比"></a>3.2.5 三种基本算法对比</h3><p><span id="threeComparing"></span></p>
<table>
<thead>
<tr>
<th>-</th>
<th>mark-sweep</th>
<th>mark-compact</th>
<th>copying</th>
</tr>
</thead>
<tbody>
<tr>
<td>速度</td>
<td>中等</td>
<td>最慢</td>
<td>最快</td>
</tr>
<tr>
<td>空间开销</td>
<td>少（但会堆积碎片）</td>
<td>少（不堆积碎片）</td>
<td>通常需要活对象的2倍大小（不堆积碎片）</td>
</tr>
<tr>
<td>移动对象？</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
</tbody>
</table>
<blockquote>
<p>关于时间开销：<br>mark-sweep：mark阶段与活对象的数量成正比，sweep阶段与整堆大小成正比<br>mark-compact：mark阶段与活对象的数量成正比，compact阶段与活对象的大小成正比<br>copying：与活对象大小成正比 </p>
<p>如果把mark、sweep、compact、copying这几种动作的耗时放在一起看，大致有这样的关系：<br><strong>compaction &gt;= copying &gt; marking &gt; sweeping </strong><br>还有 <strong>marking + sweeping &gt; copying</strong><br>（虽然compactiont与copying都涉及移动对象，但取决于具体算法，compact可能要先计算一次对象的目标地址，然后修正指针，然后再移动对象；copying则可以把这几件事情合为一体来做，所以可以快一些。<br>另外还需要留意GC带来的开销不能只看collector的耗时，还得看allocator一侧的。如果能保证内存没碎片，分配就可以用pointer bumping方式，只有挪一个指针就完成了分配，非常快；而如果内存有碎片就得用freelist之类的方式管理，分配速度通常会慢一些。） </p>
<p><strong>在分代式假设中，年轻代中的对象在minor GC时的存活率应该很低，这样用copying算法就是最合算的，因为其时间开销与活对象的大小成正比</strong>，如果没多少活对象，它就非常快；而且young gen本身应该比较小，就算需要2倍空间也只会浪费不太多的空间。<br>而年老代被GC时对象存活率可能会很高，而且假定可用剩余空间不太多，这样copying算法就不太合适，于是更可能选用另两种算法，特别是不用移动对象的mark-sweep算法。 </p>
<p>不过HotSpot VM中除了CMS之外的其它收集器都是会移动对象的，也就是要么是copying、要么是mark-compact的变种。 </p>
</blockquote>
<h2 id="3-3-HotSpot的算法实现"><a href="#3-3-HotSpot的算法实现" class="headerlink" title="3.3 HotSpot的算法实现"></a>3.3 HotSpot的算法实现</h2><h3 id="3-3-1-枚举根节点"><a href="#3-3-1-枚举根节点" class="headerlink" title="3.3.1 枚举根节点"></a>3.3.1 枚举根节点</h3><blockquote>
<p>从可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。</p>
<p>另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保<strong>一致性</strong>的快照中进行——这里“一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿所有Java执行线程（Sun将这件事情称为”<strong>Stop The World</strong>“）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p>
<p>由于目前的主流Java虚拟机使用的都是<strong>准确式GC</strong>（这个概念在第1章介绍Exact VM对Classic VM的改进时讲过），所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为<strong>OopMap</strong>的数据结构来达到这个目的的：</p>
<ul>
<li><strong>在类加载完成的时候</strong>，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，</li>
<li><strong>在JIT编译过程中</strong>，也会在特定的位置记录下栈和寄存器中哪些位置是引用。</li>
</ul>
<p>这样，GC在扫描时就可以直接得知这些信息了。</p>
</blockquote>
<h3 id="3-3-2-安全点（Safepoint）"><a href="#3-3-2-安全点（Safepoint）" class="headerlink" title="3.3.2 安全点（Safepoint）"></a>3.3.2 安全点（Safepoint）</h3><blockquote>
<p>在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说<strong>OopMap内容变化的指令非常多</strong>，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。</p>
<p>实际上，HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“<strong>特定的位置</strong>”记录了这些信息，这些位置称为<strong>安全点（Safepoint）</strong>，即程序执行时并非在所有地方都能停顿下来开始GC，<strong>只有在到达安全点时才能暂停</strong>。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“<strong>是否具有让程序长时间执行的特征</strong>”为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是<strong>指令序列复用，例如方法调用、循环跳转、异常跳转等</strong>，所以具有这些功能的指令才会产生Safepoint。</p>
<p>对于Sefepoint，另一个需要考虑的问题是如何在GC发生时让所有线程（这里不包括执行JNI调用的线程）都“跑”到最近的安全点上再停顿下来（<strong>Mutator suspension</strong>）。这里有两种方案可供选择：</p>
<ul>
<li><strong>抢先式中断（Preemptive Suspension）</strong><br>不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。</li>
<li><strong>主动式中断（Voluntary Suspension）</strong><br>思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志（<a href="#pollingPoint"><strong>Polling Point</strong></a>），各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</li>
</ul>
</blockquote>
<p>简单的解释：</p>
<blockquote>
<p>In order to support <strong>precise enumeration</strong>, JIT compiler should do additional work, because only JIT knows exactly stack frame info and register contents. When JIT compiles a method, for every instruction, it can <strong>book-keep the root reference information</strong> in case the execution is suspended at that instruction. </p>
<p>But to remember the info for every instruction is <strong>too expensive</strong>. It requires substantial space to store the information. This is also unnecessary, because <strong>only a few instructions will have the chances to be the suspension points in real execution</strong>. JIT <strong>only needs to book-keep information for those instruction points</strong> – they are called safe-points. Safe-point means it is a safe suspension point for root set enumeration.</p>
</blockquote>
<p>进一步阐述：<br><a href="https://www.zhihu.com/question/29268019/answer/43762165" target="_blank" rel="external">现代JVM中的Safe Region和Safe Point到底是如何定义和划分的?</a></p>
<blockquote>
<p>作者：RednaxelaFX<br>链接：<a href="https://www.zhihu.com/question/29268019/answer/43762165" target="_blank" rel="external">https://www.zhihu.com/question/29268019/answer/43762165</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>其实在高度优化的现代JVM里，safepoint有几种不同的用法。GC safepoint是最常见、大家听说得最多的，但还有deoptimization safepoint也很重要。<br>在HotSpot VM里，这两种safepoint目前实现在一起，但其实概念上它们俩没有直接联系，需要的数据不一样。<br>无论是哪种safepoint，最简洁的定义是<strong>“A point in program where the state of execution is known by the VM”</strong>。这里“state of execution”特意说得模糊，是因为不同种类的safepoint需要的数据不一样。<br><strong>GC safepoint需要知道在那个程序位置上，调用栈、寄存器等一些重要的数据区域里什么地方包含了GC管理的指针；</strong><br>Deoptimization safepoint需要知道在那个程序位置上，原本抽象概念上的JVM的执行状态（所有局部变量、临时变量、锁，等等）到底分配到了什么地方，是在栈帧￼的具体某个slot还是在某个寄存器里，之类的。<br>如果要触发一次GC，那么JVM里的所有Java线程都必须到达GC safepoint；<br>如果要执行一次deoptimization，那么需要执行deoptimization的线程要在到达deoptimization safepoint之后才可以开始deoptimize。<br>不同JVM实现会选用不同的位置放置safepoint。<br>以HotSpot VM为例，<br>在解释器里每条字节码的边界都可以是一个safepoint，因为HotSpot的解释器总是能很容易的找出完整的“state of execution”。<br>而在JIT编译的代码里，HotSpot会在所有方法的临返回之前，以及所有非counted loop的循环的回跳之前放置safepoint。<br>HotSpot的JIT编译器不但会生成机器码，还会额外在每个safepoint生成一些“调试符号信息”，以便VM能找到所需的“state of execution”。<br>为GC生成的符号信息是<strong>OopMap</strong>，指出栈上和寄存器里哪里有GC管理的指针；<br>为deoptimization生成的符号信息是debugInfo，指出如果要把当前栈帧从compiled frame转换为interpreted frame的话，要从哪里把相应的局部变量、临时变量、锁等信息找出来。<br><strong>之所以只在选定的位置放置safepoint是因为：</strong></p>
<ul>
<li><strong>挂在safepoint的调试符号信息要占用空间</strong>。如果允许每条机器码都可以是safepoint的话，需要存储的数据量会很大（当然这有办法解决，例如用delta存储和用压缩）</li>
<li><strong>safepoint会影响优化</strong>。特别是deoptimization safepoint，会迫使JVM保留一些只有解释器可能需要的、JIT编译器认定无用的变量的值。本来JIT编译器可能可以发现某些值不需要而消除它们对应的运算，如果在safepoint需要这些值的话那就只好保留了。这才是更重要的地方，所以要尽量少放置safepoint</li>
<li>像<strong>HotSpot VM</strong>这样，在safepoint会生成polling代码询问VM是否要“进入safepoint”，<strong>polling也有开销</strong>所以要尽量减少。</li>
</ul>
<p>还有一种情况是当某个线程在执行native函数的时候。此时该线程在执行JVM管理之外的代码，不能对JVM的执行状态做任何修改，因而JVM要进入safepoint不需要关心它。所以也<strong>可以把正在执行native函数的线程看作“已经进入了safepoint”，或者把这种情况叫做“在safe-region里”</strong>。<br>JVM外部要对JVM执行状态做修改必须要通过JNI。<strong>所有能修改JVM执行状态的JNI函数在入口处都有safepoint检查，一旦JVM已经发出通知说此时应该已经到达safepoint就会在这些检查的地方停下来把控制权交给JVM。</strong><br>换一个JVM说，JRockit选择放置safepoint的地方在方法的入口以及循环末尾回跳之前，跟HotSpot略为不同。</p>
</blockquote>
<h3 id="3-3-3-Polling-Point"><a href="#3-3-3-Polling-Point" class="headerlink" title="3.3.3 Polling Point"></a>3.3.3 Polling Point</h3><p><span id="pollingPoint"></span></p>
<p><a href="http://xiao-feng.blogspot.com/2008/01/gc-safe-point-and-safe-region.html" target="_blank" rel="external">GC safe-point (or safepoint) and safe-region | Xiao-Feng Li</a></p>
<blockquote>
<p> For voluntary suspension, a more serious problem is the polling overhead. So the basic principles for polling point insertion are: Firstly, <strong>polling points should be frequent enough</strong> so that GC does not wait too long for a mutator to suspend, because other mutators might be waiting for GC to free the space in order to continue. Secondly, <strong>polling points should not be too frequent</strong> to introduce big runtime overhead. </p>
<p>The best result is to have only adequate polling points that are necessary and sufficient. </p>
<ol>
<li>The mandatory polling points are the allocation sites. Allocation can trigger collection, so allocation site has to be a safe point. </li>
<li>Long-time execution are always associated with method call or loop. So call sites and loop back sites are also expected polling points. </li>
</ol>
<p>Those are the sites for polling points in Harmony: <strong>allocation sites</strong>, <strong>call sites</strong> and <strong>loop back sites</strong>. Mostly the runtime overhead is smaller than 1%. </p>
</blockquote>
<h3 id="3-3-4-安全区域（Safe-Region）"><a href="#3-3-4-安全区域（Safe-Region）" class="headerlink" title="3.3.4 安全区域（Safe Region）"></a>3.3.4 安全区域（Safe Region）</h3><blockquote>
<p>使用Safepoint似乎已经完美地解决了如何进入GC的问题，但实际情况却并不一定。Safepoint机制保证了程序执行时，在不太长的时间内就会遇到可进入GC的Safepoint。但是，程序“不执行”的时候呢？所谓的程序不执行就是没有分配CPU时间，典型的例子就是线程处于Sleep状态或者Blocked状态，这时候<strong>线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域（Safe Region）来解决</strong>。</p>
<p><strong>安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。我们也可以把Safe Region看做是被扩展了的safe-point。</strong></p>
<p>在线程执行到SafeRegion中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p>
</blockquote>
<p><a href="http://xiao-feng.blogspot.com/2008/01/gc-safe-point-and-safe-region.html" target="_blank" rel="external">GC safe-point (or safepoint) and safe-region | Xiao-Feng Li</a></p>
<blockquote>
<p>In safe-point design, the mutator polling for GC event will respond <strong>if the event is triggered</strong>. It <strong>responds by setting a ready flag</strong> when it’s sure to suspend. <strong>Then the GC can proceed</strong> with root set enumeration. This is a <strong>hand-shaking</strong> protocol. </p>
<p>Safe-region just follows this protocol. The mutator sets the ready flag when it enters a safe-region. Before it leaves the region, it checks if GC has finished its enumeration (or collection), and no longer needs the mutator under suspension state. If it’s true, it goes ahead and leaves the region; otherwise, it suspends itself as in a safe-point.</p>
<p>In Harmony implementation, we insert <strong>suspend_enable</strong> and <strong>suspend_disable</strong> to delimit the scope of safe-region.</p>
</blockquote>
<h1 id="4-各种垃圾收集器的异同"><a href="#4-各种垃圾收集器的异同" class="headerlink" title="4 各种垃圾收集器的异同"></a>4 各种垃圾收集器的异同</h1><h2 id="4-1-HotSpot"><a href="#4-1-HotSpot" class="headerlink" title="4.1 HotSpot"></a>4.1 HotSpot</h2><ul>
<li><a href="http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf" target="_blank" rel="external">Memory Management in the Java HotSpot™ Virtual Machine</a></li>
<li><img src="http://otlnkjq1m.bkt.clouddn.com/GC-05.png" alt=""></li>
</ul>
<h3 id="4-1-1-GC自适应的调节策略（GC-Ergonomics）"><a href="#4-1-1-GC自适应的调节策略（GC-Ergonomics）" class="headerlink" title="4.1.1 GC自适应的调节策略（GC Ergonomics）"></a>4.1.1 GC自适应的调节策略（GC Ergonomics）</h3><p><span id="GCErgonomics"></span></p>
<p><a href="https://blog.codecentric.de/en/2013/01/useful-jvm-flags-part-6-throughput-collector/" target="_blank" rel="external">Useful JVM Flags - Part 6 (Throughput Collector) - codecentric AG Blog</a></p>
<blockquote>
<p>The throughput collectors offer an interesting (but common, at least on modern JVMs) mechanism to improve user-friendliness of GC configuration. This mechanism is part of what is known as “ergonomics”, a concept <strong>introduced for HotSpot with Java 5</strong>. With ergonomics, <strong>the garbage collector may dynamically apply modifications to the different heap areas sizes as well as the GC settings if it has evidence that these modifications would improve GC performance</strong>. The precise meaning of “improve GC performance” may be specified by the user via the flags <code>-XX:GCTimeRatio</code> and <code>-XX:MaxGCPauseMillis</code> (see below).</p>
<p>It is important to know that <strong>ergonomics is activated by default</strong> – which is fine, as adaptive behavior is one of the biggest strengths of the JVM. Still, sometimes we may have a pretty clear idea of what settings are best for a particular application, and in these cases we might not want the JVM to mess around with our settings. Whenever we find ourselves in such a situation, we may consider deactivating some of the ergonomics by setting <strong><code>-XX:-UseAdaptiveSizePolicy</code></strong>.</p>
</blockquote>
<p><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/vm/gc-ergonomics.html" target="_blank" rel="external">Garbage Collection Ergonomics</a></p>
<blockquote>
<p><strong>Garbage Collector Ergonomics</strong><br>The following changes take effect with J2SE 5.0.</p>
<ul>
<li><p>Implementation of <strong><code>-XX:+UseAdaptiveSizePolicy</code></strong> Used by Parallel Garbage Collector Changed</p>
<p>  <strong>The implementation of -XX:+UseAdaptiveSizePolicy used by default with the -XX:+UseParallelGC garbage collector</strong> has changed to consider <strong>three goals</strong>:</p>
<ul>
<li>a desired maximum GC pause goal</li>
<li>a desired application throughput goal</li>
<li>minimum footprint</li>
</ul>
</li>
<li><p><strong>Suggested strategy</strong><br>Do not choose a maximum value for the heap unless you know that the heap is greater than the default maximum heap size. Choose a throughput goal that is sufficient for your application.</p>
<ul>
<li><p>In an ideal situation the heap will grow to a value (less than the maximum) that will support the chosen throughput goal.</p>
</li>
<li><p>If the heap grows to its maximum, the throughput cannot be met within that maximum. Set the maximum heap as large as you can, but no larger than the size of physical memory on the platform, and execute the application again. If the throughput goal can still not be met, then it is too high for the available memory on the platform.</p>
</li>
<li><p>If the throughput goal can be met but there are pauses that are too long, select a pause time goal. This will likely mean that your throughput goal will not be met, so choose values that are an acceptable compromise for the application.</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="4-1-2-Fast-Allocation"><a href="#4-1-2-Fast-Allocation" class="headerlink" title="4.1.2 Fast Allocation"></a>4.1.2 Fast Allocation</h3><p>这个概念应该不重要，很多地方都没提到，就<a href="http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf" target="_blank" rel="external">Memory Management in the Java HotSpot™ Virtual Machine</a>提到了这个概念。</p>
<h3 id="4-1-3-Serial-Collector"><a href="#4-1-3-Serial-Collector" class="headerlink" title="4.1.3 Serial Collector"></a>4.1.3 Serial Collector</h3><p>单线程的收集器，是JVM在client模式下运行的默认收集器。</p>
<p>Serial收集器新生代垃圾收集器，<strong>采用复制算法</strong>。</p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/GC-06.png" alt=""></p>
<ul>
<li>优点：<ul>
<li>简单而高效<br>对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得较高的收集效率</li>
</ul>
</li>
</ul>
<h3 id="4-1-4-Serial-Old-Collector"><a href="#4-1-4-Serial-Old-Collector" class="headerlink" title="4.1.4 Serial Old Collector"></a>4.1.4 Serial Old Collector</h3><p><strong>Serial Old是Serial收集器的老年代版本</strong>，它同样是一个单线程收集器，使用“标记-整理”算法。这个收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p>
<h3 id="4-1-5-ParNew收集器"><a href="#4-1-5-ParNew收集器" class="headerlink" title="4.1.5 ParNew收集器"></a>4.1.5 ParNew收集器</h3><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SurvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。</p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/GC-07.png" alt=""></p>
<p><strong>ParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处</strong>，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器，其中有一个与性能无关但很重要的原因是，<strong>除了Serial收集器外，目前只有它能与CMS收集器配合工作</strong>。在JDK 1.5时期，HotSpot推出了一款在强交互应用中几乎可认为有划时代意义的垃圾收集器——CMS收集器（Concurrent Mark Sweep，本节稍后将详细介绍这款收集器），这款收集器是HotSpot虚拟机中第一款真正意义上的并发（Concurrent）收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作，</p>
<p>不幸的是，CMS作为老年代的收集器，却无法与JDK 1.4.0中已经存在的新生代收集器Parallel Scavenge配合工作，所以在JDK 1.5中使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个。ParNew收集器也是使用-XX:+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX:+UseParNewGC选项来强制指定它。<br><strong>ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果</strong>，甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU的环境中都不能百分之百地保证可以超越Serial收集器。当然，随着可以使用的CPU的数量的增加，它对于GC时系统资源的有效利用还是很有好处的。<strong>它默认开启的收集线程数与CPU的数量相同</strong>，在CPU非常多（譬如32个，现在CPU动辄就4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）的环境下，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。</p>
<h3 id="4-1-6-Parallel-Scavenge-收集器"><a href="#4-1-6-Parallel-Scavenge-收集器" class="headerlink" title="4.1.6 Parallel Scavenge 收集器"></a>4.1.6 Parallel Scavenge 收集器</h3><p>Parallel Scavenge收集器是新生代垃圾收集器，使用复制算法，也是并行的多线程收集器。与ParNew收集器相比，很多相似之处，但是Parallel Scavenge收集器更关注可控制的吞吐量。吞吐量越大，垃圾收集的时间越短，则用户代码则可以充分利用CPU资源，尽快完成程序的运算任务。</p>
<p>Parallel Scavenge收集器使用两个参数控制吞吐量：</p>
<ul>
<li>XX:MaxGCPauseMillis 控制最大的垃圾收集停顿时间</li>
<li>XX:GCRatio 直接设置吞吐量的大小。</li>
</ul>
<p>直观上，只要最大的垃圾收集停顿时间越小，吞吐量是越高的，但是GC停顿时间的缩短是以牺牲吞吐量和新生代空间作为代价的。比如原来10秒收集一次，每次停顿100毫秒，现在变成5秒收集一次，每次停顿70毫秒。停顿时间下降的同时，吞吐量也下降了。</p>
<p>除此之外，Parallel Scavenge收集器还可以设置参数-XX:+UseAdaptiveSizePocily来动态调整停顿时间或者最大的吞吐量，这种方式称为<a href="#GCErgonomics">GC自适应调节策略（GC Ergonomics）</a>，这点是ParNew收集器所没有的。</p>
<h3 id="4-1-7-Parallel-Old-收集器"><a href="#4-1-7-Parallel-Old-收集器" class="headerlink" title="4.1.7 Parallel Old 收集器"></a>4.1.7 Parallel Old 收集器</h3><p><strong>Parallel Old是Parallel Scavenge收集器的老年代版本</strong>，使用多线程和“<strong>标记-整理</strong>”算法。这个收集器是在JDK 1.6中才开始提供的，在此之前，新生代的Parallel Scavenge收集器一直处于比较尴尬的状态。原因是，如果新生代选择了Parallel Scavenge收集器，老年代除了Serial Old（PS MarkSweep）收集器外别无选择（还记得上面说过Parallel Scavenge收集器无法与CMS收集器配合工作吗？）。由于老年代Serial Old收集器在服务端应用性能上的“拖累”，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，由于单线程的老年代收集中无法充分利用服务器多CPU的处理能力，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定有ParNew加CMS的组合“给力”。直到Paralle lOld收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。</p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/GC-08.png" alt=""></p>
<h3 id="4-1-8-Concurrent-Mark-Sweep-CMS-Collector"><a href="#4-1-8-Concurrent-Mark-Sweep-CMS-Collector" class="headerlink" title="4.1.8 Concurrent Mark-Sweep (CMS) Collector"></a>4.1.8 Concurrent Mark-Sweep (CMS) Collector</h3><p>CMS收集器（Concurrent Mark Sweep）的目标就是获取最短回收停顿时间。在注重服务器的响应速度，希望停顿时间最短，则CMS收集器是比较好的选择。</p>
<p>整个执行过程分为以下4个步骤：</p>
<ul>
<li>初始标记</li>
<li>并发标记</li>
<li>重新标记</li>
<li>并发<strong>清除</strong></li>
</ul>
<p><strong>初始标记和重新标记这两个步骤仍然需要暂停Java执行线程</strong>，初始标记只是标记GC Roots能够直接关联到的对象，并发标记就是执行GC Roots Tracing的过程，而重新标记就是为了修正并发标记期间因用户程序执行而导致标记发生变动使得标记错误的记录。其执行过程如下：</p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/GC-09.png" alt=""></p>
<p><strong>不足：</strong></p>
<ul>
<li>CMS收集器对CPU资源非常敏感。<br>其实，面向并发设计的程序都对CPU资源比较敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用了一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。CMS默认启动的回收线程数是（CPU数量+3）/4，也就是当CPU在4个以上时，并发回收时垃圾收集线程不少于25%的CPU资源，并且随着CPU数量的增加而下降。但是当CPU不足4个（譬如2个）时，CMS对用户程序的影响就可能变得很大，如果本来CPU负载就比较大，还分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然降低了50%，其实也让人无法接受。为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”（Incremental Concurrent MarkSweep/i-CMS）的CMS收集器变种，所做的事情和单CPU年代PC机操作系统使用抢占式来模拟多任务机制的思想一样，就是在并发标记、清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些，也就是速度下降没有那么明显。实践证明，增量时的CMS收集器效果很一般，在目前版本中，i-CMS已经被声明为”deprecated”，即不再提倡用户使用。</li>
<li>CMS收集器无法处理<strong>浮动垃圾（Floating Garbage）</strong>，可能出现”Concurrent Mode Failure”失败而导致另一次Full GC的产生。<br>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。在JDK 1.5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活，这是一个偏保守的设置，如果在应用中老年代增长不是太快，可以适当调高参数-XX:CMSInitiatingOccupancyFraction的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能，在JDK 1.6中，CMS收集器的启动阈值已经提升至92%。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次”Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说参数-XX:CMSInitiatingOccupancyFraction设置得太高很容易导致大量”Concurrent Mode Failure”失败，性能反而降低。</li>
<li>CMS是一款<strong>基于“标记—清除”算法</strong>实现的收集器，这意味着收集结束时会有大量<strong>空间碎片</strong>产生。<br>空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，不得不提前触发一次Full GC。<u>为了解决这个问题，CMS收集器提供了一个-XX:+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程</u>，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。虚拟机设计者还提供了另外一个参数-XX:CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的（默认值为0，表示每次进入Full GC时都进行碎片整理）。</li>
</ul>
<h3 id="4-1-9-Garbage-First（G1）-Collector"><a href="#4-1-9-Garbage-First（G1）-Collector" class="headerlink" title="4.1.9 Garbage-First（G1） Collector"></a>4.1.9 Garbage-First（G1） Collector</h3><p>G1（Garbage-First）收集器是现今收集器技术的最新成果之一，之前一直处于实验阶段，直到jdk 7u4之后，才正式作为商用的收集器。</p>
<p>与前几个收集器相比，G1收集器有以下特点：</p>
<ul>
<li>并行与并发</li>
<li>分代收集（仍然保留了分代的概念）</li>
<li>空间整合（整体上属于“标记-整理”算法，不会导致空间碎片）</li>
<li>可预测的停顿（比CMS更先进的地方在于能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒）</li>
</ul>
<p>此外，G1收集器将Java堆划分为多个大小相等的Region（独立区域），新生代与老年代都是一部分Region的集合，G1的收集范围则是这一个个Region（化整为零）。</p>
<p>G1的工作过程如下：</p>
<ul>
<li>初始标记（Initial Marking）</li>
<li>并发标记（Concurrent Marking）</li>
<li>最终标记（Final Marking）</li>
<li>筛选回收（Live Data Counting and Evacuation）</li>
</ul>
<p>初始标记阶段仅仅只是标记一下GC Roots能够直接关联的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段的用户程序并发运行的时候，能在正确可用的Region中创建对象，这个阶段需要暂停线程。并发标记阶段从GC Roots进行可达性分析，找出存活的对象，这个阶段是由用户线程并发执行的。最终标记阶段则是修正在并发标记阶段因为用户程序的并发执行而导致标记产生变动的那一部分记录，这部分记录被保存在Remembered Set Logs中，最终标记阶段再把Logs中的记录合并到Remembered Set中，这个阶段是并行执行的，仍然需要暂停用户线程。最后在筛选阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间制定回收计划。整个执行过程如下：</p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/GC-10.png" alt=""></p>
<h1 id="5-GC相关参数"><a href="#5-GC相关参数" class="headerlink" title="5 GC相关参数"></a>5 GC相关参数</h1><p><img src="http://otlnkjq1m.bkt.clouddn.com/GC-11.png" alt=""></p>
<ul>
<li><p>client/serrver端不同的GC方式：<br><img src="http://otlnkjq1m.bkt.clouddn.com/GC-12.png" alt=""></p>
</li>
<li><p>Sun JDK HotSpot虚拟机GC组合方式：<br><img src="http://otlnkjq1m.bkt.clouddn.com/GC-13.png" alt=""></p>
</li>
</ul>
<h1 id="6-GC性能指标"><a href="#6-GC性能指标" class="headerlink" title="6 GC性能指标"></a>6 GC性能指标</h1><p><a href="http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf" target="_blank" rel="external">Memory Management in the Java HotSpot™ Virtual Machine</a></p>
<h2 id="6-1-Throughput-吞吐量"><a href="#6-1-Throughput-吞吐量" class="headerlink" title="6.1 Throughput 吞吐量"></a>6.1 Throughput 吞吐量</h2><blockquote>
<p>the percentage of total time not spent in garbage collection, considered over long periods of time</p>
</blockquote>
<p>（在一段长时间内，在垃圾收集中花费的总时间的百分比）</p>
<blockquote>
<p>吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即：<br>吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）。<br>虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p>
</blockquote>
<h2 id="6-2-Garbage-collection-overhead-GC耗费"><a href="#6-2-Garbage-collection-overhead-GC耗费" class="headerlink" title="6.2 Garbage collection overhead GC耗费"></a>6.2 Garbage collection overhead GC耗费</h2><blockquote>
<p>the inverse of throughput, that is, the percentage of total time spent in garbage collection</p>
</blockquote>
<p>（吞吐量的倒数，也就是垃圾收集总时间的百分比）</p>
<h2 id="6-3-Pause-time-停顿时间"><a href="#6-3-Pause-time-停顿时间" class="headerlink" title="6.3 Pause time 停顿时间"></a>6.3 Pause time 停顿时间</h2><blockquote>
<p>the length of time during which application execution is stopped while garbage collection is occurring.</p>
</blockquote>
<p>（垃圾收集发生时停止应用程序执行的时间）</p>
<h2 id="6-4-Frequency-of-collection（GC的频率）"><a href="#6-4-Frequency-of-collection（GC的频率）" class="headerlink" title="6.4 Frequency of collection（GC的频率）"></a>6.4 Frequency of collection（GC的频率）</h2><h2 id="6-5-Footprint"><a href="#6-5-Footprint" class="headerlink" title="6.5 Footprint"></a>6.5 Footprint</h2><blockquote>
<p>a measure of size, such as heap size</p>
</blockquote>
<h2 id="6-6-Promptness-速度"><a href="#6-6-Promptness-速度" class="headerlink" title="6.6 Promptness 速度"></a>6.6 Promptness 速度</h2><blockquote>
<p>the time between when an object becomes garbage and when the memory becomes<br>available.</p>
</blockquote>
<p>（从对象变为垃圾到内存变为可用的时间可用。）</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf" target="_blank" rel="external">Memory Management in the Java HotSpot™ Virtual Machine</a></li>
<li><a href="http://blog.csdn.net/u011080472/article/details/51324422" target="_blank" rel="external">【深入理解JVM】：HotSpot垃圾收集器 - CSDN博客</a></li>
<li>周志明. 深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）</li>
<li><a href="http://xiao-feng.blogspot.com/2008/01/gc-safe-point-and-safe-region.html" target="_blank" rel="external">GC safe-point (or safepoint) and safe-region | Xiao-Feng Li</a></li>
<li><a href="https://www.zhihu.com/question/53613423/answer/135743258" target="_blank" rel="external">java的gc为什么要分代？ - 知乎</a></li>
<li><a href="https://www.zhihu.com/question/29268019/answer/43762165" target="_blank" rel="external">现代JVM中的Safe Region和Safe Point到底是如何定义和划分的?</a></li>
<li><a href="http://hllvm.group.iteye.com/group/topic/38223#post-248757" target="_blank" rel="external">并发垃圾收集器（CMS）为什么没有采用标记-整理算法来实现？ - 讨论 - 高级语言虚拟机 - ITeye群组</a></li>
<li><a href="https://www.zhihu.com/question/33210180/answer/56348818" target="_blank" rel="external">JVM GC遍历一次新生代所有对象是否可达需要多久？ - 知乎</a></li>
<li><a href="https://blog.codecentric.de/en/2013/01/useful-jvm-flags-part-6-throughput-collector/" target="_blank" rel="external">Useful JVM Flags - Part 6 (Throughput Collector) - codecentric AG Blog</a></li>
<li><a href="https://docs.oracle.com/javase/7/docs/technotes/guides/vm/gc-ergonomics.html" target="_blank" rel="external">Garbage Collection Ergonomics</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1. 概念&quot;&gt;&lt;/a&gt;1. 概念&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/u011080472/article/details/51324422&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;http://blog.csdn.net/u011080472/article/details/51324422&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-0-并发和并行&quot;&gt;&lt;a href=&quot;#1-0-并发和并行&quot; class=&quot;headerlink&quot; title=&quot;1.0 并发和并行&quot;&gt;&lt;/a&gt;1.0 并发和并行&lt;/h2&gt;&lt;p&gt;这两个名词都是并发编程中的概念，在谈论垃圾收集器的上下文语境中，它们可以解释如下。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;1-1-Minor-GC-和-Full-GC&quot;&gt;&lt;a href=&quot;#1-1-Minor-GC-和-Full-GC&quot; class=&quot;headerlink&quot; title=&quot;1.1 Minor GC 和 Full GC&quot;&gt;&lt;/a&gt;1.1 Minor GC 和 Full GC&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;新生代GC（Minor GC / Young GC /  YGC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;老年代GC（Major GC / Full GC / FGC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://bungder.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="http://bungder.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>WebSocket简介</title>
    <link href="http://bungder.github.io/2018/03/15/websocket-abstract/"/>
    <id>http://bungder.github.io/2018/03/15/websocket-abstract/</id>
    <published>2018-03-15T14:53:40.000Z</published>
    <updated>2018-03-15T15:12:51.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h1><h2 id="1-1-comet"><a href="#1-1-comet" class="headerlink" title="1.1 comet"></a>1.1 comet</h2><p>天不生WS，万古如长夜。</p>
<p>在WebSocket出现之前，服务端主动推送消息给浏览器的需求就已经存在了，但是HTTP这个协议本来就不是设计用来进行双向通信的，所以机智的工程师们采取了各种hack的方式来实现这种功能，这些实现方式都统称为<code>comet</code>。</p>
<p>但是无可避免地，这些技术都存在缺陷，既然WebSocket都出现了，那么这些技术大概也能进博物馆了，除了实现Fallback方案时需要去了解之外，这些技术感觉价值不大了，所以不展开说，如果读者有兴趣，可以根据关键词找资料去了解。</p>
<a id="more"></a>
<blockquote>
<p>Comet is a web application model in which a long-held HTTPS request allows a web server to push data to a browser, without the browser explicitly requesting it</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Comet_(programming" target="_blank" rel="external">https://en.wikipedia.org/wiki/Comet_(programming)</a>)</p>
<blockquote>
<p>With long-polling we set the bar to cross-browser push. With XHR streaming and ActiveXObject(’htmlfile’) we raised it to cross-browser streaming. With SSE we’ve been trying to raise the bar to native, cross-browser streaming</p>
</blockquote>
<h3 id="1-1-1-实现"><a href="#1-1-1-实现" class="headerlink" title="1.1.1 实现"></a>1.1.1 实现</h3><h4 id="1-1-1-1-Streaming"><a href="#1-1-1-1-Streaming" class="headerlink" title="1.1.1.1 Streaming"></a>1.1.1.1 Streaming</h4><h5 id="1-1-1-1-1-Hidden-iframe"><a href="#1-1-1-1-1-Hidden-iframe" class="headerlink" title="1.1.1.1.1 Hidden iframe"></a>1.1.1.1.1 Hidden iframe</h5><h5 id="1-1-1-1-2-XMLHttpRequest"><a href="#1-1-1-1-2-XMLHttpRequest" class="headerlink" title="1.1.1.1.2 XMLHttpRequest"></a>1.1.1.1.2 XMLHttpRequest</h5><h4 id="1-1-1-2-Ajax-Long-pulling"><a href="#1-1-1-2-Ajax-Long-pulling" class="headerlink" title="1.1.1.2 Ajax Long-pulling"></a>1.1.1.2 Ajax Long-pulling</h4><h5 id="1-1-1-2-1-XMLHttpRequest-long-polling"><a href="#1-1-1-2-1-XMLHttpRequest-long-polling" class="headerlink" title="1.1.1.2.1 XMLHttpRequest long polling"></a>1.1.1.2.1 XMLHttpRequest long polling</h5><h5 id="1-1-1-2-2-Script-tag-long-polling"><a href="#1-1-1-2-2-Script-tag-long-polling" class="headerlink" title="1.1.1.2.2 Script tag long polling"></a>1.1.1.2.2 Script tag long polling</h5><h2 id="1-2-WebSocket协议"><a href="#1-2-WebSocket协议" class="headerlink" title="1.2 WebSocket协议"></a>1.2 WebSocket协议</h2><p>WebSocket是一种在单个TCP连接上进行全双工通讯的协议。是有别于HTTP的另一个TCP协议，它们都属于OSI模型中的第七层:</p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/osi.png" alt=""></p>
<p><a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="external"><strong>RFC 6455</strong></a> states that WebSocket “is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries” thus making it <strong>compatible with the HTTP</strong> protocol.</p>
<p>原文为：</p>
<blockquote>
<p>The WebSocket Protocol attempts to address the<br>goals of existing bidirectional HTTP technologies in the context of<br>the existing HTTP infrastructure; as such, <b>it is designed to work<br>over HTTP ports 80 and 443 as well as to support HTTP proxies and<br>intermediaries</b>, even if this implies some complexity specific to the<br>current environment.</p>
</blockquote>
<h3 id="1-2-1-握手"><a href="#1-2-1-握手" class="headerlink" title="1.2.1 握手"></a>1.2.1 握手</h3><blockquote>
<p>To establish a WebSocket connection, the client sends a WebSocket handshake request, for which the server returns a WebSocket handshake response, as shown in the example below:</p>
</blockquote>
<ul>
<li><p>客户端请求</p>
  <figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GET</span> <span class="string">/</span> HTTP/1.1</div><div class="line"><span class="attribute">Upgrade</span>: websocket    </div><div class="line"><span class="attribute">Connection</span>: Upgrade</div><div class="line"><span class="attribute">Host</span>: example.com</div><div class="line"><span class="attribute">Origin</span>: http://example.com</div><div class="line"><span class="attribute">Sec-WebSocket-Key</span>: sN9cRrP/n9NdMgdcy2VJFQ==</div><div class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</div></pre></td></tr></table></figure>
</li>
<li><p>服务器回应</p>
  <figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 <span class="number">101</span> Switching Protocols</div><div class="line"><span class="attribute">Upgrade</span>: websocket</div><div class="line"><span class="attribute">Connection</span>: Upgrade</div><div class="line"><span class="attribute">Sec-WebSocket-Accept</span>: fFBooB7FAkLlXgRSz0BT3v4hq5s=</div><div class="line"><span class="attribute">Sec-WebSocket-Location</span>: ws://example.com/</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>The handshake resembles HTTP in allowing servers to handle HTTP connections as well as WebSocket connections on the same port. Once the connection is established, communication switches to a bidirectional binary protocol which doesn’t conform to the HTTP protocol.</p>
</blockquote>
<h3 id="1-2-2-Frame"><a href="#1-2-2-Frame" class="headerlink" title="1.2.2 Frame"></a>1.2.2 Frame</h3><p>WebSocket传输的数据是基于帧的，一帧数据里包含两部分：数据主体和控制帧</p>
<blockquote>
<p>there are types for textual data (which is interpreted as UTF-8 [RFC3629]<br>text), binary data (whose interpretation is left up to the<br>application), and control frames (which are not intended to carry<br>data for the application but instead for protocol-level signaling,<br>such as to signal that the connection should be closed)</p>
</blockquote>
<p>为了避免混淆网络中间件（例如拦截代理）以及出于安全原因，</p>
<ul>
<li>客户端必须屏蔽（mask）所有发送给服务器的帧，如果服务器收到了未屏蔽的帧，必须关闭连接。在这种情况下，服务器可以发送一个<code>Close</code>帧，状态码为<code>1002</code>。</li>
<li>服务器不能屏蔽任何发送给客户端的帧，如果客户端收到了屏蔽过的帧，必须关闭连接。这种情况下，也可以利用状态码<code>1002</code>。</li>
<li></li>
</ul>
<p>基本的帧协议（The Base Framing Protocol）简单地定义以下部分：</p>
<p>Frame：</p>
<ul>
<li>opcode：操作码，用于定义一个帧的类型</li>
<li>Payload data<ul>
<li>Extension data：<ul>
<li>payload length：载荷长度</li>
<li>designated locations：指定位置</li>
</ul>
</li>
<li>Application Data</li>
</ul>
</li>
</ul>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/websocket-frame.png" alt=""></p>
<h3 id="1-2-3-心跳"><a href="#1-2-3-心跳" class="headerlink" title="1.2.3 心跳"></a>1.2.3 心跳</h3><p>一端发送<code>Ping</code>帧，另一端发送<code>Pong</code>帧作为响应</p>
<ul>
<li>The <code>Ping</code> frame contains an opcode of <code>0x9</code>.</li>
<li>The <code>Pong</code> frame contains an opcode of <code>0xA</code>.</li>
</ul>
<h3 id="1-2-4-优点"><a href="#1-2-4-优点" class="headerlink" title="1.2.4 优点"></a>1.2.4 优点</h3><blockquote>
<ul>
<li>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</li>
<li>更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。</li>
<li>保持连接状态。于HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</li>
<li>更好的二进制支持。Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。</li>
<li>可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。</li>
<li>更好的压缩效果。相对于HTTP压缩，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率。</li>
</ul>
</blockquote>
<h1 id="2-API"><a href="#2-API" class="headerlink" title="2 API"></a>2 API</h1><h2 id="2-1-JavaScript-API"><a href="#2-1-JavaScript-API" class="headerlink" title="2.1 JavaScript API"></a>2.1 JavaScript API</h2><p><a href="https://www.w3.org/TR/websockets/" target="_blank" rel="external">The WebSocket API</a>:</p>
<p>The WebSocket Interface<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">interface WebSocket : EventTarget &#123;</div><div class="line">  readonly attribute DOMString url;</div><div class="line"></div><div class="line">  <span class="comment">// ready state</span></div><div class="line">  <span class="keyword">const</span> unsigned short CONNECTING = <span class="number">0</span>;</div><div class="line">  <span class="keyword">const</span> unsigned short OPEN = <span class="number">1</span>;</div><div class="line">  <span class="keyword">const</span> unsigned short CLOSING = <span class="number">2</span>;</div><div class="line">  <span class="keyword">const</span> unsigned short CLOSED = <span class="number">3</span>;</div><div class="line">  readonly attribute unsigned short readyState;</div><div class="line">  readonly attribute unsigned long bufferedAmount;</div><div class="line"></div><div class="line">  <span class="comment">// networking</span></div><div class="line">           attribute EventHandler onopen;</div><div class="line">           attribute EventHandler onerror;</div><div class="line">           attribute EventHandler onclose;</div><div class="line">  readonly attribute DOMString extensions;</div><div class="line">  readonly attribute DOMString protocol;</div><div class="line">  <span class="keyword">void</span> close([Clamp] optional unsigned short code, optional DOMString reason);</div><div class="line"></div><div class="line">  <span class="comment">// messaging</span></div><div class="line">           attribute EventHandler onmessage;</div><div class="line">           attribute DOMString binaryType;</div><div class="line">  <span class="keyword">void</span> send(DOMString data);</div><div class="line">  <span class="keyword">void</span> send(Blob data);</div><div class="line">  <span class="keyword">void</span> send(<span class="built_in">ArrayBuffer</span> data);</div><div class="line">  <span class="keyword">void</span> send(ArrayBufferView data);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/websocket-prototype.png" alt=""></p>
<h2 id="2-2-Java-API"><a href="#2-2-Java-API" class="headerlink" title="2.2 Java API"></a>2.2 Java API</h2><h3 id="2-2-1-Java-EE"><a href="#2-2-1-Java-EE" class="headerlink" title="2.2.1 Java EE"></a>2.2.1 Java EE</h3><p><a href="http://www.oracle.com/technetwork/articles/java/jsr356-1937161.html" target="_blank" rel="external">JSR 356, Java API for WebSocket</a></p>
<p>JSR 356是Java EE 7标准的一部分。</p>
<p>开源实现有：</p>
<ul>
<li>GlassFish</li>
<li>Jetty 9.1.+</li>
</ul>
<p>以下是一个典型的例子：<br><img src="http://otlnkjq1m.bkt.clouddn.com/server-client-sample.png" alt=""></p>
<p>服务端由Java实现，用JSR 356的一个实现来处理WebSocket协议的细节。<br>客户端中，JavaFX客户端可以依赖任何符合JSR 356的客户端来处理WebSocket协议，而其他客户端则可以使用符合RFC 6455的实现来与服务器通信。</p>
<p>兼容JSR 356的好处：</p>
<ul>
<li>防止供应商锁定（vendor-lock），可以自由地选择库和应用服务器</li>
</ul>
<p>JSR 356的缺点：</p>
<p><a href="https://books.google.com/books?id=EkBPDwAAQBAJ&amp;pg=PA282&amp;lpg=PA282&amp;dq=netty+jsr+356&amp;source=bl&amp;ots=9nbhtR3VEn&amp;sig=wVmL3ImgmRmE_69OCpHLHjrYv2c&amp;hl=zh-CN&amp;sa=X&amp;ved=0ahUKEwiYnY7rse3ZAhUMzGMKHX_kDBg4ChDoAQgvMAE#v=onepage&amp;q=netty%20jsr%20356&amp;f=false" target="_blank" rel="external">Learning Spring Boot 2.0: Simplify the development of lightning fast … - Greg L. Turnquist - Google 图书</a></p>
<ul>
<li>基于Servlet 3.1<br>  目前兼容Servlet 3.1的有tomcat，但是如果在使用Netty，则不兼容了<br>  <img src="http://otlnkjq1m.bkt.clouddn.com/not-suing-jsr356.png" alt=""></li>
<li>J2EE标准前景不太好<br>  J2EE标准发布比较慢，RFC6455在2011年12月就正式发布了，而相应的JSR 356却在2013年5月才发布，相应地，Jetty在2013年11月才发布对JSR 356支持的稳定版本，从RFC标准发布到JSR标准实现之间相距了2年。</li>
<li>考虑到在一般的场景下，WebSocket客户端都不是Java客户端，所以花费精力去适配JSR 356没必要，别的语言才不管J2EE的标准。</li>
</ul>
<h3 id="2-2-2-非Java-EE"><a href="#2-2-2-非Java-EE" class="headerlink" title="2.2.2 非Java EE"></a>2.2.2 非Java EE</h3><p>实现了RFC6455标准即可。</p>
<h1 id="3-Fallback"><a href="#3-Fallback" class="headerlink" title="3 Fallback"></a>3 Fallback</h1><p>目前主流的浏览器基本都支持WebSocket，但是，IE 10（不含10）以下的版本不支持，而这些版本的IE用户量还是不少的，因此需要有后备方案。</p>
<h2 id="3-1-sockjs"><a href="#3-1-sockjs" class="headerlink" title="3.1 sockjs"></a>3.1 sockjs</h2><p>项目主页：<br><a href="https://github.com/sockjs/sockjs-client" target="_blank" rel="external">https://github.com/sockjs/sockjs-client</a></p>
<ul>
<li>The API should follow HTML5 Websockets API as closely as possible.</li>
<li>All the transports must support cross domain connections out of the box. It’s possible and recommended to host a SockJS server on a different server than your main web site.</li>
<li>There is support for at least one streaming protocol for every major browser.</li>
<li>Streaming transports should work cross-domain and should support cookies (for cookie-based sticky sessions).</li>
<li>Polling transports are used as a fallback for old browsers and hosts behind restrictive proxies.</li>
<li>Connection establishment should be fast and lightweight.</li>
<li>No Flash inside (no need to open port 843 - which doesn’t work through proxies, no need to host ‘crossdomain.xml’, no need to wait for 3 seconds in order to detect problems)</li>
</ul>
<hr>
<ul>
<li>API尽量接近HTML5 WebSocket的API</li>
<li>开箱即用地对所有协议支持跨域连接，可以在主站点以外架设SockJS服务器，并且也推荐这样做。</li>
<li>对每个主流的浏览器至少支持一种streaming协议</li>
<li>流传输（streaming transports）应该能跨域工作，并且支持cookies（基于cookies的会话）</li>
<li>Polling传输作为一种后备方案，支持老版本的浏览器和被限制性代理所限制的主机</li>
<li>连接的建立应该是快速和轻量级的</li>
<li>不包含Flash（不必开启843端口）</li>
</ul>
<p>协议：<br><a href="http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html" target="_blank" rel="external">sockjs-protocol-0.3.3.py</a></p>
<p>在底层的实现上，SockJS会首先尝试使用原生的WebSocket，如果失败了，再根据浏览器来决定采取相应的传输协议。</p>
<blockquote>
<p>Under the hood SockJS tries to use native WebSockets first. If that fails it can use a variety of browser-specific transport protocols and presents them through WebSocket-like abstractions.</p>
</blockquote>
<p>Supported transports, by browser (html served from http:// or https://)</p>
<table>
<thead>
<tr>
<th>_Browser_</th>
<th>_Websockets_</th>
<th>_Streaming_</th>
<th>_Polling_</th>
</tr>
</thead>
<tbody>
<tr>
<td>IE 6, 7</td>
<td>no</td>
<td>no</td>
<td>jsonp-polling</td>
</tr>
<tr>
<td>IE 8, 9 (cookies=no)</td>
<td>no</td>
<td>xdr-streaming &dagger;</td>
<td>xdr-polling &dagger;</td>
</tr>
<tr>
<td>IE 8, 9 (cookies=yes)</td>
<td>no</td>
<td>iframe-htmlfile</td>
<td>iframe-xhr-polling</td>
</tr>
<tr>
<td>IE 10</td>
<td>rfc6455</td>
<td>xhr-streaming</td>
<td>xhr-polling</td>
</tr>
<tr>
<td>Chrome 6-13</td>
<td>hixie-76</td>
<td>xhr-streaming</td>
<td>xhr-polling</td>
</tr>
<tr>
<td>Chrome 14+</td>
<td>hybi-10 / rfc6455</td>
<td>xhr-streaming</td>
<td>xhr-polling</td>
</tr>
<tr>
<td>Firefox &lt;10</td>
<td>no &Dagger;</td>
<td>xhr-streaming</td>
<td>xhr-polling</td>
</tr>
<tr>
<td>Firefox 10+</td>
<td>hybi-10 / rfc6455</td>
<td>xhr-streaming</td>
<td>xhr-polling</td>
</tr>
<tr>
<td>Safari 5.x</td>
<td>hixie-76</td>
<td>xhr-streaming</td>
<td>xhr-polling</td>
</tr>
<tr>
<td>Safari 6+</td>
<td>rfc6455</td>
<td>xhr-streaming</td>
<td>xhr-polling</td>
</tr>
<tr>
<td>Opera 10.70+</td>
<td>no &Dagger;</td>
<td>iframe-eventsource</td>
<td>iframe-xhr-polling</td>
</tr>
<tr>
<td>Opera 12.10+</td>
<td>rfc6455</td>
<td>xhr-streaming</td>
<td>xhr-polling</td>
</tr>
<tr>
<td>Konqueror</td>
<td>no</td>
<td>no</td>
<td>jsonp-polling</td>
</tr>
</tbody>
</table>
<h1 id="4-实现"><a href="#4-实现" class="headerlink" title="4 实现"></a>4 实现</h1><h2 id="4-1-Netty"><a href="#4-1-Netty" class="headerlink" title="4.1 Netty"></a>4.1 Netty</h2><p><a href="http://netty.io/" target="_blank" rel="external">http://netty.io/</a></p>
<h2 id="4-2-Undertow"><a href="#4-2-Undertow" class="headerlink" title="4.2 Undertow"></a>4.2 Undertow</h2><p><a href="http://undertow.io/" target="_blank" rel="external">http://undertow.io/</a></p>
<h2 id="4-3-Jetty"><a href="#4-3-Jetty" class="headerlink" title="4.3 Jetty"></a>4.3 Jetty</h2><h2 id="4-4-Vert-x"><a href="#4-4-Vert-x" class="headerlink" title="4.4 Vert.x"></a>4.4 Vert.x</h2><p><a href="http://http//vertx.io" target="_blank" rel="external">http://http//vertx.io</a></p>
<h2 id="4-5-Spray-WebSocket"><a href="#4-5-Spray-WebSocket" class="headerlink" title="4.5 Spray-WebSocket"></a>4.5 Spray-WebSocket</h2><p><a href="https://github.com/dcaoyuan/spray-websocket" target="_blank" rel="external">https://github.com/dcaoyuan/spray-websocket</a></p>
<h2 id="4-6-nodejs-websocket"><a href="#4-6-nodejs-websocket" class="headerlink" title="4.6 nodejs-websocket"></a>4.6 nodejs-websocket</h2><p><a href="https://github.com/sitegui/nodejs-websocket" target="_blank" rel="external">https://github.com/sitegui/nodejs-websocket</a></p>
<h2 id="4-7-Grizzly"><a href="#4-7-Grizzly" class="headerlink" title="4.7 Grizzly"></a>4.7 Grizzly</h2><p><a href="https://javaee.github.io/grizzly/" target="_blank" rel="external">https://javaee.github.io/grizzly/</a></p>
<h2 id="4-8-Go"><a href="#4-8-Go" class="headerlink" title="4.8 Go"></a>4.8 Go</h2><h1 id="5-进一步封装的协议"><a href="#5-进一步封装的协议" class="headerlink" title="5 进一步封装的协议"></a>5 进一步封装的协议</h1><p><strong>为什么不直接使用WebSocket协议？</strong></p>
<ol>
<li>数据的解析是未定义的。<br> WebSocket支持text和binary两种传输数据格式，无论是哪种格式，客户端和服务器都需要约定如何包装、解析数据。因此在WebSocket协议的基础上，还需要再定义一层协议，客户端和服务端才能完成协作。</li>
<li>兼容Fallback方案。<br> 当WebSocket不能工作的时候（例如在IE 6上），采用后备方案实现消息推送，除了通信的实现方式改变之外，数据解析的协议应当保持不变。</li>
</ol>
<h2 id="5-1-STOMP"><a href="#5-1-STOMP" class="headerlink" title="5.1 STOMP"></a>5.1 STOMP</h2><blockquote>
<p>Simple (or Streaming) Text Orientated Messaging Protocol 的缩写。</p>
</blockquote>
<p>项目主页：<br><a href="http://stomp.github.io" target="_blank" rel="external">http://stomp.github.io</a></p>
<p>STOMP是基于帧的消息协议。</p>
<blockquote>
<p>A frame consists of a command, a set of optional headers and an optional body. It is an alternative to other open messaging protocols such as AMQP and implementation specific wire protocols used in JMS brokers such as OpenWire. </p>
<p>STOMP is text based but also allows for the transmission of binary messages. </p>
</blockquote>
<h3 id="5-1-1-采用STOMP的理由"><a href="#5-1-1-采用STOMP的理由" class="headerlink" title="5.1.1 采用STOMP的理由"></a>5.1.1 采用STOMP的理由</h3><ul>
<li>目前RabbitMQ和Spring都支持STOMP协议，表明STOMP已经是一个主流的消息协议之一，基于主流的协议，可以替换各种实现；</li>
<li>STOMP协议的帧格式比较简洁，由command + headers + body构成，各部分使用<code>EOL</code>进行划分，冗余字符较少，不会浪费带宽。（EOL（end-of-line，consists of an OPTIONAL carriage return (octet 13) followed by a REQUIRED line feed (octet 10)））</li>
<li>支持发布/订阅模型和事务<br>  每个STOMP客户端既可以作为生产者，也可以作为消费者</li>
</ul>
<h3 id="5-1-2-帧"><a href="#5-1-2-帧" class="headerlink" title="5.1.2 帧"></a>5.1.2 帧</h3><p>STOMP消息帧由以下部分组成：</p>
<ul>
<li>Command</li>
<li>Headers（Optional）</li>
<li>Body（Optional）</li>
</ul>
<p>示例：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">COMMAND</div><div class="line"><span class="symbol">header1:</span>value1</div><div class="line"><span class="symbol">header2:</span>value2</div><div class="line"></div><div class="line">Body^@</div></pre></td></tr></table></figure></p>
<h3 id="5-1-3-Heart-beating"><a href="#5-1-3-Heart-beating" class="headerlink" title="5.1.3 Heart-beating"></a>5.1.3 Heart-beating</h3><p>略。</p>
<h3 id="5-1-4-发布-订阅模型"><a href="#5-1-4-发布-订阅模型" class="headerlink" title="5.1.4 发布-订阅模型"></a>5.1.4 发布-订阅模型</h3><p>通过以下帧来控制：</p>
<ul>
<li>SUBSCRIBE</li>
<li>UNSUBSCRIBE</li>
</ul>
<p>在RFC 6455里，限制了一个客户端到一个host的连接数：</p>
<blockquote>
<p>If the client already has a WebSocket connection to the remote<br>       host (IP address) identified by /host/ and port /port/ pair, even<br>       if the remote host is known by another name, the client MUST wait<br>       until that connection has been established or for that connection<br>       to have failed.  There MUST be no more than one connection in a<br>       CONNECTING state.  If multiple connections to the same IP address<br>       are attempted simultaneously, the client MUST serialize them so<br>       that there is no more than one connection at a time running<br>       through the following steps.</p>
</blockquote>
<p>因此，如果直接利用原始的WebSocket全双工通信连接进行通信，在适配业务逻辑的时候很可能会耗费大量的工作，而通过发布-订阅模型，则可以复用同一个连接实现不同主题消息的分发</p>
<h3 id="5-1-5-事务"><a href="#5-1-5-事务" class="headerlink" title="5.1.5 事务"></a>5.1.5 事务</h3><p>通过以下帧来控制：</p>
<ul>
<li>ACK</li>
<li>NACK</li>
<li>BEGIN</li>
<li>COMMIT</li>
<li>ABORT</li>
</ul>
<h2 id="5-2-SocketIO"><a href="#5-2-SocketIO" class="headerlink" title="5.2 SocketIO"></a>5.2 SocketIO</h2><p><a href="https://github.com/socketio/socket.io-protocol" target="_blank" rel="external">socketio/socket.io-protocol: Socket.IO 1.0 Protocol specification and parser component / node.js module.</a></p>
<p>SocketIO实际上也定义了发布订阅模型。通过namespace来订阅不同的『主题』，namespace下继续划分room，，类似于二级主题。</p>
<h3 id="5-2-1-协议定义"><a href="#5-2-1-协议定义" class="headerlink" title="5.2.1 协议定义"></a>5.2.1 协议定义</h3><h3 id="5-2-2-实现"><a href="#5-2-2-实现" class="headerlink" title="5.2.2 实现"></a>5.2.2 实现</h3><h4 id="5-2-2-1-socket-io"><a href="#5-2-2-1-socket-io" class="headerlink" title="5.2.2.1 socket.io"></a>5.2.2.1 socket.io</h4><p><a href="https://github.com/socketio/socket.io/" target="_blank" rel="external">https://github.com/socketio/socket.io/</a></p>
<h4 id="5-2-2-2-netty-socketio"><a href="#5-2-2-2-netty-socketio" class="headerlink" title="5.2.2.2 netty-socketio"></a>5.2.2.2 netty-socketio</h4><p><a href="https://github.com/mrniko/netty-socketio" target="_blank" rel="external">https://github.com/mrniko/netty-socketio</a></p>
<h1 id="6-测试"><a href="#6-测试" class="headerlink" title="6 测试"></a>6 测试</h1><p><a href="https://github.com/crossbario/autobahn-testsuite" target="_blank" rel="external">https://github.com/crossbario/autobahn-testsuite</a></p>
<h1 id="7-FAQ"><a href="#7-FAQ" class="headerlink" title="7 FAQ"></a>7 FAQ</h1><h2 id="7-1-Socket和WebSocket有什么关系？"><a href="#7-1-Socket和WebSocket有什么关系？" class="headerlink" title="7.1 Socket和WebSocket有什么关系？"></a>7.1 Socket和WebSocket有什么关系？</h2><p>就像Java和JavaScript，并没有什么太大的关系，但又不能说完全没关系。</p>
<p>通常所说的<strong>Socket</strong> API，是指操作系统中（也可能不是操作系统）提供的对于传输层（TCP/UDP）抽象的接口。</p>
<p><strong>WebSocket</strong>是一种在单个TCP连接上进行全双工通讯的协议。</p>
<p><a href="http://blog.jobbole.com/106009/" target="_blank" rel="external">WebSocket这个名称的由来</a>：</p>
<blockquote>
<p>08年6月18日，一群WHATWG的工程师在讨论一些技术问题，一个工程师提到说「我们之前讨论的那个东西，不要叫TCPConnection 了，还是起个别的名字吧 」，接着几个名字被提及，DuplexConnection，TCPSocket，SocketConnection ，一个叫mcarter（Michael Carter ）的工程师说他马上要写一篇关于Comet的文章，如果可以确定这个名称，想在文章中引用这个名字。</p>
<p>Socket一直以来都被人用来表示网络中一个连接的两端，考虑到怎么让工程师更容易接受，后来Hixie说了一句「我看WebSocket这个名字就很适合嘛（Hixie briefly pops back online to record that “WebSocket” would probably be a good new name for the TCPConnection object）」，大家都没有异议，紧接着mcarter在Comet Daily中发表了文章<a href="http://cometdaily.com/2008/07/04/html5-websocket/index.html" target="_blank" rel="external">Independence Day: HTML5 WebSocket Liberates Comet From Hacks</a>，后来随着各大浏览器对WebSocket的支持，它变成了实际的标准，IETF也沿用了这个名字。</p>
</blockquote>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="http://colobu.com/2015/07/14/performance-comparison-of-7-websocket-frameworks/" target="_blank" rel="external">七种WebSocket框架的性能比较</a></li>
<li><a href="https://github.com/smallnest/C1000K-Servers" target="_blank" rel="external">smallnest/C1000K-Servers - GitHub</a></li>
<li><a href="http://colobu.com/2015/05/22/implement-C1000K-servers-by-spray-netty-undertow-and-node-js/" target="_blank" rel="external">使用四种框架分别实现百万websocket常连接的服务器</a></li>
<li><a href="https://en.wikipedia.org/wiki/WebSocket" target="_blank" rel="external">WebSocket - Wikipedia</a></li>
<li><a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="external">RFC 6455</a></li>
<li><a href="http://stomp.github.io" target="_blank" rel="external">STOMP</a></li>
<li><a href="http://jmesnil.net/stomp-websocket/doc/" target="_blank" rel="external">STOMP Over WebSocket</a></li>
<li><a href="http://stomp.github.io/stomp-specification-1.2.html" target="_blank" rel="external">STOMP Protocol Specification, Version 1.2</a></li>
<li><a href="https://github.com/sockjs/sockjs-client" target="_blank" rel="external">sockjs/sockjs-client</a></li>
<li><a href="http://blog.jobbole.com/106009/" target="_blank" rel="external">WebSocket 和 Socket 的区别 - 文章 - 伯乐在线</a></li>
<li><a href="http://cometdaily.com/2008/07/04/html5-websocket/index.html" target="_blank" rel="external">Comet Daily  » Blog Archive   » Independence Day: HTML5 WebSocket Liberates Comet From Hacks</a></li>
<li><a href="https://www.w3.org/TR/websockets/" target="_blank" rel="external">The WebSocket API</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1 概念&quot;&gt;&lt;/a&gt;1 概念&lt;/h1&gt;&lt;h2 id=&quot;1-1-comet&quot;&gt;&lt;a href=&quot;#1-1-comet&quot; class=&quot;headerlink&quot; title=&quot;1.1 comet&quot;&gt;&lt;/a&gt;1.1 comet&lt;/h2&gt;&lt;p&gt;天不生WS，万古如长夜。&lt;/p&gt;
&lt;p&gt;在WebSocket出现之前，服务端主动推送消息给浏览器的需求就已经存在了，但是HTTP这个协议本来就不是设计用来进行双向通信的，所以机智的工程师们采取了各种hack的方式来实现这种功能，这些实现方式都统称为&lt;code&gt;comet&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是无可避免地，这些技术都存在缺陷，既然WebSocket都出现了，那么这些技术大概也能进博物馆了，除了实现Fallback方案时需要去了解之外，这些技术感觉价值不大了，所以不展开说，如果读者有兴趣，可以根据关键词找资料去了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebSocket" scheme="http://bungder.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区域</title>
    <link href="http://bungder.github.io/2018/03/12/jvm-run-time-data-area/"/>
    <id>http://bungder.github.io/2018/03/12/jvm-run-time-data-area/</id>
    <published>2018-03-12T07:51:06.000Z</published>
    <updated>2018-03-13T05:08:57.049Z</updated>
    
    <content type="html"><![CDATA[<p>根据 <a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf" target="_blank" rel="external">The Java<sup>&reg;</sup> Virtual Machine Specification - Java SE 8 Edition</a>，可以整理出其定义的JVM内存结构如下：</p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/runtime2.png" alt=""><br>JVM Specification定义的运行时数据区域模型↑↑↑</p>
<p>其中，方法区所属的区域并没有强制要求。不同的JVM实现，其内存分布细节会不同。</p>
<a id="more"></a>
<h1 id="1-PCR（程序计数寄存器-The-Program-Counter-Register）"><a href="#1-PCR（程序计数寄存器-The-Program-Counter-Register）" class="headerlink" title="1 PCR（程序计数寄存器 The Program Counter Register）"></a>1 PCR（程序计数寄存器 The Program Counter Register）</h1><blockquote>
<p>The Java Virtual Machine can support many threads of execution at once (JLS §17). Each Java Virtual Machine thread has its own pc (program counter) register. At any point, each Java Virtual Machine thread is executing the code of a single method, namely the $current method$ (§2.6) for that thread. </p>
<ul>
<li>If that method is <strong>not native</strong>, the pc register contains the <strong>address</strong> of the Java Virtual Machine instruction currently being executed. </li>
<li>If the method currently being executed by the thread is <strong>native</strong>, the value of the Java Virtual Machine’s pc register is <strong>undefined</strong>. The Java Virtual Machine’s pc register is wide enough to hold a returnAddress or a native pointer on the specific platform.</li>
</ul>
</blockquote>
<h1 id="2-JVM-Stack"><a href="#2-JVM-Stack" class="headerlink" title="2 JVM Stack"></a>2 JVM Stack</h1><h2 id="2-1-Frames-栈帧"><a href="#2-1-Frames-栈帧" class="headerlink" title="2.1 Frames 栈帧"></a>2.1 Frames 栈帧</h2><blockquote>
<p>A $frame$ is used to store data and partial results, as well as to perform dynamic linking, return values for methods, and dispatch exceptions.</p>
<p><strong>A new frame is created each time a method is invoked</strong>. <strong>A frame is destroyed when its method invocation completes, whether that completion is normal or abrupt</strong> (it throws an uncaught exception). Frames are <strong>allocated from the Java Virtual Machine stack (§2.5.2) of the thread creating the frame</strong>. Each frame has its own <strong>array of local variables</strong> (§2.6.1), its own <strong>operand stack</strong> (§2.6.2), and <strong>a reference to the run- time constant pool (§2.5.5) of the class of the current method</strong>.<br>The sizes of the local variable array and the operand stack are determined at compile-time and are supplied along with the code for the method associated with the frame (§4.7.3). Thus the size of the frame data structure depends only on the implementation of the Java Virtual Machine, and the memory for these structures can be allocated simultaneously on method invocation.<br>Only one frame, the frame for the executing method, is active at any point in a given thread of control. This frame is referred to as the $current frame$, and its method is known as the $current method$. The class in which the current method is defined is the $current class$. Operations on local variables and the operand stack are typically with reference to the current frame.<br>A frame <strong>ceases to be current</strong> if its method <strong>invokes another method</strong> or if its <strong>method completes</strong>. When a method is invoked, a new frame is created and becomes current when control transfers to the new method. On method return, the current frame passes back the result of its method invocation, if any, to the previous frame. The current frame is then discarded as the previous frame becomes the current one.<br>Note that a frame created by a thread is local to that thread and cannot be referenced by any other thread.</p>
</blockquote>
<h3 id="2-1-1-Local-Variables-本地变量表"><a href="#2-1-1-Local-Variables-本地变量表" class="headerlink" title="2.1.1 Local Variables 本地变量表"></a>2.1.1 Local Variables 本地变量表</h3><p>A <strong>single</strong> local variable can hold a value of type </p>
<ul>
<li>boolean, </li>
<li>byte, </li>
<li>char, </li>
<li>short, </li>
<li>int, </li>
<li>float, </li>
<li>reference</li>
<li>returnAddress. </li>
</ul>
<p>A <strong>pair</strong> of local variables can hold a value of type <strong>long</strong> or <strong>double</strong>.</p>
<p>本地变量表通过索引来处理，第一个本地变量的下标（index）为0.</p>
<blockquote>
<p>The Java Virtual Machine uses local variables to pass parameters on method invocation. On class method invocation, any parameters are passed in consecutive local variables starting from local variable 0. On instance method invocation, local variable 0 is always used to pass a reference to the object on which the instance method is being invoked (<code>this</code> in the Java programming language). Any parameters are subsequently passed in consecutive local variables starting from local variable 1.</p>
</blockquote>
<p>Java虚拟机使用局部变量在方法调用上传递参数。 在<strong>类方法</strong>（静态方法）调用中，任何参数都是<strong>从局部变量0开始</strong>的连续局部变量中传递的。在<strong>实例方法</strong>调用中，局部变量0用于将引用（<code>this</code>）传递给调用者。 随后从局部变量1开始，连续的局部变量传递任何参数。</p>
<h3 id="2-1-2-Operand-Stacks-操作数栈"><a href="#2-1-2-Operand-Stacks-操作数栈" class="headerlink" title="2.1.2 Operand Stacks 操作数栈"></a>2.1.2 Operand Stacks 操作数栈</h3><blockquote>
<p>The maximum depth of the operand stack of a frame is determined at compile-time and is supplied along with the code for the method associated with the frame</p>
</blockquote>
<p>用处：</p>
<blockquote>
<p>The operand stack is empty when the frame that contains it is created. The Java Virtual Machine supplies instructions to <strong>load constants or values from local variables or fields onto the operand stack</strong>. Other Java Virtual Machine instructions <strong>take operands from the operand stack, operate on them, and push the result back onto the operand stack</strong>. The operand stack is also used to <strong>prepare parameters to be passed to methods</strong> and to <strong>receive method results</strong>.</p>
</blockquote>
<h3 id="2-1-3-Return-Value"><a href="#2-1-3-Return-Value" class="headerlink" title="2.1.3 Return Value"></a>2.1.3 Return Value</h3><h3 id="2-1-4-Dynamic-Linking"><a href="#2-1-4-Dynamic-Linking" class="headerlink" title="2.1.4 Dynamic Linking"></a>2.1.4 Dynamic Linking</h3><blockquote>
<p>Each frame (§2.6) contains <strong>a reference to the run-time constant pool</strong> (§2.5.5) for the type of the current method to support $dynamic linking$ of the method code. The class file code for a method refers to methods to be invoked and variables to be accessed via symbolic references. Dynamic linking translates these symbolic method references into concrete method references, loading classes as necessary to resolve as-yet-undefined symbols, and translates variable accesses into appropriate offsets in storage structures associated with the run-time location of these variables.</p>
</blockquote>
<p><a href="http://ifeve.com/jvm-internals/" target="_blank" rel="external">JVM内部原理</a>:</p>
<blockquote>
<p><strong>每个栈帧都包含了运行时常量池的引用</strong>。这个引用指向了这个栈帧正在执行的方法所在的类的常量池，它对动态链接提供了支持。</p>
<p>C/C++ 代码通常编译成一个对象文件，然后多个文件被链接起来生成一个可用的文件比如一个可执行文件或者动态链接库。在链接阶段，符号引用在每个对象文件里被替换成一个和最终执行相关的实际的内存地址。在Java里，这个链接过程在运行时是自动发生的。</p>
<p>当Java文件被编译时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。一个符号引用是一个逻辑引用并不是一个实际的指向一个物理内存地址的引用。不同的JVM实现能选择什么时候去解决符号引用，它通常发生在class文件加载后的验证，加载完成，立即调用或者静态解析等阶段，另外一种发生的时候是当符号引用第一次被使用，也叫做延迟或者延期解析。无论如何当每个引用第一次使用的时候，JVM必须保证解析发生，并抛出任何解析错误。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程</strong>，这仅仅发生一次，因为符号引用是完全替换的。如果符号引用关联到某个类，而这个类却还没准备好，就会引发类加载。每个直接引用被保存为偏移地址而不是和变量或者方法在运行时的位置相关的存储结构。</p>
</blockquote>
<h1 id="3-Heap-堆"><a href="#3-Heap-堆" class="headerlink" title="3 Heap 堆"></a>3 Heap 堆</h1><blockquote>
<p>The Java Virtual Machine has a heap that is <strong>shared among all Java Virtual Machine threads</strong>. The heap is the <strong>run-time data area from which memory for all class instances and arrays is allocated</strong>.<br>…<br><strong>Heap storage for objects is reclaimed by</strong> an automatic storage management system (known as a <strong>garbage collector</strong>); objects are never explicitly deallocated.</p>
</blockquote>
<p><a href="https://www.zhihu.com/question/49044988/answer/113961406" target="_blank" rel="external">https://www.zhihu.com/question/49044988/answer/113961406</a> 评论里：</p>
<blockquote>
<p>如果“堆”是说<strong>Java heap</strong>，那么这个也对也错。因为JVM规范对抽象的“Java heap”的定义是“存储Java对象的地方”，也就是说Java对象在哪里，哪里就是Java heap。HotSpot的PermGen里是会存储部分Java对象的，例如说一些java.lang.String实例。这些String实例占的部分就得算是Java heap。</p>
<p>如果“堆”是说<strong>GC heap</strong>，那么这个错误。<strong>PermGen是HotSpot的GC heap的一部分</strong>。</p>
<p>一般说“native memory”都是跟GC heap相对的，所以一般取上述后者的定义</p>
</blockquote>
<h1 id="4-Method-Area"><a href="#4-Method-Area" class="headerlink" title="4 Method Area"></a>4 Method Area</h1><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf" target="_blank" rel="external">The Java<sup>&reg;</sup> Virtual Machine Specification - Java SE 8 Edition</a>:</p>
<blockquote>
<p>The Java Virtual Machine has a method area that <strong>is shared among all Java Virtual Machine threads</strong>.</p>
<p>It stores per-class structures such as the <strong>run-time constant pool</strong>, <strong>field</strong> and <strong>method data</strong>, and <strong>the code for methods and constructors</strong>, including the special methods (§2.9) used in class and instance initialization and interface initialization.</p>
</blockquote>
<hr>
<blockquote>
<p>Although the method area is logically part of the heap, simple implementations may choose not to either garbage collect or compact it. This specification does not mandate the location of the method area or the policies used to manage compiled code.</p>
</blockquote>
<p>尽管方法区域在逻辑上是堆的一部分，但是简单的实现可以选择不垃圾收集或压缩它。 本规范不要求方法区域的位置或用于管理编译代码的策略</p>
<hr>
<h2 id="4-1-Run-Time-Const-Pool"><a href="#4-1-Run-Time-Const-Pool" class="headerlink" title="4.1 Run-Time Const Pool"></a>4.1 Run-Time Const Pool</h2><blockquote>
<p>A run-time constant pool is a <strong>per-class or per-interface</strong> run-time representation of the constant_pool table in a class file.<br>…<br>The run-time constant pool for a class or interface <strong>is constructed when the class or interface is created</strong> (§5.3) by the Java Virtual Machine.</p>
</blockquote>
<p>根据上面这段引用，可知以下几点：</p>
<ol>
<li>每个类（或者interface，为便于行文，下面都统称为类）对应一个run-time constant pool</li>
<li>是class文件中constant_pool的运行时表达</li>
<li>在类被JVM加载时创建</li>
</ol>
<p>那么，要理清其结构，需要先了解class文件的结构。可参见我的另一篇博文：<a href="/2018/03/10/java-class-file-format/">Java class文件格式</a></p>
<p style="color:red;font-weight:bold">其余具体的存储结构，JVM规范并没有作进一步阐述。</p>

<h2 id="4-2-Field"><a href="#4-2-Field" class="headerlink" title="4.2 Field"></a>4.2 Field</h2><p style="color:red;font-weight:bold">具体的存储结构，JVM规范并没有作进一步阐述。</p>

<h2 id="4-3-Method-Data"><a href="#4-3-Method-Data" class="headerlink" title="4.3 Method Data"></a>4.3 Method Data</h2><p style="color:red;font-weight:bold">具体的存储结构，JVM规范并没有作进一步阐述。</p>

<h2 id="4-4-Code"><a href="#4-4-Code" class="headerlink" title="4.4 Code"></a>4.4 Code</h2><p style="color:red;font-weight:bold">具体的存储结构，JVM规范并没有作进一步阐述。</p>

<h1 id="5-Native-Method-Stacks"><a href="#5-Native-Method-Stacks" class="headerlink" title="5 Native Method Stacks"></a>5 Native Method Stacks</h1><blockquote>
<p>Java Virtual Machine implementations that cannot load native methods and that do not themselves rely on conventional stacks need not supply native method stacks. If supplied, <strong>native method stacks are typically allocated per thread when each thread is created</strong>.</p>
</blockquote>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="http://ifeve.com/jvm-internals/" target="_blank" rel="external">JVM内部原理 | 并发编程网 – ifeve.com</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf" target="_blank" rel="external">The Java<sup>&reg;</sup> Virtual Machine Specification - Java SE 8 Edition</a></li>
<li><a href="http://openjdk.java.net/jeps/122" target="_blank" rel="external">JEP 122: Remove the Permanent Generation</a></li>
<li><a href="https://www.zhihu.com/question/49044988/answer/113961406" target="_blank" rel="external">方法区的Class信息,又称为永久代,是否属于Java堆？ - 知乎</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The Java&lt;sup&gt;&amp;reg;&lt;/sup&gt; Virtual Machine Specification - Java SE 8 Edition&lt;/a&gt;，可以整理出其定义的JVM内存结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://otlnkjq1m.bkt.clouddn.com/runtime2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;JVM Specification定义的运行时数据区域模型↑↑↑&lt;/p&gt;
&lt;p&gt;其中，方法区所属的区域并没有强制要求。不同的JVM实现，其内存分布细节会不同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://bungder.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="http://bungder.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM加载、启动和初始化</title>
    <link href="http://bungder.github.io/2018/03/10/jvm-loading-linking-initializing/"/>
    <id>http://bungder.github.io/2018/03/10/jvm-loading-linking-initializing/</id>
    <published>2018-03-09T17:08:12.000Z</published>
    <updated>2018-03-12T08:01:51.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0 概述"></a>0 概述</h1><p>这实际上是<a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf" target="_blank" rel="external">《The Java<sup>&reg;</sup> Virtual Machine Specification - Java SE 8 Edition》</a>中第五章内容（Loading, Linking, and Initializing）的部分翻译。主要目的是整理阅读笔记，让我自己看得明白，在这个前提下，尽量让别人看得明白，如果读者觉得我写得很混乱，还请自行阅读原文，不便之处敬请见谅。如有错误，还请指正（拉到页面底部点击『联系我』就可以发邮件给我）。</p>
<p>阅读本文内容需要先对java的class文件结构有所了解。如果尚不了解，不妨参考我的另一篇博文 <a href="/2018/03/10/java-class-file-format/">Java class文件格式</a></p>
<hr>
<ul>
<li><strong>加载</strong>是这样一个过程：寻找一个特定名称的class或者interface的二进制表达形式（binary representation），然后从这个二进制表达形式中创建出一个class或者interface。</li>
<li><strong>链接</strong>是这样一个过程：取得class或者interface，然后将其结合到JVM的运行时状态，使得它可以被执行。</li>
<li><strong>初始化</strong>一个class或者interface的过程就是执行这个class或者interface的初始化方法<code>&lt;clinit&gt;</code>的过程。</li>
</ul>
<a id="more"></a>
<h1 id="1-运行时常量池（Run-Time-Constant-Pool）"><a href="#1-运行时常量池（Run-Time-Constant-Pool）" class="headerlink" title="1 运行时常量池（Run-Time Constant Pool）"></a>1 运行时常量池（Run-Time Constant Pool）</h1><p>在class或interface被创建的时候，用二进制形式的class文件中的<code>constant_pool</code>表来构造运行时常量池。运行时常量池中的所有引用最初都是符号引用。运行时常量池中的符号引用来自二进制表达形式中的以下结构：</p>
<table>
<thead>
<tr>
<th>Symbolic Reference to</th>
<th>Structure in class file</th>
</tr>
</thead>
<tbody>
<tr>
<td>class</td>
<td>CONSTANT_Class_info</td>
</tr>
<tr>
<td>field</td>
<td>CONSTANT_Fieldref_info</td>
</tr>
<tr>
<td>class method</td>
<td>CONSTANT_Methodref_info</td>
</tr>
<tr>
<td>interface method</td>
<td>CONSTANT_InterfaceMethodref_info</td>
</tr>
<tr>
<td>method handle</td>
<td>CONSTANT_MethodHandle_info</td>
</tr>
<tr>
<td>method type</td>
<td>CONSTANT_MethodType_info</td>
</tr>
<tr>
<td>call site specifier</td>
<td>CONSTANT_InvokeDynamic_info</td>
</tr>
</tbody>
</table>
<p>另外，某些不是符号引用的运行时值则来自<code>constant_pool</code>表中的以下结构：</p>
<ul>
<li>字符串字面量  <code>CONSTANT_String_info</code></li>
<li>运行时常量值 <code>CONSTANT_Integer_info</code> <code>CONSTANT_Float_info</code> <code>CONSTANT_Long_info</code> <code>CONSTANT_Double_info</code></li>
</ul>
<p><code>constant_pool</code>里剩下的结构则只会被间接使用：</p>
<ul>
<li><code>CONSTANT_NameAndType_info</code></li>
<li><code>CONSTANT_Utf8_info</code></li>
</ul>
<h1 id="2-JVM启动"><a href="#2-JVM启动" class="headerlink" title="2 JVM启动"></a>2 JVM启动</h1><p>JVM通过使用引导类加载器（<strong>bootstrap class loader</strong>）创建初始类来启动，初始类的指定方式与实现相关。</p>
<p>然后，JVM链接初始类，初始化它，并调用<code>public static void main(String[])</code>方法。此方法的调用将驱动所有进一步的执行。执行构成 main 方法的JVM指令可能会导致附加类和接口的链接（链接之后进而创建），以及调用其他方法。</p>
<p>在JVM的实现中，初始类可以作为命令行参数提供。或者， JVM的实现可以提供一个初始类来设置类加载程序，然后加载一个应用程序。可以选择其他初始类，只要它们与前一段中给出的规范一致即可。</p>
<h1 id="3-创建和加载（Creation-and-Loading）"><a href="#3-创建和加载（Creation-and-Loading）" class="headerlink" title="3 创建和加载（Creation and Loading）"></a>3 创建和加载（Creation and Loading）</h1><p><span id="creationAndLoading"></span></p>
<h2 id="符号约定"><a href="#符号约定" class="headerlink" title="符号约定"></a>符号约定</h2><p>class或者interface $C$ 用其类名 $N$ 来表示，其创建过程由另一个class or interface $D$ 触发，$D$通过运行时常量池引用$C$。class or interface的创建也可以通过$D$调用Java SE平台的特定class libraries中的方法来触发，例如反射。</p>
<p>如果$C$不是数组类，则通过使用class loader加载$C$的二进制表达来创建。</p>
<p>数组类没有外部的二进制表达，由JVM来创建，而不是class loader。</p>
<p>类加载器 $L$可以通过以下两种方式来创建$C$：</p>
<ul>
<li>直接定义$C$    </li>
<li>委托给另一个class loader</li>
</ul>
<p>如果$L$委托了另一个class loader来加载$C$，则说$L$启动了$C$的加载（$L$ <em>initiates loading of</em> $C$），或者等价地说，$L$是$C$的<code>initiating loader</code>。$N^L$ 表示由$L$ initiates loading的$C$。</p>
<p>如果$L$直接创建$C$，则我们说$L$定义了$C$（$L$ <em>defines</em> $C$），或者等价地说，$L$是$C$的 <code>defining loader</code>。&lt;$N, L$&gt; 表示由$L$ defines的$C$。同时，$L$也是$C$的<code>initiating loader</code>。</p>
<h2 id="3-1-用Bootstrap-Class-Loader加载"><a href="#3-1-用Bootstrap-Class-Loader加载" class="headerlink" title="3.1 用Bootstrap Class Loader加载"></a>3.1 用Bootstrap Class Loader加载</h2><p>下面的步骤用于加载、从而创建由$N$表示的、非数组类型的类或者接口$C$。</p>
<ol>
<li><p>首先，JVM判断bootstrap class loader是否已经被标记为由$N$表示的类或接口的initiating loader。如果是，这个类或者接口就是$C$，后续没有创建过程。</p>
<p> 否则，JVM将$N$作为参数来调用bootstrap class loader的方法，用平台依赖的方式来搜索给出的$C$的表达形式。</p>
<p> 通常，类或接口会使用分层文件系统中的文件来表达，并且其名称会编码在文件的路径名（pathname）中。</p>
<p> 这个阶段需要检查以下错误：</p>
<ul>
<li>如果找不到给出的$C$的表达形式，抛出<code>ClassNotFoundException</code></li>
</ul>
</li>
<li><p>然后，JVM尝试使用<a href="TBD">加载算法</a>，从给出的表达形式中取得$N$表示的类，将结果作为$C$。</p>
</li>
</ol>
<h2 id="3-2-用User-defined-Class-Loader加载"><a href="#3-2-用User-defined-Class-Loader加载" class="headerlink" title="3.2 用User-defined Class Loader加载"></a>3.2 用User-defined Class Loader加载</h2><p>下面的步骤用于使用<strong>用户定义的类加载器（user-defined class loader）</strong> $L$加载、从而创建由$N$表示的、非数组类型的类或者接口$C$。</p>
<ol>
<li>首先，JVM判断$L$是否已经被标记为由$N$表示的类或接口的initiating loader。如果是，这个类或者接口就是$C$，后续没有创建过程。</li>
<li>否则，JVM调用$L$的<code>loadClass(N)</code>方法，这个调用的返回值就是创建后的类或接口$C$。</li>
<li>然后JVM将$L$记录为$C$的initiating loader。</li>
</ol>
<p>当使用$N$来调用$L$的<code>loadClass</code>方法时，$L$必须执行以下两个操作之一来加载$C$：</p>
<ol>
<li>$L$可以创建一个byte数组，这个数组表达了$C$的<code>ClassFile</code>结构；然后它必须调用<code>ClassLoader</code>类的<code>defineClass</code>方法，执行这个方法使得JVM用$L$使用<a href="TBD">加载算法</a>从byte数组中取得$C$。</li>
<li>$L$可以将加载过程委托给另一个类加载器$L’$，将参数$N$直接或者间接地传给$L’$的方法调用（一般是<code>loadClass</code>方法）。方法调用的结果是$C$。</li>
</ol>
<p>在上述两个步骤中，无论处于任何原因无法加载$N$所表示的类或接口时，都必须抛出<code>ClassNotFoundException</code>。</p>
<h2 id="3-3-创建数组类（Array-Classes）"><a href="#3-3-创建数组类（Array-Classes）" class="headerlink" title="3.3 创建数组类（Array Classes）"></a>3.3 创建数组类（Array Classes）</h2><p>下面的步骤用于使用类加载器$L$来加载、从而创建由$N$表示的、数组类型的类$C$。</p>
<p>如果$L$已被记录为与$N$相同的组件类型（component type）的数组类的initiating loader，则该类为$C$，并且不需要再进行任何数组类创建。</p>
<p>否则，执行下面的步骤来创建$C$：</p>
<ol>
<li>如果组件类型是引用类型（reference type），则使用$L$递归地应用<a href="#creationAndLoading">本节的算法</a>，以加载、从而创建$C$的组件类型；</li>
<li>JVM使用指定的组件类型和维数创建一个新的数组类。<ul>
<li>如果组件类型是一个引用类型，$C$会被标记为 『已被组件类型的defining class loader定义了』（<em>having been defined by the defining class loader of the component type</em>）。否则，$C$会被标记为『已被bootstrap class loader定义了』（<em>having been defined by the bootstrap class loader</em>）。</li>
<li>无论如何，JVM都会将$L$记录为$C$的initiating loader。</li>
<li>如果组件类型是一个引用类型，那么这个数组类的可见性（accessibility）和组件类型一致，否则可见性为<code>public</code></li>
</ul>
</li>
</ol>
<h2 id="3-4-加载的约束"><a href="#3-4-加载的约束" class="headerlink" title="3.4 加载的约束"></a>3.4 加载的约束</h2><p>在class loader出现的时候，确保类型安全链接要特别小心。有可能存在这样一种情况：两个不同的class loader触发了由$N$表示的class or interface的加载，而$N$在每个class loader里可能表示了不同的class or interface。</p>
<p style="color:red;font-size:30px;font-weight:BOLD">（TBD）</p>

<h2 id="3-5-从class文件表达形式中获得Class"><a href="#3-5-从class文件表达形式中获得Class" class="headerlink" title="3.5 从class文件表达形式中获得Class"></a>3.5 从class文件表达形式中获得<code>Class</code></h2><p>将一个非数组类型的class或者interface $C$ 记为 $N$，下面是用loader $L$从class文件格式中加载$C$为Class对象的步骤：</p>
<ol>
<li>JVM判断$L$是否已经被标记为$N$的initiating loader，如果是，创建过程将不可用，并且抛出<code>LinkageError</code></li>
<li>否则，JVM尝试解析给出的表达。但是，给出的表达不一定是$C$的一个有效的表达。这个加载阶段必须检查以下错误：<ul>
<li>如果给出的表达形式不是<code>ClassFile</code>结构，抛出<code>ClassFormatError</code></li>
<li>否则，如果给出的表达不在支持的版本范围内（major version和minor version），抛出<code>UnsupportedClassVersionError</code></li>
<li>否则，如果给出的表达不是类名$N$的实际表达，抛出<code>NoClassDefFoundError</code>或者其子类</li>
</ul>
</li>
<li>如果$C$有直接父类，就用<a href="#ClassAndInterfaceResolution">Class and Interface Resolution</a>算法来解析出$C$到其直接父类的符号链接。<br> 这个阶段要检查以下错误：<ul>
<li>如果其直接父类实际上是一个interface，抛出<code>IncompatibleClassChangeError</code></li>
<li>否则，如果$C$任意父类是$C$本身，抛出<code>ClassCircularityError</code></li>
</ul>
</li>
<li>如果$C$有任何直接父接口，则使用 <a href="#ClassAndInterfaceResolution">Class and Interface Resolution</a> 算法来解析出$C$到其直接父接口的符号链接。<br> 这个阶段要检查以下错误：<ul>
<li>如果其直接父接口实际上不是一个interface，抛出<code>IncompatibleClassChangeError</code></li>
<li>如果$C$的任何一个父接口是$C$本身，抛出<code>ClassCircularityError</code></li>
</ul>
</li>
<li>JVM将$C$标记为拥有$L$作为其defining class loader，并且标记$L$是$C$的initiating loader</li>
</ol>
<h1 id="4-链接（Linking）"><a href="#4-链接（Linking）" class="headerlink" title="4 链接（Linking）"></a>4 链接（Linking）</h1><p>链接一个class或者interface包括<strong>验证</strong>和<strong>准备</strong>阶段，涉及到的对象有：</p>
<ul>
<li>该class或interface本身</li>
<li>其直接父类</li>
<li>其直接父接口</li>
<li>如果这是数组类型，还涉及其元素类型</li>
</ul>
<p>解析class或interface中的符号链接是链接阶段可选的一部分。</p>
<p>该规范允许实现的灵活性，以便在链接活动（以及由于递归、加载）发生时，只要保持以下所有属性：</p>
<ul>
<li>一个class或interface在链接前要被完全加载</li>
<li>一个class或interface在初始化前要被完全验证</li>
<li>程序执行的一些操作可能直接或间接地要求链接涉及错误的class或interface，当这些错误被检测到时，必须在发生这些操作的地方抛出这些错误。</li>
</ul>
<p>例如，一个JVM实现可能选择在使用到一个class或interface的时候才去解析其中的每个符号链接（懒加载或者延迟加载，”lazy” or “late” resolution），或者在验证class的时候一次性解析其中所有的符号链接（”eager” or “static” resolution）。这意味着在某些实现中，在class或interface初始化之后还有可能继续执行解析过程。无论采用哪种策略，在解析期间检测到的任何错误都必须在程序中的使用对class或interface的符号引用的地方抛出，不论是直接还是间接地使用到。</p>
<p>由于链接阶段涉及到新数据结构的分配（allocation），有可能因<code>OutOfMEmoryError</code>而失败。</p>
<h2 id="4-1-验证（Verification）"><a href="#4-1-验证（Verification）" class="headerlink" title="4.1 验证（Verification）"></a>4.1 验证（Verification）</h2><p>验证阶段确保了class或interface的二进制表达在结构上是正确的。验证阶段有可能引起其他类或接口被加载，但是不需要导致它们被验证或者准备。</p>
<p>如果class或interface的二进制表达不满足<a href="/2018/03/10/java-class-file-format/#ConstraintsOnJavaVirtualMachineCode">The class File Format - Constraints on Java Virtual Machine Code</a>中列出的静态约束或结构型约束，那么在程序中导致class或interface被校验的地方必须要抛出<code>VerifyError</code>。</p>
<p>如果因为抛出了LinkageError（或子类）实例错误导致JVM尝试验证class或interface失败，则随后尝试验证class或interface始终会失败，并抛出相同的错误 作为初步验证尝试的结果。</p>
<h2 id="4-2-准备（Preparation）"><a href="#4-2-准备（Preparation）" class="headerlink" title="4.2 准备（Preparation）"></a>4.2 准备（Preparation）</h2><p>准备阶段包括创建class or interface的static fields，并初始化默认值。这个过程不需要执行任何JVM代码。静态字段的显式初始值设定是作为初始化的一部分执行，而不是准备阶段。</p>
<p>在class or interface $C$ 的准备阶段，JVM有以下约束：</p>
<p>令$L_1$为$C$的defining loader，$m$为$C$中覆盖自父类或者父接口&lt;$D, L_2$&gt;的方法，对于每个$m$，令其返回值为$T_r$，形参为$T_{f_1},…,T_{f_n}$，那么：</p>
<ul>
<li>如果$T_r$不是数组类型，令$T_0$为$T_r$；否则令$T_0$为$T_r$的元素类型；</li>
<li>对于$i=1, …, n$，如果$T_{f_i}$不是数组类型，令$T_i$为$T_{f_i}$；否则令$T_i$为$T_{f_i}$的元素类型</li>
</ul>
<p>则有：<br>$$ {T_i}^{L_1} = {T_i}^{L_2}, i=0, …, n $$</p>
<p>更进一步的情况，如果$C$实现了父接口&lt;$I, L_3$&gt;中的方法$m$，但是$C$没有声明方法$m$，但是$C$的父类&lt;$D, L_2$&gt;声明了方法$m$的实现，则有以下约束：</p>
<p>$m$的返回类型记为$T_r$，$m$的形参类型记为$T_{f1}, …, T_{fn}$，则：<br>如果$T_r$不是数组类型，令$T_0$为$T_r$，否则令$T_0$为$T_r$的元素类型（element type）。<br>对于所有$i=0, …, n$：如果$T_{fi}$不是数组类型，则$T_i$为$T_{fi}$，否则$T_i$为$T_{fi}$的元素类型。<br>那么有<br>$$ {T_i}^{L_2}={T_i}^{L_3}, i=0, …, n $$</p>
<h2 id="4-3-解析（Resolution）"><a href="#4-3-解析（Resolution）" class="headerlink" title="4.3 解析（Resolution）"></a>4.3 解析（Resolution）</h2><p>以下JVM指令对运行时常量池做了符号引用，执行任何这些指令都需要解析其符号引用：<br><code>anewarray</code>, <code>checkcast</code>, <code>getfield</code>, <code>getstatic</code>, <code>instanceof</code>, <code>invokedynamic</code>, <code>invokeinterface</code>, <code>invokespecial</code>, <code>invokestatic</code>, <code>invokevirtual</code>, <code>ldc</code>, <code>ldc_w</code>, <code>multianewarray</code>, <code>new</code>, <code>putfield</code>, and <code>putstatic</code>。</p>
<p>解析是从运行时常量池中的符号引用中动态确定具体值的过程。</p>
<p>解析某次出现的invokedynamic指令中的符号引用并不意味着该符号引用对于其它任何invokedynamic指令来说都被解析了。</p>
<p>对于其他指令来说，解析了某次出现的指令中的符号引用，确实意味着该符号应用对于其他任意的非invokedynamic指令来说都视为被解析了。</p>
<p>上文的意思是，由一个特定的invokedynamic指令确定的具体值是一个绑定到该特定invokedynamic指令的<code>call site object</code>。</p>
<p style="color:red;font-size:30px;font-weight:BOLD">（TBD）</p>

<p>下面部分阐述对一个class或interface $D$所引用的、尚在运行时常量池中的符号引用的解析过程。符号引用的类型不同，解析的细节也不同。</p>
<h3 id="4-3-1-Class-and-Interface-Resolution-类和接口解析"><a href="#4-3-1-Class-and-Interface-Resolution-类和接口解析" class="headerlink" title="4.3.1 Class and Interface Resolution 类和接口解析"></a>4.3.1 Class and Interface Resolution 类和接口解析</h3><p><span id="ClassAndInterfaceResolution"></span></p>
<p>执行以下步骤来将$D$所引用的、未解析的符号引用解析为由$N$表示的class或interface $C$：</p>
<ol>
<li>用$D$的defining class loader来创建由$N$表示的class或interface，细节在<a href="#creationAndLoading">第三节（Creation and Loading）</a>给出了。<br> 在创建过程中抛出的任何作为失败结果的exception都可以作为解析过程的失败结果抛出。</li>
<li>如果$C$是数组类并且其元素类型是一个引用类型，则递归地调用<a href="#ClassAndInterfaceResolution">上一小节（Class and Interface Resolution）</a>中的算法来解析其元素类型的符号引用。</li>
<li>最后，检查$C$的访问授权：<ul>
<li>如果$C$不能被$D$访问，抛出<code>IllegalAccessError</code><br>  这种情况举例：如果$C$这个类本来是被声明为public的，但是在$D$编译完之后被改为了非public了。</li>
</ul>
</li>
</ol>
<p>如果第1、2步成功执行但是第3步失败了，$C$仍然是有效和可用的。尽管如此，这个解析过程也是失败了的，并且$D$也禁止访问$C$。</p>
<h3 id="4-3-2-Field-Resolution-字段解析"><a href="#4-3-2-Field-Resolution-字段解析" class="headerlink" title="4.3.2 Field Resolution 字段解析"></a>4.3.2 Field Resolution 字段解析</h3><p>为了将$D$中未解析的符号引用解析为一个class或interface $C$中的一个字段（field），由字段引用（field reference）给出的到$C$的符号引用必须首先被解析（<a href="#ClassAndInterfaceResolution">4.3.1</a>）。</p>
<p>在解析字段引用的时候，字段解析（field resolution）首先尝试查找在$C$及其父类中引用的字段：</p>
<ol>
<li>如果$C$使用了由字段引用指定的名称和描述符来声明一个字段，则字段查找（field lookup）成功。所声明的字段就是查找结果。</li>
<li>否则，对$C$的直接父接口递归地进行字段查找。</li>
<li>否则，如果$C$具有父类$S$，对$S$递归地进行字段查找。</li>
<li>否则，字段查找失败。</li>
</ol>
<p>然后：</p>
<ul>
<li>如果字段查找失败了，字段解析抛出<code>NoSuchFieldError</code></li>
<li>否则，如果字段查找成功了，但是$D$不能访问该引用字段，抛出<code>IllegalAccessError</code></li>
<li>否则，令实际声明该引用字段的class或interface为&lt;$E, L_1$&gt;，令$L_2$为$D$的defining loading<br>  假设引用字段的类型为$T_f$，如果$T_f$不是数组类型，则$T$为$T_f$，如果$T_f$为数组类型，则$T$为$T_f$的元素类型。<br>  JVM必须保证$T^{L_1}=T^{L_2}$的约束。</li>
</ul>
<h3 id="4-3-3-Method-Resolution-方法解析"><a href="#4-3-3-Method-Resolution-方法解析" class="headerlink" title="4.3.3 Method Resolution 方法解析"></a>4.3.3 Method Resolution 方法解析</h3><p>为了将$D$中的符号引用解析为class $C$中的方法，由该方法引用给出的到$C$的符号引用要首先被解析（<a href="#ClassAndInterfaceResolution">4.3.1</a>）。</p>
<p>当解析一个方法引用时：</p>
<ol>
<li>如果$C$是一个interface，抛出<code>IncompatibleClassChangeError</code></li>
<li><p>否则，方法解析（method resolution）尝试在$C$及其父类中定位该引用方法：</p>
<ul>
<li><p>如果$C$刚好声明了一个由该方法引用指定的名字的方法，并且声明的方法是一个<em>signature polymorphic method</em>，那么方法查找成功。描述符中声明的所有类名都被解析了。</p>
<blockquote>
<p>The resolved method is the signature polymorphic method declaration. It is not necessary for C to declare a method with the descriptor specified by the method reference.</p>
</blockquote>
<p>  <strong>signature polymorphic method</strong>这个概念在<a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf" target="_blank" rel="external">《The Java<sup>&reg;</sup> Virtual Machine Specification - Java SE 8 Edition》</a>的 2.9 Special Methods 中定义：</p>
<blockquote>
<p>  A method is signature polymorphic if all of the following are true:<br>  • It is declared in the java.lang.invoke.MethodHandle class.<br>  • It has a single formal parameter of type Object[].<br>  • It has a return type of Object.<br>  • It has the ACC_VARARGS and ACC_NATIVE flags set.</p>
</blockquote>
</li>
<li><p>否则，如果$C$用该方法引用指定的名字和描述符声明了一个方法，方法查找成功。</p>
</li>
<li>否则，如果$C$有父类，对$C$的直接父类递归地调用步骤2。</li>
</ul>
</li>
<li>否则，方法解析尝试在$C$的父接口中定位引用方法：<ul>
<li>If the maximally-specific superinterface methods of C for the name and descriptor specified by the method reference include exactly one method that does not have its <code>ACC_ABSTRACT</code> flag set, then this method is chosen and method lookup succeeds.</li>
<li>Otherwise, if any superinterface of C declares a method with the name and descriptor specified by the method reference that has neither its <code>ACC_PRIVATE</code> flag nor its <code>ACC_STATIC</code> flag set, one of these is arbitrarily chosen and method lookup succeeds.</li>
<li>Otherwise, method lookup fails.</li>
</ul>
</li>
</ol>
<p>A maximally-specific superinterface method of a class or interface $C$ for a particular method name and descriptor is any method for which all of the following are true:</p>
<ul>
<li>The method is declared in a superinterface (direct or indirect) of $C$.</li>
<li>The method is declared with the specified name and descriptor.</li>
<li>The method has neither its <code>ACC_PRIVATE</code> flag nor its <code>ACC_STATIC</code> flag set.</li>
<li>Where the method is declared in interface I, there exists no other maximally- specific superinterface method of $C$ with the specified name and descriptor that is declared in a subinterface of $I$.</li>
</ul>
<p>The result of method resolution is determined by whether method lookup succeeds or fails:</p>
<ul>
<li>If method lookup fails, method resolution throws a <code>NoSuchMethodError</code>.</li>
<li>Otherwise, if method lookup succeeds and the referenced method is not<br>accessible (§5.4.4) to $D$, method resolution throws an <code>IllegalAccessError</code>.</li>
<li><p>Otherwise,let&lt;$E,L_1$&gt;be the class or interface in which the referenced method $m$ is actually declared, and let $L_2$ be the defining loader of $D$.<br>  Given that the return type of $m$ is $T_r$, and that the formal parameter types of $m$<br>are $T_{f_1}, …, T_{f_n}$, then:<br>  If $T_r$ is not an array type, let $T_0$ be $T_r$; otherwise, let $T_0$ be the element type (§2.4) of $T_r$.<br>  For $i = 1, …, n$: If $T_{f_i}$ is not an array type, let $T_i$ be $T_{f_i}$; otherwise, let $T_i$ be the element type (§2.4) of $T_{f_i}$.<br>  The Java Virtual Machine must impose the loading constraints $T^{L_1} = T^{L_2}$ for $i = 0, …, n$ (§5.3.4).<br>  When resolution searches for a method in the class’s superinterfaces, the best outcome is to identify a maximally-specific non-<code>abstract</code> method. It is possible that this method will be chosen by method selection, so it is desirable to add class loader constraints for it.<br>  Otherwise, the result is nondeterministic. This is not new: <em>The Java<sup>®</sup> Virtual Machine Specification</em> has never identified exactly which method is chosen, and how “ties” should be broken. Prior to Java SE 8, this was mostly an unobservable distinction. However, beginning with Java SE 8, the set of interface methods is more heterogenous, so care must be taken to avoid problems with nondeterministic behavior. Thus:</p>
<ul>
<li>Superinterface methods that are <code>private</code> and <code>static</code> are ignored by resolution. This is consistent with the Java programming language, where such interface methods are not inherited.</li>
<li><p>Any behavior controlled by the resolved method should not depend on whether the method is <code>abstract</code> or not.</p>
<p>Note that if the result of resolution is an abstract method, the referenced class $C$ may be non-abstract. Requiring $C$ to be <code>abstract</code> would conflict with the nondeterministic choice of superinterface methods. Instead, resolution assumes that the run time class of the invoked object has a concrete implementation of the method.</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-3-4-Interface-Method-Resolution"><a href="#4-3-4-Interface-Method-Resolution" class="headerlink" title="4.3.4 Interface Method Resolution"></a>4.3.4 Interface Method Resolution</h3><p style="color:red;font-size:30px;font-weight:BOLD">（TBD）</p>

<h3 id="4-3-5-Method-Type-and-Method-Handle-Resolution"><a href="#4-3-5-Method-Type-and-Method-Handle-Resolution" class="headerlink" title="4.3.5 Method Type and Method Handle Resolution"></a>4.3.5 Method Type and Method Handle Resolution</h3><p style="color:red;font-size:30px;font-weight:BOLD">（TBD）</p>

<h3 id="4-3-6-Call-Site-Specifier-Resolution"><a href="#4-3-6-Call-Site-Specifier-Resolution" class="headerlink" title="4.3.6 Call Site Specifier Resolution"></a>4.3.6 Call Site Specifier Resolution</h3><p style="color:red;font-size:30px;font-weight:BOLD">（TBD）</p>


<h2 id="4-4-访问控制（Access-Control）"><a href="#4-4-访问控制（Access-Control）" class="headerlink" title="4.4 访问控制（Access Control）"></a>4.4 访问控制（Access Control）</h2><p>当且仅当以下都为真时，class或interface $C$对class或interface $D$来说是可访问的：</p>
<ul>
<li>$C$为<code>public</code>；</li>
<li>$C$和$D$是同一个运行时包（run-time package）的成员。</li>
</ul>
<p>当且仅当以下都为真时，一个字段或方法$R$对class或interface $D$来说是可访问的：</p>
<ul>
<li>$R$为<code>public</code>；</li>
<li>$R$为<code>protected</code>并且在类$C$中被声明，同时$D$是$C$的子类或者是$C$本身。更进一步，如果$R$不是<code>static</code>的，指向$R$的符号引用必须包含指向类$T$的符号引用，这个$T$是$D$的子类或者是$D$的父类或者是$D$本身；</li>
<li>$R$是<code>protected</code>的，或者具有默认的访问级别（即没有显式声明访问修饰符，非<code>public</code>、非<code>protected</code>、非<code>private</code>），并且和$D$是同一个运行时包（run-time package）的成员；</li>
<li>$R$是<code>private</code>的并且在$D$里声明。</li>
</ul>
<p>上述访问控制的讨论省略了调用<code>protected</code>方法或者访问<code>protected</code>字段的目标的相关限制（目标必须是$D$或者是$D$的子类型）。这种约束是<a href="/2018/03/10/java-class-file-format/#VerificationOfClassFiles">验证阶段</a>的一部分，不是链接时的访问控制。</p>
<h2 id="4-5-覆盖（Overriding）"><a href="#4-5-覆盖（Overriding）" class="headerlink" title="4.5 覆盖（Overriding）"></a>4.5 覆盖（Overriding）</h2><p>有$C$类中声明的实例方法$m_C$和$A$类中声明的另一个实例方法$m_A$，当$m_C$和$m_A$一样或者下列条件都为真时，我们说$m_C$覆盖了$m_A$：</p>
<ul>
<li>$C$是$A$的子类</li>
<li>$m_C$和$m_A$具有同样的名称和描述符</li>
<li>$M_C$没有标记为<code>ACC_PRIVATE</code></li>
<li>以下其中一个为真：<ul>
<li>$m_A$被标记为<code>ACC_PUBLIC</code>；或者被标记为<code>ACC_PROTECTED</code>；或者都没有标记为<code>ACC_PUBLIC</code>、<code>ACC_PROTECTED</code>、<code>ACC_PRIVATE</code>并且$A$和$C$属于同一个运行时包。</li>
<li>$m_C$覆盖了方法$m’$（$m’$与$m_C$和$m_A$都不同），而$m’$覆盖了$m_A$</li>
</ul>
</li>
</ul>
<h1 id="5-初始化（Initialization）"><a href="#5-初始化（Initialization）" class="headerlink" title="5 初始化（Initialization）"></a>5 初始化（Initialization）</h1><p style="color:red;font-size:30px;font-weight:BOLD">（TBD）</p>

<h1 id="6-绑定本地方法实现（Binding-Native-Method-Implementations）"><a href="#6-绑定本地方法实现（Binding-Native-Method-Implementations）" class="headerlink" title="6 绑定本地方法实现（Binding Native Method Implementations）"></a>6 绑定本地方法实现（Binding Native Method Implementations）</h1><p>绑定是这样一个过程：一种用Java以外的语言编写的、实现本地方法的函数被集成到JVM中以便执行。</p>
<p>虽然这个过程通常被称为链接，但术语『绑定』在这个规范中用来避免与JVM的类或接口链接混淆。</p>
<h1 id="7-JVM-Exit"><a href="#7-JVM-Exit" class="headerlink" title="7 JVM Exit"></a>7 JVM Exit</h1><p>某个线程调用了<strong><code>Runtime</code>或<code>System</code>类的<code>exit</code></strong>方法或者<strong><code>Runtime</code>类的<code>halt</code></strong>方法、并且<code>exit</code>或<code>halt</code>操作得到了安全管理器（security manager）的准许时，JVM退出。</p>
<p>另外，JNI（Java Native Interface）规范描述了当JNI Invocation API被用于加载和卸载JVM时JVM的终止。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf" target="_blank" rel="external">The Java<sup>&reg;</sup> Virtual Machine Specification - Java SE 8 Edition</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-概述&quot;&gt;&lt;a href=&quot;#0-概述&quot; class=&quot;headerlink&quot; title=&quot;0 概述&quot;&gt;&lt;/a&gt;0 概述&lt;/h1&gt;&lt;p&gt;这实际上是&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《The Java&lt;sup&gt;&amp;reg;&lt;/sup&gt; Virtual Machine Specification - Java SE 8 Edition》&lt;/a&gt;中第五章内容（Loading, Linking, and Initializing）的部分翻译。主要目的是整理阅读笔记，让我自己看得明白，在这个前提下，尽量让别人看得明白，如果读者觉得我写得很混乱，还请自行阅读原文，不便之处敬请见谅。如有错误，还请指正（拉到页面底部点击『联系我』就可以发邮件给我）。&lt;/p&gt;
&lt;p&gt;阅读本文内容需要先对java的class文件结构有所了解。如果尚不了解，不妨参考我的另一篇博文 &lt;a href=&quot;/2018/03/10/java-class-file-format/&quot;&gt;Java class文件格式&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;加载&lt;/strong&gt;是这样一个过程：寻找一个特定名称的class或者interface的二进制表达形式（binary representation），然后从这个二进制表达形式中创建出一个class或者interface。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链接&lt;/strong&gt;是这样一个过程：取得class或者interface，然后将其结合到JVM的运行时状态，使得它可以被执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化&lt;/strong&gt;一个class或者interface的过程就是执行这个class或者interface的初始化方法&lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt;的过程。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://bungder.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="http://bungder.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java class文件格式</title>
    <link href="http://bungder.github.io/2018/03/10/java-class-file-format/"/>
    <id>http://bungder.github.io/2018/03/10/java-class-file-format/</id>
    <published>2018-03-09T17:02:29.000Z</published>
    <updated>2018-03-13T00:52:21.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0 概述"></a>0 概述</h1><p>这实际上是<a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf" target="_blank" rel="external">《The Java<sup>&reg;</sup> Virtual Machine Specification - Java SE 8 Edition》</a>中第四章内容（The class File Format）的部分翻译。主要目的是整理阅读笔记，让我自己看得明白，在这个前提下，尽量让别人看得明白，如果读者觉得我写得很混乱，还请自行阅读原文，不便之处敬请见谅。如有错误，还请指正（拉到页面底部点击『联系我』就可以发邮件给我）。</p>
<hr>
<p>每一个class文件都包含了一个单独的class或者interface的定义。尽管一个class或者interface并不是有一个以文件形式存在的外部表达，但是下面还是通俗地将class或interface的任何有效表达称为类文件格式（<em>the class file format</em>）。</p>
<p>一个类文件由一个<code>8位字节流</code>组成。 所有的16位，32位和64位量分别通过读取2、4、8个连续的8位字节来构造。 多字节数据项总是以<code>big-endian顺序</code>存储，其中高字节排在第一位。 在Java SE平台中，此格式由接口<code>java.io.DataInput</code>和<code>java.io.DataOutput</code>以及类如<code>java.io.DataInputStream</code>和<code>java.io.DataOutputStream</code>支持。</p>
<a id="more"></a>
<p>本章定义了自己的一组表示类文件数据的数据类型：</p>
<ul>
<li>类型<code>u1</code>，<code>u2</code>和<code>u4</code>分别表示一个无符号的一个，两个或四个字节数量（即1 byte、2 byte和4 byte）。</li>
</ul>
<p>在Java SE平台中，这些类型可以通过接口<code>java.io.DataInput</code>的<code>readUnsignedByte</code>，<code>readUnsignedShort</code>和<code>readInt</code>等方法读取。</p>
<h1 id="1-ClassFile结构"><a href="#1-ClassFile结构" class="headerlink" title="1 ClassFile结构"></a>1 <code>ClassFile</code>结构</h1><p>一个class文件包含一个单独的<code>ClassFile</code>结构：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="section">ClassFile</span> &#123;</div><div class="line">   <span class="attribute">u4</span>             magic;</div><div class="line">   <span class="attribute">u2</span>             minor_version;</div><div class="line">   <span class="attribute">u2</span>             major_version;</div><div class="line">   <span class="attribute">u2</span>             constant_pool_count;</div><div class="line">   <span class="attribute">cp_info</span>        constant_pool[constant_pool_count-<span class="number">1</span>];</div><div class="line">   <span class="attribute">u2</span>             access_flags;</div><div class="line">   <span class="attribute">u2</span>             this_class;</div><div class="line">   <span class="attribute">u2</span>             super_class;</div><div class="line">   <span class="attribute">u2</span>             interfaces_count;</div><div class="line">   <span class="attribute">u2</span>             interfaces[interfaces_count];</div><div class="line">   <span class="attribute">u2</span>             fields_count;</div><div class="line">   <span class="attribute">field_info</span>     fields[fields_count];</div><div class="line">   <span class="attribute">u2</span>             methods_count;</div><div class="line">   <span class="attribute">method_info</span>    methods[methods_count];</div><div class="line">   <span class="attribute">u2</span>             attributes_count;</div><div class="line">   <span class="attribute">attribute_info</span> attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>ClassFile</code>结构中的各个<code>item</code>含义如下：</p>
<h2 id="1-1-magic"><a href="#1-1-magic" class="headerlink" title="1.1 magic"></a>1.1 magic</h2><p>魔法数字，用于标识class文件格式，固定为<code>0xCAFEBABE</code></p>
<h2 id="1-2-minor-version-major-version"><a href="#1-2-minor-version-major-version" class="headerlink" title="1.2 minor_version, major_version"></a>1.2 minor_version, major_version</h2><p>minor_version和major_version组合到一起，决定了class文件格式的版本。</p>
<p>假设class文件的major_version为$M$，minor_version为$m$，那么我们将class文件格式的版本记为$M.m$，因此，这个版本号可以按字典序排序，例如$1.5&lt;2.0&lt;2.1$。</p>
<p>一个JVM的实现可以支持的class文件格式版本记为$v$，当且仅当$v$落在连续区间 $M_i.0 \leq v \leq M_j.m$ 时成立。</p>
<p>JVM实现所遵循的Java SE平台的<strong>release level</strong>决定了其支持范围。</p>
<p>例如</p>
<ul>
<li>Oracle对JDK release 1.0.2的JVM实现支持的class文件格式版本为$[45.0, 45.3]$</li>
<li>JDK release 1.1.* 支持$[45.0, 45.65535]$</li>
<li>对于$k \geq 2$，JDK release $1.k$ 支持范围为$[45.0, 44+k.0]$</li>
</ul>
<h2 id="1-3-constant-pool-count"><a href="#1-3-constant-pool-count" class="headerlink" title="1.3 constant_pool_count"></a>1.3 constant_pool_count</h2><p><code>constant_pool[]</code>中的条目数量+1</p>
<h2 id="1-4-constant-pool"><a href="#1-4-constant-pool" class="headerlink" title="1.4 constant_pool[]"></a>1.4 constant_pool[]</h2><p>constant_pool是一个结构表，表示<code>ClassFile</code>结构及其子结构中引用的各种</p>
<ul>
<li>字符串常量</li>
<li>类和接口名</li>
<li>字段名</li>
<li>其他常量。</li>
</ul>
<p>每个constant_pool表项的格式由第一个“标记(tag)”字节表示。<br>constant_pool表下标的取值范围是$[1,\ constant\_pool\_count)$</p>
<h2 id="1-5-access-flags"><a href="#1-5-access-flags" class="headerlink" title="1.5 access_flags"></a>1.5 access_flags</h2><p>access_flags 项的值是用于<strong>表示对此类或接口的访问权限和属性</strong>的标志的掩码。</p>
<p>16bit</p>
<table>
<thead>
<tr>
<th>Flag Name</th>
<th>Value</th>
<th>二进制</th>
<th>十进制表示</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>00000000 00000001</td>
<td>1</td>
<td>声明<code>public</code></td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>00000000 00010000</td>
<td>16</td>
<td>声明<code>final</code></td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>00000000 00100000</td>
<td>32</td>
<td>当调用<code>invokespecial</code>指令时，特殊对待父类方法</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>00000010 00000000</td>
<td>512</td>
<td>指明这是<code>interface</code>而非<code>class</code></td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>00000100 00000000</td>
<td>1024</td>
<td>声明<code>abstract</code></td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>00010000 00000000</td>
<td>4096</td>
<td>声明synthetic，在源码中不存在</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>00100000 00000000</td>
<td>8192</td>
<td>指明这是注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>01000000 00000000</td>
<td>16384</td>
<td>指明这是<code>enum</code></td>
</tr>
</tbody>
</table>
<h2 id="1-6-this-class"><a href="#1-6-this-class" class="headerlink" title="1.6 this_class"></a>1.6 this_class</h2><p><code>this_class</code>的值必须是<code>constant_pool[]</code>的有效下标。<code>constant_pool[this_class]</code>必须为<code>CONSTANT_Class_info</code>结构，表示了在此class文件中定义的类或者接口。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="section">CONSTANT_Class_info</span> &#123;</div><div class="line">   <span class="attribute">u1</span> tag;</div><div class="line">   <span class="attribute">u2</span> name_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1-7-super-class"><a href="#1-7-super-class" class="headerlink" title="1.7 super_class"></a>1.7 super_class</h2><p><code>super_class</code>的值也必须是<code>constant_pool[]</code>的有效下标。</p>
<p>对于类来说，</p>
<ul>
<li>如果此值不是0， 则<code>constant_pool[super_class]</code>必须为<code>CONSTANT_Class_info</code>结构，表示了此class文件定义的类的直接父类。</li>
<li>如果此值为0，则此class文件必须表示<code>Object</code>类，这是唯一没有直接父类的类或者接口。</li>
</ul>
<p>对于接口来说，没有规定。</p>
<h2 id="1-8-interfaces-count"><a href="#1-8-interfaces-count" class="headerlink" title="1.8 interfaces_count"></a>1.8 interfaces_count</h2><p>指明了此类的直接父接口的数量。</p>
<h2 id="1-9-interfaces"><a href="#1-9-interfaces" class="headerlink" title="1.9 interfaces[]"></a>1.9 interfaces[]</h2><p>里面的每个值都必须是<code>constant_pool[]</code>的有效下标。所指向的<code>constant_pool</code>中的条目必须为<code>CONSTANT_Class_info</code>结构，指明了其直接父接口。</p>
<h2 id="1-10-fileds-count"><a href="#1-10-fileds-count" class="headerlink" title="1.10 fileds_count"></a>1.10 fileds_count</h2><p>给出<code>fields[]</code>中<code>field_info</code>结构的数量。<code>field_info</code>结构表示了此类或接口所声明的所有field，包括class variables和instance virables（也就是静态变量和实例变量）。</p>
<h2 id="1-11-fields"><a href="#1-11-fields" class="headerlink" title="1.11 fields[]"></a>1.11 fields[]</h2><p>所有值都必须为<code>field_info</code>结构，给出对变量的完整描述。只包含由此类或者接口声明的变量，不包括继承而来的。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="section">field_info</span> &#123;</div><div class="line">   <span class="attribute">u2</span>             access_flags;</div><div class="line">   <span class="attribute">u2</span>             name_index;</div><div class="line">   <span class="attribute">u2</span>             descriptor_index;</div><div class="line">   <span class="attribute">u2</span>             attributes_count;</div><div class="line">   <span class="attribute">attribute_info</span> attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1-12-methods-count"><a href="#1-12-methods-count" class="headerlink" title="1.12 methods_count"></a>1.12 methods_count</h2><p>给出<code>methods[]</code>中<code>method_info</code>结构的数量</p>
<h2 id="1-13-methods"><a href="#1-13-methods" class="headerlink" title="1.13 methods[]"></a>1.13 methods[]</h2><p>所有值都必须为<code>method_info</code>结构。</p>
<p>如果<code>ACC_NATIVE</code>和<code>ACC_ABSTRACT</code>标志都没有在<code>method_info</code>里的<code>access_flags</code>中设置，实现此方法的JVM指令也要提供。</p>
<p><code>methods[]</code>表达了此class or intreface声明的所有方法，包括实例方法、类方法、实例初始化方法和class or interface 初始化方法，不包括继承而来的方法。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="section">method_info</span> &#123;</div><div class="line">   <span class="attribute">u2</span>             access_flags;</div><div class="line">   <span class="attribute">u2</span>             name_index;</div><div class="line">   <span class="attribute">u2</span>             descriptor_index;</div><div class="line">   <span class="attribute">u2</span>             attributes_count;</div><div class="line">   <span class="attribute">attribute_info</span> attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1-14-attributes-count"><a href="#1-14-attributes-count" class="headerlink" title="1.14 attributes_count"></a>1.14 attributes_count</h2><p>size of <code>attributes[]</code></p>
<h2 id="1-15-attributes"><a href="#1-15-attributes" class="headerlink" title="1.15 attributes[]"></a>1.15 attributes[]</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="section">attribute_info</span> &#123;</div><div class="line">   <span class="attribute">u2</span> attribute_name_index;</div><div class="line">   <span class="attribute">u4</span> attribute_length;</div><div class="line">   <span class="attribute">u1</span> <span class="literal">info</span>[attribute_length];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="2-The-Internal-Form-of-Names"><a href="#2-The-Internal-Form-of-Names" class="headerlink" title="2 The Internal Form of Names"></a>2 The Internal Form of Names</h1><p><span id="internalFormOfNames"></span></p>
<h2 id="2-1-Binary-Class-and-Interface-Names"><a href="#2-1-Binary-Class-and-Interface-Names" class="headerlink" title="2.1 Binary Class and Interface Names"></a>2.1 Binary Class and Interface Names</h2><p>class文件结构中，class和interface的名字总是以一种全限定（fully qualified）的形式表达的，被称为<code>binary names</code>（JLS §13.1）。这些名字总是表达为<code>CONSTANT_Utf8_info</code>结构。</p>
<p>类和接口名称是从那些<code>CONSTANT_NameAndType_info</code>结构中引用的, 它们的名称是其描述符的一部分, 并且来自所有<code>CONSTANT_Class_info</code>结构</p>
<p>由于历史原因, 类文件结构中出现的binary names的语法不同于JLS §13.1中记录的二进制名称的语法。标识符（identifiers）构成了binary names，通常用ASCII码（<code>.</code>）分割各个标识符，在这种内部形式中，替换为了ASCII码（<code>/</code>）。标识符本身必须是未限定的名称（unqualified names）。</p>
<h2 id="2-2-Unqualified-Names-未限定的名称"><a href="#2-2-Unqualified-Names-未限定的名称" class="headerlink" title="2.2 Unqualified Names 未限定的名称"></a>2.2 Unqualified Names 未限定的名称</h2><p>方法、field、本地变量和形式参数的名称都存储为<code>unqualified names</code>。</p>
<p>一个<code>unqualified names</code>必须包含至少一个Unicode码（Unicode code point），并且不能包含以下ASCII字符：<code>.</code>, <code>;</code>, <code>[</code>, <code>/</code>（即，句号、分号、左方括号和斜线）。</p>
<p>方法名的约束还要加上不能出现ASCII字符<code>&lt;</code>、<code>&gt;</code>（即左尖括号和右尖括号），例外方法为</p>
<ul>
<li><code>&lt;init&gt;</code></li>
<li><code>&lt;clinit&gt;</code></li>
</ul>
<h1 id="3-Descriptors-描述符"><a href="#3-Descriptors-描述符" class="headerlink" title="3 Descriptors 描述符"></a>3 Descriptors 描述符</h1><p>描述符是用于表示field或者方法的字符串。</p>
<h2 id="3-1-Grammer-Notaion-语法符号"><a href="#3-1-Grammer-Notaion-语法符号" class="headerlink" title="3.1 Grammer Notaion 语法符号"></a>3.1 Grammer Notaion 语法符号</h2><p>（先定义用于描述描述符构成的语法）：<br>描述符是使用语法指定的。语法是一组生产、 描述字符序列如何形成各种语法正确的描述符。</p>
<ul>
<li>语法的终端符号以固定宽度字体显示。</li>
<li>非终结名称符号以斜体类型显示。</li>
<li>非终结名称的定义由定义的非终结名称的名称引入，后跟冒号。</li>
<li>非终结名称的一个或多个可选定义随后将跟随后续行。</li>
<li>生产右侧的语法 {x} 表示 x 的零个或多个匹配项。</li>
<li>生产右侧的短语 (one of) 表示以下行或行上的每个终端符号都是可选的定义。</li>
</ul>
<h2 id="3-2-Field-Descriptors"><a href="#3-2-Field-Descriptors" class="headerlink" title="3.2 Field Descriptors"></a>3.2 Field Descriptors</h2><p><img src="http://otlnkjq1m.bkt.clouddn.com/FieldDescriptors.jpeg" alt=""></p>
<p>field descriptors的说明：</p>
<table>
<thead>
<tr>
<th>FieldType term</th>
<th>Type</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>byte</td>
<td>signed byte  </td>
</tr>
<tr>
<td>C</td>
<td>char</td>
<td>Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16 </td>
</tr>
<tr>
<td>D</td>
<td>double</td>
<td>double-precision floating-point value </td>
</tr>
<tr>
<td>F</td>
<td>float</td>
<td>single-precision floating-point value </td>
</tr>
<tr>
<td>I</td>
<td>int</td>
<td>integer  </td>
</tr>
<tr>
<td>J</td>
<td>long</td>
<td>long integer </td>
</tr>
<tr>
<td>L ClassName ;</td>
<td>reference</td>
<td>an instance of class ClassName </td>
</tr>
<tr>
<td>S</td>
<td>short</td>
<td>signed short </td>
</tr>
<tr>
<td>Z</td>
<td>boolean</td>
<td>true or false </td>
</tr>
<tr>
<td>[</td>
<td>reference</td>
<td>one array dimension </td>
</tr>
</tbody>
</table>
<p>例子：</p>
<ul>
<li>一个Object实例表示为：<code>Ljava/lang/Object;</code></li>
<li>一个多维数组<code>double[][][]</code>表示为<code>[[[D</code></li>
</ul>
<h2 id="3-3-Method-Descriptors-方法描述符"><a href="#3-3-Method-Descriptors-方法描述符" class="headerlink" title="3.3 Method Descriptors 方法描述符"></a>3.3 Method Descriptors 方法描述符</h2><p><img src="http://otlnkjq1m.bkt.clouddn.com/MethodDescriptors.jpeg" alt=""></p>
<p>例子：</p>
<ul>
<li><p>1</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Object <span class="title">m</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">double</span> d, Thread t)</span> </span>&#123;...&#125;</div></pre></td></tr></table></figure>
<p>  描述符为：<code>(IDLjava/lang/Thread;)Ljava/lang/Object;</code></p>
</li>
</ul>
<h1 id="4-The-Constant-Pool"><a href="#4-The-Constant-Pool" class="headerlink" title="4 The Constant Pool"></a>4 The Constant Pool</h1><p>Java 虚拟机指令不依赖于类、接口、类实例或数组的运行时布局。相反, 指令指的是 constant_pool 表中的符号信息。</p>
<p><code>constant_pool</code>中的所有条目都具有以下的一般结构：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="section">cp_info</span> &#123;</div><div class="line">    <span class="attribute">u1</span> tag;</div><div class="line">    <span class="attribute">u1</span> <span class="literal">info</span>[]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，<code>tag</code>用于指示<code>cp_info</code>条目的类型，<code>info</code>数组的内容随<code>tag</code>的值而变化。每个标记字节必须后跟两个或多个字节, 以提供有关特定常量的信息。<code>tag</code>的取值范围如下：</p>
<table>
<thead>
<tr>
<th>Constant Type</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONSTANT_Class</td>
<td>7</td>
</tr>
<tr>
<td>CONSTANT_Fieldref</td>
<td>9</td>
</tr>
<tr>
<td>CONSTANT_Methodref</td>
<td>10</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref</td>
<td>11</td>
</tr>
<tr>
<td>CONSTANT_String</td>
<td>8</td>
</tr>
<tr>
<td>CONSTANT_Integer</td>
<td>3</td>
</tr>
<tr>
<td>CONSTANT_Float</td>
<td>4</td>
</tr>
<tr>
<td>CONSTANT_Long</td>
<td>5</td>
</tr>
<tr>
<td>CONSTANT_Double</td>
<td>6</td>
</tr>
<tr>
<td>CONSTANT_NameAndType</td>
<td>12</td>
</tr>
<tr>
<td>CONSTANT_Utf8</td>
<td>1</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle</td>
<td>15</td>
</tr>
<tr>
<td>CONSTANT_MethodType</td>
<td>16</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic</td>
<td>18</td>
</tr>
</tbody>
</table>
<h2 id="4-1-CONSTANT-Class-info"><a href="#4-1-CONSTANT-Class-info" class="headerlink" title="4.1 CONSTANT_Class_info"></a>4.1 CONSTANT_Class_info</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="section">CONSTANT_Class_info</span> &#123;</div><div class="line">    <span class="attribute">u1</span> tag;</div><div class="line">    <span class="attribute">u2</span> name_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>tag</code>的值为<code>7</code>，表示这是一个<code>CONSTANT_Class</code>，<code>name_index</code>必须是<code>constant_pool</code>的有效下标，指向的必须是一个<code>CONSTANT_Utf8_info</code>结构。也就是说指向了常量池中表示类名的字符串常量。类名表达为<a href="#internalFormOfNames"><code>internal form</code></a>，例如：</p>
<ul>
<li><code>int[][]</code>表达为<code>[[I</code></li>
<li><code>Thread[]</code>表达为<code>[Ljava/lang/Thread;</code></li>
</ul>
<h2 id="4-2-CONSTANT-Fieldref-info-CONSTANT-Methodref-info和CONSTANT-InterfaceMethodref-info"><a href="#4-2-CONSTANT-Fieldref-info-CONSTANT-Methodref-info和CONSTANT-InterfaceMethodref-info" class="headerlink" title="4.2 CONSTANT_Fieldref_info, CONSTANT_Methodref_info和CONSTANT_InterfaceMethodref_info"></a>4.2 CONSTANT_Fieldref_info, CONSTANT_Methodref_info和CONSTANT_InterfaceMethodref_info</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="section">CONSTANT_Fieldref_info</span> &#123;</div><div class="line">   <span class="attribute">u1</span> tag;</div><div class="line">   <span class="attribute">u2</span> class_index;</div><div class="line">   <span class="attribute">u2</span> name_and_type_index;</div><div class="line">&#125;</div><div class="line"><span class="section">CONSTANT_Methodref_info</span> &#123;</div><div class="line">   <span class="attribute">u1</span> tag;</div><div class="line">   <span class="attribute">u2</span> class_index;</div><div class="line">   <span class="attribute">u2</span> name_and_type_index;</div><div class="line">&#125;</div><div class="line"><span class="section">CONSTANT_InterfaceMethodref_info</span> &#123;</div><div class="line">   <span class="attribute">u1</span> tag;</div><div class="line">   <span class="attribute">u2</span> class_index;</div><div class="line">   <span class="attribute">u2</span> name_and_type_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-3-CONSTANT-String-info"><a href="#4-3-CONSTANT-String-info" class="headerlink" title="4.3 CONSTANT_String_info"></a>4.3 CONSTANT_String_info</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="section">CONSTANT_String_info</span> &#123;</div><div class="line">   <span class="attribute">u1</span> tag;</div><div class="line">   <span class="attribute">u2</span> string_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>string_index<br>必须是<code>constant_pool</code>的有效下标，必须指向<code>CONSTANT_Utf8_info</code>结构。</li>
</ul>
<h2 id="4-4-CONSTANT-Integer-info和CONSTANT-Float-info结构"><a href="#4-4-CONSTANT-Integer-info和CONSTANT-Float-info结构" class="headerlink" title="4.4 CONSTANT_Integer_info和CONSTANT_Float_info结构"></a>4.4 CONSTANT_Integer_info和CONSTANT_Float_info结构</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="section">CONSTANT_Integer_info</span> &#123;</div><div class="line">    <span class="attribute">u1</span> tag;</div><div class="line">    <span class="attribute">u4</span> bytes; </div><div class="line">&#125;</div><div class="line"><span class="section">CONSTANT_Float_info</span> &#123;</div><div class="line">    <span class="attribute">u1</span> tag;</div><div class="line">    <span class="attribute">u4</span> bytes; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>bytes<br>表达实际值</li>
</ul>
<h2 id="4-5-CONSTANT-Long-info和CONSTANT-Double-info结构"><a href="#4-5-CONSTANT-Long-info和CONSTANT-Double-info结构" class="headerlink" title="4.5 CONSTANT_Long_info和CONSTANT_Double_info结构"></a>4.5 CONSTANT_Long_info和CONSTANT_Double_info结构</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="section">CONSTANT_Long_info</span> &#123;</div><div class="line">   <span class="attribute">u1</span> tag;</div><div class="line">   <span class="attribute">u4</span> high_bytes;</div><div class="line">   <span class="attribute">u4</span> low_bytes;</div><div class="line">&#125;</div><div class="line"><span class="section">CONSTANT_Double_info</span> &#123;</div><div class="line">   <span class="attribute">u1</span> tag;</div><div class="line">   <span class="attribute">u4</span> high_bytes;</div><div class="line">   <span class="attribute">u4</span> low_bytes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-6-CONSTANT-NameAndType-info"><a href="#4-6-CONSTANT-NameAndType-info" class="headerlink" title="4.6 CONSTANT_NameAndType_info"></a>4.6 CONSTANT_NameAndType_info</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="section">CONSTANT_NameAndType_info</span> &#123;</div><div class="line">   <span class="attribute">u1</span> tag;</div><div class="line">   <span class="attribute">u2</span> name_index;</div><div class="line">   <span class="attribute">u2</span> descriptor_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-7-CONSTANT-Utf8-info"><a href="#4-7-CONSTANT-Utf8-info" class="headerlink" title="4.7 CONSTANT_Utf8_info"></a>4.7 CONSTANT_Utf8_info</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="section">CONSTANT_Utf8_info</span> &#123;</div><div class="line">    <span class="attribute">u1</span> tag;</div><div class="line">    <span class="attribute">u2</span> length;</div><div class="line">    <span class="attribute">u1</span> bytes[length];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-8-CONSTANT-MethodHandle-info"><a href="#4-8-CONSTANT-MethodHandle-info" class="headerlink" title="4.8 CONSTANT_MethodHandle_info"></a>4.8 CONSTANT_MethodHandle_info</h2><p><span id="CONSTANT_MethodHandle_info"></span></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="section">CONSTANT_MethodHandle_info</span> &#123;</div><div class="line">   <span class="attribute">u1</span> tag;</div><div class="line">   <span class="attribute">u1</span> reference_kind;</div><div class="line">   <span class="attribute">u2</span> reference_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>reference_kind</p>
<blockquote>
<p>  The value of the reference_kind item must be in the range <strong>1 to 9</strong>. The value denotes the kind of this method handle, which characterizes its bytecode behavior (§5.4.3.5)(Chapter 5: Loading, Linking, and Initializing).</p>
</blockquote>
</li>
<li>reference_index<br>  必须是<code>constant_pool</code>的有效下标，指向的结构根据<code>reference_kind</code>的不同而有不同的要求：<ul>
<li>如果<code>reference_kind</code>为1、2、3、4，必须指向<code>CONSTANT_Fieldref_info</code>结构</li>
<li>如果<code>reference_kind</code>为5、8，必须指向<code>CONSTANT_Methodref_info</code>，而此结构表达了类的方法或构造器</li>
<li>如果<code>reference_kind</code>为6、7，然后<ul>
<li>如果class文件的版本号小于52.0，必须指向<code>CONSTANT_Methodref_info</code>结构，此结构表示类的方法；</li>
<li>如果class文件的版本号大于或等于52.0，则必须指向<code>CONSTANT_Methodref_info</code>结构或者<code>CONSTANT_InterfaceMethodref_info</code>结构，表达了类或接口的方法；</li>
</ul>
</li>
<li>如果<code>reference_kind</code>为9，必须指向<code>CONSTANT_InterfaceMethodref_info</code>结构，表达了接口方法。</li>
</ul>
</li>
</ul>
<h2 id="4-9-CONSTANT-MethodType-info"><a href="#4-9-CONSTANT-MethodType-info" class="headerlink" title="4.9 CONSTANT_MethodType_info"></a>4.9 CONSTANT_MethodType_info</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="section">CONSTANT_MethodType_info</span> &#123;</div><div class="line">   <span class="attribute">u1</span> tag;</div><div class="line">   <span class="attribute">u2</span> descriptor_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-10-CONSTANT-InvokeDynamic-info"><a href="#4-10-CONSTANT-InvokeDynamic-info" class="headerlink" title="4.10 CONSTANT_InvokeDynamic_info"></a>4.10 CONSTANT_InvokeDynamic_info</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="section">CONSTANT_InvokeDynamic_info</span> &#123;</div><div class="line">   <span class="attribute">u1</span> tag;</div><div class="line">   <span class="attribute">u2</span> bootstrap_method_attr_index;</div><div class="line">   <span class="attribute">u2</span> name_and_type_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>bootstrap_method_attr_index<blockquote>
<p>The value of the bootstrap_method_attr_index item must be a valid index into the <strong>bootstrap_methods</strong> array of the <a href="#TheBootstrapMethodsAttribute">bootstrap method table (§4.7.23)</a> of this class file.</p>
</blockquote>
</li>
</ul>
<h1 id="5-Fields"><a href="#5-Fields" class="headerlink" title="5 Fields"></a>5 Fields</h1><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="section">field_info</span> &#123;</div><div class="line">   <span class="attribute">u2</span>             access_flags;</div><div class="line">   <span class="attribute">u2</span>             name_index;</div><div class="line">   <span class="attribute">u2</span>             descriptor_index;</div><div class="line">   <span class="attribute">u2</span>             attributes_count;</div><div class="line">   <span class="attribute">attribute_info</span> attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>attributes[]<br>里面的每个item都必须是<a href="#attributeInfo"><code>attribute_info</code></a>结构</li>
</ul>
<h1 id="6-Methods"><a href="#6-Methods" class="headerlink" title="6 Methods"></a>6 Methods</h1><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="section">method_info</span> &#123;</div><div class="line">       <span class="attribute">u2</span>             access_flags;</div><div class="line">       <span class="attribute">u2</span>             name_index;</div><div class="line">       <span class="attribute">u2</span>             descriptor_index;</div><div class="line">       <span class="attribute">u2</span>             attributes_count;</div><div class="line">       <span class="attribute">attribute_info</span> attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>attributes[]<br>里面的每个item都必须是<a href="#attributeInfo"><code>attribute_info</code></a>结构</li>
</ul>
<h1 id="7-Attributes"><a href="#7-Attributes" class="headerlink" title="7 Attributes"></a>7 Attributes</h1><p><span id="attributeInfo"><br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="section">attribute_info</span> &#123;</div><div class="line">   <span class="attribute">u2</span> attribute_name_index;</div><div class="line">   <span class="attribute">u4</span> attribute_length;</div><div class="line">   <span class="attribute">u1</span> <span class="literal">info</span>[attribute_length];</div><div class="line">&#125;</div></pre></td></tr></table></figure></span></p>
<h2 id="The-Code-Attribute"><a href="#The-Code-Attribute" class="headerlink" title="The Code Attribute"></a>The Code Attribute</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Code_attribute &#123;</div><div class="line">    u2 attribute_name_index<span class="comment">;</span></div><div class="line">    u4 attribute_length<span class="comment">;</span></div><div class="line">    u2 max_stack<span class="comment">;</span></div><div class="line">    u2 max_locals<span class="comment">;</span></div><div class="line">    u4 code_length<span class="comment">;</span></div><div class="line">    u1 code[code_length]<span class="comment">;</span></div><div class="line">    u2 exception_table_length<span class="comment">;</span></div><div class="line">    &#123;   u2 start_pc<span class="comment">;</span></div><div class="line">        u2 end_pc<span class="comment">;</span></div><div class="line">        u2 handler_pc<span class="comment">;</span></div><div class="line">        u2 catch_type<span class="comment">;</span></div><div class="line">    &#125; exception_table[exception_table_length]<span class="comment">;</span></div><div class="line">    u2 attributes_count<span class="comment">;</span></div><div class="line">    attribute_info attributes[attributes_count]<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>max_stack<br>给出在方法执行的任意地方操作数栈的最大深度</li>
<li>max_locals<br>给出方法调用时本地方法表的最大容量</li>
<li><strong>code[]</strong><br><strong>给出了实现方法的JVM代码的实际字节（byte）。</strong></li>
</ul>
<h2 id="The-BootstrapMethods-Attribute"><a href="#The-BootstrapMethods-Attribute" class="headerlink" title="The BootstrapMethods Attribute"></a>The BootstrapMethods Attribute</h2><p><span id="TheBootstrapMethodsAttribute"></span></p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">BootstrapMethods_attribute </span>&#123;</div><div class="line">       u2 attribute_name_index<span class="comment">;</span></div><div class="line">       u4 attribute_length<span class="comment">;</span></div><div class="line">       u2 num_bootstrap_methods<span class="comment">;</span></div><div class="line">       &#123;   u2 <span class="keyword">bootstrap_method_ref;</span></div><div class="line">           u2 num_bootstrap_arguments<span class="comment">;</span></div><div class="line">           u2 <span class="keyword">bootstrap_arguments[num_bootstrap_arguments];</span></div><div class="line">       &#125; <span class="keyword">bootstrap_methods[num_bootstrap_methods];</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>bootstrap_methods[]<ul>
<li>bootstrap_method_ref<br>其值必须是<code>constant_pool</code>中的有效下标，指向的必须是<a href="#CONSTANT_MethodHandle_info"><code>CONSTANT_MethodHandle_info</code></a>结构</li>
</ul>
</li>
</ul>
<h1 id="8-Format-Checking"><a href="#8-Format-Checking" class="headerlink" title="8 Format Checking"></a>8 Format Checking</h1><p style="color:red;font-size:30px;font-weight:BOLD">（TBD）</p>

<h1 id="9-Constraints-on-Java-Virtual-Machine-Code"><a href="#9-Constraints-on-Java-Virtual-Machine-Code" class="headerlink" title="9 Constraints on Java Virtual Machine Code"></a>9 Constraints on Java Virtual Machine Code</h1><p><span id="ConstraintsOnJavaVirtualMachineCode"></span></p>
<p style="color:red;font-size:30px;font-weight:BOLD">（TBD）</p>

<h1 id="10-Verification-of-class-Files"><a href="#10-Verification-of-class-Files" class="headerlink" title="10 Verification of class Files"></a>10 Verification of class Files</h1><p><span id="VerificationOfClassFiles"></span></p>
<p style="color:red;font-size:30px;font-weight:BOLD">（TBD）</p>

<h2 id="10-1-Verification-by-Type-Checking"><a href="#10-1-Verification-by-Type-Checking" class="headerlink" title="10.1 Verification by Type Checking"></a>10.1 Verification by Type Checking</h2><h2 id="10-2-Verification-by-Type-Inference"><a href="#10-2-Verification-by-Type-Inference" class="headerlink" title="10.2 Verification by Type Inference"></a>10.2 Verification by Type Inference</h2><h1 id="11-JVM的限制"><a href="#11-JVM的限制" class="headerlink" title="11 JVM的限制"></a>11 JVM的限制</h1><ul>
<li><code>ClassFile</code>结构中16-bit的<code>constant_pool_count</code>限制了per-class或者per-interface的常量池最多只有<strong>65535</strong>个条目（entries）。这对单个类或接口的总体复杂性起到了内部限制作用。</li>
<li><code>ClassFile</code>结构中的<code>fields_count</code>限制了一个class or interface能声明的<code>field</code>数量不能超过<strong>65535</strong>。（不包括继承的）</li>
<li>方法数量限制同上。（<code>methods_count</code>）</li>
<li>直接父接口的数量限制同上（<code>interfaces_count</code>）</li>
<li>方法调用时创建的帧里面，本地变量表中的本地变量数量最多为<strong>65535</strong>，由<code>Code</code> attribute中的<code>max_locals</code> item所限制，以及由JVM指令集的16-bit本地变量索引所限制。<br>其中，<code>long</code>和<code>double</code>类型视为两个本地变量</li>
<li><code>Code</code> attribute中的<code>max_stack</code> item限制了frame中的操作数栈的大小为<strong>65535</strong><br>其中，<code>long</code>和<code>double</code>类型的操作数视为两个单元</li>
<li><code>method descriptor</code>的定义限制了方法参数的数量最多为<strong>255</strong><br>其中，实例方法的<code>this</code>占了一个单元，<code>long</code>和<code>double</code>类型的会占两个单元</li>
<li>field和方法的名称、field和方法的descriptor以及其他string常量值（包括被<code>ConstantValue</code> attribute引用的）最多为<strong>65535</strong>个<strong>byte</strong>，由<code>CONSTANT_Utf8_info</code>结构中的16-bit无符号<code>length</code> item所限制</li>
<li><p>数组的维度最多为<strong>255</strong>，由<code>multianewarray</code>指令中的opcode <code>dimensions</code>的大小所限制</p>
<blockquote>
<p>  The number of dimensions in an array is limited to 255 by the size of the dimensions opcode of the multianewarray instruction and by the constraints imposed on the multianewarray, anewarray, and newarray instructions</p>
</blockquote>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf" target="_blank" rel="external">The Java<sup>&reg;</sup> Virtual Machine Specification - Java SE 8 Edition</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-概述&quot;&gt;&lt;a href=&quot;#0-概述&quot; class=&quot;headerlink&quot; title=&quot;0 概述&quot;&gt;&lt;/a&gt;0 概述&lt;/h1&gt;&lt;p&gt;这实际上是&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《The Java&lt;sup&gt;&amp;reg;&lt;/sup&gt; Virtual Machine Specification - Java SE 8 Edition》&lt;/a&gt;中第四章内容（The class File Format）的部分翻译。主要目的是整理阅读笔记，让我自己看得明白，在这个前提下，尽量让别人看得明白，如果读者觉得我写得很混乱，还请自行阅读原文，不便之处敬请见谅。如有错误，还请指正（拉到页面底部点击『联系我』就可以发邮件给我）。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;每一个class文件都包含了一个单独的class或者interface的定义。尽管一个class或者interface并不是有一个以文件形式存在的外部表达，但是下面还是通俗地将class或interface的任何有效表达称为类文件格式（&lt;em&gt;the class file format&lt;/em&gt;）。&lt;/p&gt;
&lt;p&gt;一个类文件由一个&lt;code&gt;8位字节流&lt;/code&gt;组成。 所有的16位，32位和64位量分别通过读取2、4、8个连续的8位字节来构造。 多字节数据项总是以&lt;code&gt;big-endian顺序&lt;/code&gt;存储，其中高字节排在第一位。 在Java SE平台中，此格式由接口&lt;code&gt;java.io.DataInput&lt;/code&gt;和&lt;code&gt;java.io.DataOutput&lt;/code&gt;以及类如&lt;code&gt;java.io.DataInputStream&lt;/code&gt;和&lt;code&gt;java.io.DataOutputStream&lt;/code&gt;支持。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://bungder.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="http://bungder.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Druid连接池监控的一次改造</title>
    <link href="http://bungder.github.io/2017/08/31/druid-monitor-remould/"/>
    <id>http://bungder.github.io/2017/08/31/druid-monitor-remould/</id>
    <published>2017-08-30T17:32:07.000Z</published>
    <updated>2017-09-20T08:31:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>druid本身提供了监控功能，具体在我另一篇博文《<a href="/2017/08/27/druid-monitor/">Druid连接池监控</a>》里有介绍。当时提到有以下缺陷：</p>
<ol>
<li>无法灵活监控多个目标</li>
<li>切换环境不方便</li>
<li>JMX重连不会成功</li>
</ol>
<p>因此针对这些问题，对其进行改造。改造后的源码已经放在个人的github上：<br><a href="https://github.com/bungder/druid-aggregated-monitor" target="_blank" rel="external">https://github.com/bungder/druid-aggregated-monitor</a></p>
<p>对应本文的版本，已经打了tag：<br><a href="https://github.com/bungder/druid-aggregated-monitor/releases/tag/0.0.1" target="_blank" rel="external">https://github.com/bungder/druid-aggregated-monitor/releases/tag/0.0.1</a></p>
<a id="more"></a>
<p>对于在同一个工程里进行监控和展示的情况不进行考虑，具体原因见刚刚提到的博文。</p>
<h1 id="2-原理分析"><a href="#2-原理分析" class="headerlink" title="2. 原理分析"></a>2. 原理分析</h1><p>首先，监控数据的展示是通过<code>com.alibaba.druid.support.http.StatViewServlet</code>实现的，将其源码贴上来分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> com.alibaba.druid.support.http;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.management.MBeanServerConnection;</div><div class="line"><span class="keyword">import</span> javax.management.ObjectName;</div><div class="line"><span class="keyword">import</span> javax.management.remote.JMXConnector;</div><div class="line"><span class="keyword">import</span> javax.management.remote.JMXConnectorFactory;</div><div class="line"><span class="keyword">import</span> javax.management.remote.JMXServiceURL;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletException;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.alibaba.druid.stat.DruidStatService;</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.support.logging.Log;</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.support.logging.LogFactory;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 注意：避免直接调用Druid相关对象例如DruidDataSource等，相关调用要到DruidStatManagerFacade里用反射实现</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> sandzhang&lt;sandzhangtoo@gmail.com&gt;</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatViewServlet</span> <span class="keyword">extends</span> <span class="title">ResourceServlet</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Log      LOG                     = LogFactory.getLog(StatViewServlet.class);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span>     serialVersionUID        = <span class="number">1L</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String    PARAM_NAME_RESET_ENABLE = <span class="string">"resetEnable"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String    PARAM_NAME_JMX_URL      = <span class="string">"jmxUrl"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String    PARAM_NAME_JMX_USERNAME = <span class="string">"jmxUsername"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String    PARAM_NAME_JMX_PASSWORD = <span class="string">"jmxPassword"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> DruidStatService      statService             = DruidStatService.getInstance();</div><div class="line"></div><div class="line">    <span class="comment">/** web.xml中配置的jmx的连接地址 */</span></div><div class="line">    <span class="keyword">private</span> String                jmxUrl                  = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">/** web.xml中配置的jmx的用户名 */</span></div><div class="line">    <span class="keyword">private</span> String                jmxUsername             = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">/** web.xml中配置的jmx的密码 */</span></div><div class="line">    <span class="keyword">private</span> String                jmxPassword             = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> MBeanServerConnection conn                    = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StatViewServlet</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>(<span class="string">"support/http/resources"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">        <span class="keyword">super</span>.init();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            String param = getInitParameter(PARAM_NAME_RESET_ENABLE);</div><div class="line">            <span class="keyword">if</span> (param != <span class="keyword">null</span> &amp;&amp; param.trim().length() != <span class="number">0</span>) &#123;</div><div class="line">                param = param.trim();</div><div class="line">                <span class="keyword">boolean</span> resetEnable = Boolean.parseBoolean(param);</div><div class="line">                statService.setResetEnable(resetEnable);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            String msg = <span class="string">"initParameter config error, resetEnable : "</span> + getInitParameter(PARAM_NAME_RESET_ENABLE);</div><div class="line">            LOG.error(msg, e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 获取jmx的连接配置信息</span></div><div class="line">        String param = readInitParam(PARAM_NAME_JMX_URL);</div><div class="line">        <span class="keyword">if</span> (param != <span class="keyword">null</span>) &#123;</div><div class="line">            jmxUrl = param;</div><div class="line">            jmxUsername = readInitParam(PARAM_NAME_JMX_USERNAME);</div><div class="line">            jmxPassword = readInitParam(PARAM_NAME_JMX_PASSWORD);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                initJmxConn();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                LOG.error(<span class="string">"init jmx connection error"</span>, e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 读取servlet中的配置参数.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> key 配置参数名</div><div class="line">     * <span class="doctag">@return</span> 配置参数值，如果不存在当前配置参数，或者为配置参数长度为0，将返回null</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">readInitParam</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        String value = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            String param = getInitParameter(key);</div><div class="line">            <span class="keyword">if</span> (param != <span class="keyword">null</span>) &#123;</div><div class="line">                param = param.trim();</div><div class="line">                <span class="keyword">if</span> (param.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">                    value = param;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            String msg = <span class="string">"initParameter config ["</span> + key + <span class="string">"] error"</span>;</div><div class="line">            LOG.warn(msg, e);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 初始化jmx连接</div><div class="line">     * </div><div class="line">     * <span class="doctag">@throws</span> IOException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initJmxConn</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (jmxUrl != <span class="keyword">null</span>) &#123;</div><div class="line">            JMXServiceURL url = <span class="keyword">new</span> JMXServiceURL(jmxUrl);</div><div class="line">            Map&lt;String, String[]&gt; env = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span> (jmxUsername != <span class="keyword">null</span>) &#123;</div><div class="line">                env = <span class="keyword">new</span> HashMap&lt;String, String[]&gt;();</div><div class="line">                String[] credentials = <span class="keyword">new</span> String[] &#123; jmxUsername, jmxPassword &#125;;</div><div class="line">                env.put(JMXConnector.CREDENTIALS, credentials);</div><div class="line">            &#125;</div><div class="line">            JMXConnector jmxc = JMXConnectorFactory.connect(url, env);</div><div class="line">            conn = jmxc.getMBeanServerConnection();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 根据指定的url来获取jmx服务返回的内容.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> connetion jmx连接</div><div class="line">     * <span class="doctag">@param</span> url url内容</div><div class="line">     * <span class="doctag">@return</span> the jmx返回的内容</div><div class="line">     * <span class="doctag">@throws</span> Exception the exception</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getJmxResult</span><span class="params">(MBeanServerConnection connetion, String url)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ObjectName name = <span class="keyword">new</span> ObjectName(DruidStatService.MBEAN_NAME);</div><div class="line"></div><div class="line">        String result = (String) conn.invoke(name, <span class="string">"service"</span>, <span class="keyword">new</span> String[] &#123; url &#125;,</div><div class="line">                                             <span class="keyword">new</span> String[] &#123; String.class.getName() &#125;);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 程序首先判断是否存在jmx连接地址，如果不存在，则直接调用本地的duird服务； 如果存在，则调用远程jmx服务。在进行jmx通信，首先判断一下jmx连接是否已经建立成功，如果已经</div><div class="line">     * 建立成功，则直接进行通信，如果之前没有成功建立，则会尝试重新建立一遍。.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> url 要连接的服务地址</div><div class="line">     * <span class="doctag">@return</span> 调用服务后返回的json字符串</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">process</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">        String resp = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (jmxUrl == <span class="keyword">null</span>) &#123;</div><div class="line">            resp = statService.service(url);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;<span class="comment">// 连接在初始化时创建失败</span></div><div class="line">                <span class="keyword">try</span> &#123;<span class="comment">// 尝试重新连接</span></div><div class="line">                    initJmxConn();</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    LOG.error(<span class="string">"init jmx connection error"</span>, e);</div><div class="line">                    resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR,</div><div class="line">                                                             <span class="string">"init jmx connection error"</span> + e.getMessage());</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;<span class="comment">// 连接成功</span></div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        resp = getJmxResult(conn, url);</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        LOG.error(<span class="string">"get jmx data error"</span>, e);</div><div class="line">                        resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR, <span class="string">"get data error:"</span></div><div class="line">                                                                                                     + e.getMessage());</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 连接成功</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    resp = getJmxResult(conn, url);</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    LOG.error(<span class="string">"get jmx data error"</span>, e);</div><div class="line">                    resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR,</div><div class="line">                                                             <span class="string">"get data error"</span> + e.getMessage());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> resp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>首先，现在需要搞清楚的问题有：</p>
<ol>
<li>配置信息是如何生效的</li>
<li>监控数据是怎么流动的</li>
<li>权限控制是怎样实现的</li>
<li>为什么重连会失败</li>
</ol>
<p>逐个方法去看，<code>init</code>方法是初始化的，应该能找到『配置信息是如何生效的』的答案。里面调用了<code>readInitparam</code>方法来读取，而这个方法又调用了<code>getInitParameter</code>方法，进入方法后发现此方法是<code>javax.servlet.GenericServlet</code>里的，已经不是druid的代码，意味着读取参数是通过调用容器的api实现的，这个过程无法进行篡改。</p>
<p>这里只是读取参数值，还没使用，让我们一步步回退回<code>init</code>方法，在读取了参数值之后就调用<code>initJmxConn</code>方法，该方法初始化了与监控目标之间的JMX连接，是关键的地方。但是里面也没多少东西，主要就是根据url去获取连接，对于『为什么重连会失败』，应该也是一个切入点。但是一路点进去看都没发现有重试的机制。</p>
<p>接着往下看，剩下<code>getJmxResult</code>和<code>process</code>两个方法，其注释里已经讲得很明白了。可以发现，在<code>process</code>方法里有重连的机制，那么还是没搞清楚为什么无法重连成功。</p>
<p>在看完这个类之后，可以发现请求的调用链并没有体现出来，所以看它的父类<code>ResourceServlet</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Copyright 1999-2011 Alibaba Group Holding Ltd.</div><div class="line"> *</div><div class="line"> * Licensed under the Apache License, Version 2.0 (the "License");</div><div class="line"> * you may not use this file except in compliance with the License.</div><div class="line"> * You may obtain a copy of the License at</div><div class="line"> *</div><div class="line"> *      http://www.apache.org/licenses/LICENSE-2.0</div><div class="line"> *</div><div class="line"> * Unless required by applicable law or agreed to in writing, software</div><div class="line"> * distributed under the License is distributed on an "AS IS" BASIS,</div><div class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</div><div class="line"> * See the License for the specific language governing permissions and</div><div class="line"> * limitations under the License.</div><div class="line"> */</div><div class="line"><span class="keyword">package</span> com.alibaba.druid.support.http;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.util.IPAddress;</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.util.IPRange;</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.support.logging.Log;</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.support.logging.LogFactory;</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.util.StringUtils;</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.util.Utils;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.ServletException;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Log   LOG                 = LogFactory.getLog(ResourceServlet.class);</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SESSION_USER_KEY    = <span class="string">"druid-user"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAM_NAME_USERNAME = <span class="string">"loginUsername"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAM_NAME_PASSWORD = <span class="string">"loginPassword"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAM_NAME_ALLOW    = <span class="string">"allow"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAM_NAME_DENY     = <span class="string">"deny"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAM_REMOTE_ADDR   = <span class="string">"remoteAddress"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> String           username            = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">protected</span> String           password            = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> List&lt;IPRange&gt;    allowList           = <span class="keyword">new</span> ArrayList&lt;IPRange&gt;();</div><div class="line">    <span class="keyword">protected</span> List&lt;IPRange&gt;    denyList            = <span class="keyword">new</span> ArrayList&lt;IPRange&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String     resourcePath;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> String           remoteAddressHeader = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResourceServlet</span><span class="params">(String resourcePath)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.resourcePath = resourcePath;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">        initAuthEnv();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initAuthEnv</span><span class="params">()</span> </span>&#123;</div><div class="line">        String paramUserName = getInitParameter(PARAM_NAME_USERNAME);</div><div class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(paramUserName)) &#123;</div><div class="line">            <span class="keyword">this</span>.username = paramUserName;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String paramPassword = getInitParameter(PARAM_NAME_PASSWORD);</div><div class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(paramPassword)) &#123;</div><div class="line">            <span class="keyword">this</span>.password = paramPassword;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String paramRemoteAddressHeader = getInitParameter(PARAM_REMOTE_ADDR);</div><div class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(paramRemoteAddressHeader)) &#123;</div><div class="line">            <span class="keyword">this</span>.remoteAddressHeader = paramRemoteAddressHeader;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            String param = getInitParameter(PARAM_NAME_ALLOW);</div><div class="line">            <span class="keyword">if</span> (param != <span class="keyword">null</span> &amp;&amp; param.trim().length() != <span class="number">0</span>) &#123;</div><div class="line">                param = param.trim();</div><div class="line">                String[] items = param.split(<span class="string">","</span>);</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (String item : items) &#123;</div><div class="line">                    <span class="keyword">if</span> (item == <span class="keyword">null</span> || item.length() == <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    IPRange ipRange = <span class="keyword">new</span> IPRange(item);</div><div class="line">                    allowList.add(ipRange);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            String msg = <span class="string">"initParameter config error, allow : "</span> + getInitParameter(PARAM_NAME_ALLOW);</div><div class="line">            LOG.error(msg, e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            String param = getInitParameter(PARAM_NAME_DENY);</div><div class="line">            <span class="keyword">if</span> (param != <span class="keyword">null</span> &amp;&amp; param.trim().length() != <span class="number">0</span>) &#123;</div><div class="line">                param = param.trim();</div><div class="line">                String[] items = param.split(<span class="string">","</span>);</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (String item : items) &#123;</div><div class="line">                    <span class="keyword">if</span> (item == <span class="keyword">null</span> || item.length() == <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    IPRange ipRange = <span class="keyword">new</span> IPRange(item);</div><div class="line">                    denyList.add(ipRange);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            String msg = <span class="string">"initParameter config error, deny : "</span> + getInitParameter(PARAM_NAME_DENY);</div><div class="line">            LOG.error(msg, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPermittedRequest</span><span class="params">(String remoteAddress)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> ipV6 = remoteAddress != <span class="keyword">null</span> &amp;&amp; remoteAddress.indexOf(<span class="string">':'</span>) != -<span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (ipV6) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"0:0:0:0:0:0:0:1"</span>.equals(remoteAddress) || (denyList.size() == <span class="number">0</span> &amp;&amp; allowList.size() == <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        IPAddress ipAddress = <span class="keyword">new</span> IPAddress(remoteAddress);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (IPRange range : denyList) &#123;</div><div class="line">            <span class="keyword">if</span> (range.isIPAddressInRange(ipAddress)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (allowList.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (IPRange range : allowList) &#123;</div><div class="line">                <span class="keyword">if</span> (range.isIPAddressInRange(ipAddress)) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getFilePath</span><span class="params">(String fileName)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> resourcePath + fileName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">returnResourceFile</span><span class="params">(String fileName, String uri, HttpServletResponse response)</span></span></div><div class="line">                                                                                                <span class="keyword">throws</span> ServletException,</div><div class="line">                                                                                                IOException &#123;</div><div class="line"></div><div class="line">        String filePath = getFilePath(fileName);</div><div class="line">        <span class="keyword">if</span> (fileName.endsWith(<span class="string">".jpg"</span>)) &#123;</div><div class="line">            <span class="keyword">byte</span>[] bytes = Utils.readByteArrayFromResource(filePath);</div><div class="line">            <span class="keyword">if</span> (bytes != <span class="keyword">null</span>) &#123;</div><div class="line">                response.getOutputStream().write(bytes);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String text = Utils.readFromResource(filePath);</div><div class="line">        <span class="keyword">if</span> (text == <span class="keyword">null</span>) &#123;</div><div class="line">            response.sendRedirect(uri + <span class="string">"/index.html"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (fileName.endsWith(<span class="string">".css"</span>)) &#123;</div><div class="line">            response.setContentType(<span class="string">"text/css;charset=utf-8"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fileName.endsWith(<span class="string">".js"</span>)) &#123;</div><div class="line">            response.setContentType(<span class="string">"text/javascript;charset=utf-8"</span>);</div><div class="line">        &#125;</div><div class="line">        response.getWriter().write(text);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line">        String contextPath = request.getContextPath();</div><div class="line">        String servletPath = request.getServletPath();</div><div class="line">        String requestURI = request.getRequestURI();</div><div class="line"></div><div class="line">        response.setCharacterEncoding(<span class="string">"utf-8"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (contextPath == <span class="keyword">null</span>) &#123; <span class="comment">// root context</span></div><div class="line">            contextPath = <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        String uri = contextPath + servletPath;</div><div class="line">        String path = requestURI.substring(contextPath.length() + servletPath.length());</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!isPermittedRequest(request)) &#123;</div><div class="line">            path = <span class="string">"/nopermit.html"</span>;</div><div class="line">            returnResourceFile(path, uri, response);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="string">"/submitLogin"</span>.equals(path)) &#123;</div><div class="line">            String usernameParam = request.getParameter(PARAM_NAME_USERNAME);</div><div class="line">            String passwordParam = request.getParameter(PARAM_NAME_PASSWORD);</div><div class="line">            <span class="keyword">if</span> (username.equals(usernameParam) &amp;&amp; password.equals(passwordParam)) &#123;</div><div class="line">                request.getSession().setAttribute(SESSION_USER_KEY, username);</div><div class="line">                response.getWriter().print(<span class="string">"success"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                response.getWriter().print(<span class="string">"error"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (isRequireAuth() <span class="comment">//</span></div><div class="line">            &amp;&amp; !ContainsUser(request)<span class="comment">//</span></div><div class="line">            &amp;&amp; !(<span class="string">"/login.html"</span>.equals(path) <span class="comment">//</span></div><div class="line">                 || path.startsWith(<span class="string">"/css"</span>)<span class="comment">//</span></div><div class="line">                 || path.startsWith(<span class="string">"/js"</span>) <span class="comment">//</span></div><div class="line">            || path.startsWith(<span class="string">"/img"</span>))) &#123;</div><div class="line">            <span class="keyword">if</span> (contextPath.equals(<span class="string">""</span>) || contextPath.equals(<span class="string">"/"</span>)) &#123;</div><div class="line">                response.sendRedirect(<span class="string">"/druid/login.html"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="string">""</span>.equals(path)) &#123;</div><div class="line">                    response.sendRedirect(<span class="string">"druid/login.html"</span>);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    response.sendRedirect(<span class="string">"login.html"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="string">""</span>.equals(path)) &#123;</div><div class="line">            <span class="keyword">if</span> (contextPath.equals(<span class="string">""</span>) || contextPath.equals(<span class="string">"/"</span>)) &#123;</div><div class="line">                response.sendRedirect(<span class="string">"/druid/index.html"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                response.sendRedirect(<span class="string">"druid/index.html"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="string">"/"</span>.equals(path)) &#123;</div><div class="line">            response.sendRedirect(<span class="string">"index.html"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (path.contains(<span class="string">".json"</span>)) &#123;</div><div class="line">            String fullUrl = path;</div><div class="line">            <span class="keyword">if</span> (request.getQueryString() != <span class="keyword">null</span> &amp;&amp; request.getQueryString().length() &gt; <span class="number">0</span>) &#123;</div><div class="line">                fullUrl += <span class="string">"?"</span> + request.getQueryString();</div><div class="line">            &#125;</div><div class="line">            response.getWriter().print(process(fullUrl));</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// find file in resources path</span></div><div class="line">        returnResourceFile(path, uri, response);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ContainsUser</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line">        HttpSession session = request.getSession(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">return</span> session != <span class="keyword">null</span> &amp;&amp; session.getAttribute(SESSION_USER_KEY) != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRequireAuth</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.username != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPermittedRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line">        String remoteAddress = getRemoteAddress(request);</div><div class="line">        <span class="keyword">return</span> isPermittedRequest(remoteAddress);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getRemoteAddress</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line">        String remoteAddress = <span class="keyword">null</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (remoteAddressHeader != <span class="keyword">null</span>) &#123;</div><div class="line">            remoteAddress = request.getHeader(remoteAddressHeader);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (remoteAddress == <span class="keyword">null</span>) &#123;</div><div class="line">            remoteAddress = request.getRemoteAddr();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> remoteAddress;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">process</span><span class="params">(String url)</span></span>;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>其中，<code>service</code>方法里有URL的判断，方法里有request和response，看上去就是流程的起点，但是一般我们写servlet都是从<code>doGet</code>和<code>doPost</code>入手的，这里面不知道做了什么封装，于是继续往父类去看，发现其父类是<code>javax.servlet.http.HttpServlet</code>，已经是J2EE定义的类了，我用的是tomcat容器，所以这个类由tomcat提供。里面有常见的<code>doPost</code>和<code>doGet</code>方法</p>
<p>可以看到，<code>doGet</code>和<code>doPost</code>方法默认都是不通的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">        <span class="keyword">throws</span> ServletException, IOException</div><div class="line">&#123;</div><div class="line">    String protocol = req.getProtocol();</div><div class="line">    String msg = lStrings.getString(<span class="string">"http.method_get_not_supported"</span>);</div><div class="line">    <span class="keyword">if</span> (protocol.endsWith(<span class="string">"1.1"</span>)) &#123;</div><div class="line">        resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line"></div><div class="line">    String protocol = req.getProtocol();</div><div class="line">    String msg = lStrings.getString(<span class="string">"http.method_post_not_supported"</span>);</div><div class="line">    <span class="keyword">if</span> (protocol.endsWith(<span class="string">"1.1"</span>)) &#123;</div><div class="line">        resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>赶紧去看注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Called by the server (via the &lt;code&gt;service&lt;/code&gt; method) to</div><div class="line"> * allow a servlet to handle a GET request.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;Overriding this method to support a GET request also</div><div class="line"> * automatically supports an HTTP HEAD request. A HEAD</div><div class="line"> * request is a GET request that returns no body in the</div><div class="line"> * response, only the request header fields.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;When overriding this method, read the request data,</div><div class="line"> * write the response headers, get the response's writer or...</div><div class="line"> * /</div><div class="line">protected void doGet(HttpServletRequest req, HttpServletResponse resp)</div><div class="line">        throws ServletException, IOException</div><div class="line">&#123;</div><div class="line">    //...</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * Called by the server (via the &lt;code&gt;service&lt;/code&gt; method)</div><div class="line"> * to allow a servlet to handle a POST request.</div><div class="line"> * </div><div class="line"> * ...</div><div class="line"> * </div><div class="line"> * &lt;p&gt;When overriding this method, read the request data,</div><div class="line"> * write the response headers...</div><div class="line"> * </div><div class="line"> */</div><div class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">	<span class="comment">//...</span></div><div class="line">&#125;</div><div class="line">     </div></pre></td></tr></table></figure>     
<p>原来这些方法是由<code>service</code>方法调用的，并且需要自己覆盖，很符合我们一贯的经验。再看看<code>service</code>方法是怎么回事：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Receives standard HTTP requests from the public</div><div class="line"> * &lt;code&gt;service&lt;/code&gt; method and dispatches</div><div class="line"> * them to the &lt;code&gt;do&lt;/code&gt;&lt;i&gt;Method&lt;/i&gt; methods defined in</div><div class="line"> * this class. This method is an HTTP-specific version of the</div><div class="line"> * &#123;<span class="doctag">@link</span> javax.servlet.Servlet#service&#125; method. There's no</div><div class="line"> * need to override this method.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> req   the &#123;<span class="doctag">@link</span> HttpServletRequest&#125; object that</div><div class="line"> *                  contains the request the client made of</div><div class="line"> *                  the servlet</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> resp  the &#123;<span class="doctag">@link</span> HttpServletResponse&#125; object that</div><div class="line"> *                  contains the response the servlet returns</div><div class="line"> *                  to the client</div><div class="line"> *</div><div class="line"> * <span class="doctag">@exception</span> IOException   if an input or output error occurs</div><div class="line"> *                              while the servlet is handling the</div><div class="line"> *                              HTTP request</div><div class="line"> *</div><div class="line"> * <span class="doctag">@exception</span> ServletException  if the HTTP request</div><div class="line"> *                                  cannot be handled</div><div class="line"> *</div><div class="line"> * <span class="doctag">@see</span> javax.servlet.Servlet#service</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">	<span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>这个方法是请求的统一接收入口，然后将请求分发到<code>doGet</code>、<code>doPost</code>、<code>doHead</code>等对应标准HTTP请求方法的方法去。注释里特地说明了没有必要覆盖这个方法，druid的开发者很直接粗暴，不管你请求方法是什么，全部一刀切，反正这玩意儿要求不高。总之，现在我们知道了，<code>service</code>方法就是请求的入口，这样我们再回去看看<code>com.alibaba.druid.support.http.ResourceServlet</code>的<code>service</code>方法，通过这个方法应该就能理顺整个流程。</p>
<p>将其方法代码加上我自己的注释贴出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 整个方法其实做的还是路由分发的工作，根据请求的地址，分别返回不同的资源，并且进行访问控制。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line">    String contextPath = request.getContextPath();</div><div class="line">    String servletPath = request.getServletPath();</div><div class="line">    String requestURI = request.getRequestURI();</div><div class="line"></div><div class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (contextPath == <span class="keyword">null</span>) &#123; <span class="comment">// root context</span></div><div class="line">        contextPath = <span class="string">""</span>;</div><div class="line">    &#125;</div><div class="line">    String uri = contextPath + servletPath;</div><div class="line">    String path = requestURI.substring(contextPath.length() + servletPath.length());</div><div class="line"></div><div class="line">    <span class="comment">// 禁止访问的时候返回nopermit.html，returnResourceFile这个方法很关键，下文说说</span></div><div class="line">    <span class="keyword">if</span> (!isPermittedRequest(request)) &#123;</div><div class="line">        path = <span class="string">"/nopermit.html"</span>;</div><div class="line">        returnResourceFile(path, uri, response);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* 从名字看来，这是接收登录请求的</span></div><div class="line">     * 很明显，校验就是匹配username和password是否都与配置的匹配，如果匹配就在session里塞点标识</div><div class="line">     * 很原始的做法，但是对于一个内部使用的线程池监控来说也不用做得太复杂</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (<span class="string">"/submitLogin"</span>.equals(path)) &#123;</div><div class="line">        String usernameParam = request.getParameter(PARAM_NAME_USERNAME);</div><div class="line">        String passwordParam = request.getParameter(PARAM_NAME_PASSWORD);</div><div class="line">        <span class="keyword">if</span> (username.equals(usernameParam) &amp;&amp; password.equals(passwordParam)) &#123;</div><div class="line">            request.getSession().setAttribute(SESSION_USER_KEY, username);</div><div class="line">            response.getWriter().print(<span class="string">"success"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            response.getWriter().print(<span class="string">"error"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* 拦截登录 */</span></div><div class="line">    <span class="keyword">if</span> (isRequireAuth() <span class="comment">//</span></div><div class="line">        &amp;&amp; !ContainsUser(request)<span class="comment">//</span></div><div class="line">        &amp;&amp; !(<span class="string">"/login.html"</span>.equals(path) <span class="comment">//</span></div><div class="line">             || path.startsWith(<span class="string">"/css"</span>)<span class="comment">//</span></div><div class="line">             || path.startsWith(<span class="string">"/js"</span>) <span class="comment">//</span></div><div class="line">        || path.startsWith(<span class="string">"/img"</span>))) &#123;</div><div class="line">        <span class="keyword">if</span> (contextPath.equals(<span class="string">""</span>) || contextPath.equals(<span class="string">"/"</span>)) &#123;</div><div class="line">            response.sendRedirect(<span class="string">"/druid/login.html"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="string">""</span>.equals(path)) &#123;</div><div class="line">                response.sendRedirect(<span class="string">"druid/login.html"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                response.sendRedirect(<span class="string">"login.html"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	 <span class="comment">// 缺省首页的跳转</span></div><div class="line">    <span class="keyword">if</span> (<span class="string">""</span>.equals(path)) &#123;</div><div class="line">        <span class="keyword">if</span> (contextPath.equals(<span class="string">""</span>) || contextPath.equals(<span class="string">"/"</span>)) &#123;</div><div class="line">            response.sendRedirect(<span class="string">"/druid/index.html"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            response.sendRedirect(<span class="string">"druid/index.html"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="string">"/"</span>.equals(path)) &#123;</div><div class="line">        response.sendRedirect(<span class="string">"index.html"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 在不改造的时候，正常监控一个druid实例，会发现页面的数据都是异步刷新的，</div><div class="line">     * 通过浏览器的开发者工具能发现取数据的请求都是json后缀的，所以这里就是监控数据流动的节点</div><div class="line">     * process方法是关键，而这个方法是一个抽象方法，由具体的实现类来实现，下文将回到&#123;@link com.alibaba.druid.support.http.StatViewServlet#process(String)&#125;方法里看</div><div class="line">     * /</div><div class="line">    if (path.contains(".json")) &#123;</div><div class="line">        String fullUrl = path;</div><div class="line">        if (request.getQueryString() != null &amp;&amp; request.getQueryString().length() &gt; 0) &#123;</div><div class="line">            fullUrl += "?" + request.getQueryString();</div><div class="line">        &#125;</div><div class="line">        response.getWriter().print(process(fullUrl));</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 在以上情况都不匹配的时候，返回资源文件</div><div class="line">    // find file in resources path</div><div class="line">    returnResourceFile(path, uri, response);</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>有两个方法需要看：</p>
<ol>
<li>returnResourceFile</li>
<li>process</li>
</ol>
<p><code>returnResourceFile</code>方法在<code>ResourceServlet</code>里面实现了（注释是我加的）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">returnResourceFile</span><span class="params">(String fileName, String uri, HttpServletResponse response)</span>                                                                       <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line"></div><div class="line">    String filePath = getFilePath(fileName);</div><div class="line">    <span class="comment">// 如果是jpg，则返回流</span></div><div class="line">    <span class="keyword">if</span> (fileName.endsWith(<span class="string">".jpg"</span>)) &#123;</div><div class="line">        <span class="keyword">byte</span>[] bytes = Utils.readByteArrayFromResource(filePath);</div><div class="line">        <span class="keyword">if</span> (bytes != <span class="keyword">null</span>) &#123;</div><div class="line">            response.getOutputStream().write(bytes);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 否则读取文件，返回文件内的文本</div><div class="line">     * 其中，Utils.readFromResource有这么关键的一行</div><div class="line">     * Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);</div><div class="line">     * 这和servlet初始化的时候是有关的</div><div class="line">     * ResourceServlet本身也是一个抽象类，其子类StatViewServlet初始化的时候指定了资源目录的路径：</div><div class="line">     * public StatViewServlet()&#123;</div><div class="line">     *     super("support/http/resources");</div><div class="line">     * &#125;</div><div class="line">     */</div><div class="line">    String text = Utils.readFromResource(filePath);</div><div class="line">    <span class="keyword">if</span> (text == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 如果请求的路径映射不到资源文件，则调到默认首页（其实就是将404指向了index.html）</span></div><div class="line">        response.sendRedirect(uri + <span class="string">"/index.html"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 如果是css或者是js文件，则还需要设置相应的响应头部</span></div><div class="line">    <span class="keyword">if</span> (fileName.endsWith(<span class="string">".css"</span>)) &#123;</div><div class="line">        response.setContentType(<span class="string">"text/css;charset=utf-8"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fileName.endsWith(<span class="string">".js"</span>)) &#123;</div><div class="line">        response.setContentType(<span class="string">"text/javascript;charset=utf-8"</span>);</div><div class="line">    &#125;</div><div class="line">    response.getWriter().write(text);</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>接着看process方法（注释是原有的）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 程序首先判断是否存在jmx连接地址，如果不存在，则直接调用本地的duird服务； 如果存在，则调用远程jmx服务。在进行jmx通信，首先判断一下jmx连接是否已经建立成功，如果已经</div><div class="line"> * 建立成功，则直接进行通信，如果之前没有成功建立，则会尝试重新建立一遍。.</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> url 要连接的服务地址</div><div class="line"> * <span class="doctag">@return</span> 调用服务后返回的json字符串</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">process</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">    String resp = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (jmxUrl == <span class="keyword">null</span>) &#123;</div><div class="line">        resp = statService.service(url);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;<span class="comment">// 连接在初始化时创建失败</span></div><div class="line">            <span class="keyword">try</span> &#123;<span class="comment">// 尝试重新连接</span></div><div class="line">                initJmxConn();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                LOG.error(<span class="string">"init jmx connection error"</span>, e);</div><div class="line">                resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR,</div><div class="line">                                                         <span class="string">"init jmx connection error"</span> + e.getMessage());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;<span class="comment">// 连接成功</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    resp = getJmxResult(conn, url);</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    LOG.error(<span class="string">"get jmx data error"</span>, e);</div><div class="line">                    resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR, <span class="string">"get data error:"</span></div><div class="line">                                                                                                 + e.getMessage());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 连接成功</span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                resp = getJmxResult(conn, url);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                LOG.error(<span class="string">"get jmx data error"</span>, e);</div><div class="line">                resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR,</div><div class="line">                                                         <span class="string">"get data error"</span> + e.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> resp;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>可见它是有重连的，而保证了连接成功之后，获取数据的方法是<code>getJmxResult</code>，这个是在<code>StatViewServlet</code>里面实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getJmxResult</span><span class="params">(MBeanServerConnection connetion, String url)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    ObjectName name = <span class="keyword">new</span> ObjectName(DruidStatService.MBEAN_NAME);</div><div class="line"></div><div class="line">    String result = (String) conn.invoke(name, <span class="string">"service"</span>, <span class="keyword">new</span> String[] &#123; url &#125;,</div><div class="line">                                         <span class="keyword">new</span> String[] &#123; String.class.getName() &#125;);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以实际上就是用MBeanServer的连接去直接取数据然后原样返回，所有的监控数据其实是缓存在被监控的目标处的，web的监控只是一个请求转发与展示的作用。</p>
<p>所以现在总结StatViewServlet整个工作的主要过程：</p>
<ol>
<li>记录用户名和密码</li>
<li>根据配置的jmxUrl初始化jmx连接</li>
<li>接收请求，分发请求</li>
<li>如果请求是json数据请求，则通过jmx连接到被监控对象处取数据，然后返回</li>
</ol>
<h1 id="3-改进思路"><a href="#3-改进思路" class="headerlink" title="3. 改进思路"></a>3. 改进思路</h1><h2 id="3-1-思路一：动态创建并注册StatViewServlet"><a href="#3-1-思路一：动态创建并注册StatViewServlet" class="headerlink" title="3.1 思路一：动态创建并注册StatViewServlet"></a>3.1 思路一：动态创建并注册StatViewServlet</h2><p>这是首先想到的思路，因为使用这种办法不需要对druid的web监控细节了解多少。要实现这个目标，需要做到以下两点之一：</p>
<ol>
<li>对于Java Web容器的启动过程很了解，并且深入细节</li>
<li>Google能找到相似的例子</li>
</ol>
<p>第一点我还做不到，短时间内也做不到，所以只能往第二点去努力。找到了一个最贴切的办法是：<br><a href="http://javaevangelist.blogspot.co.id/2012/11/dynamic-servlet-registration-example.html" target="_blank" rel="external">Dynamic Servlet Registration Example</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletRegistration;</div><div class="line"><span class="keyword">import</span> javax.servlet.annotation.WebListener;</div><div class="line"></div><div class="line"><span class="meta">@WebListener</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletContextListenerImpl</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(<span class="keyword">final</span> ServletContextEvent sce)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> ServletContext servletContext = sce.getServletContext();</div><div class="line">        <span class="keyword">final</span> ServletRegistration.Dynamic dynamic = servletContext.addServlet(<span class="string">"Example Servlet"</span>, ExampleServlet.class);</div><div class="line">        dynamic.addMapping(<span class="string">"/"</span>);</div><div class="line"> </div><div class="line">        <span class="keyword">final</span> Map&lt;String, ? extends ServletRegistration&gt; map = servletContext.getServletRegistrations();</div><div class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</div><div class="line">            servletContext.log(<span class="string">"Registered Servlet: "</span> + map.get(key).getName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(<span class="keyword">final</span> ServletContextEvent sce)</span> </span>&#123;</div><div class="line">        <span class="comment">//NO-OP</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>主要就是实现<code>javax.servlet.ServletContextListener</code>，通过<code>javax.servlet.ServletContextEvent</code>实例获取<code>javax.servlet.ServletContext</code>实例，然后调用它的方法去注册新的servlet。</p>
<p>看上去好像可行的样子，但是在实际运行起来之后，在这一行报错了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> ServletRegistration.Dynamic dynamic = servletContext.addServlet(<span class="string">"Example Servlet"</span>, ExampleServlet.class);</div></pre></td></tr></table></figure>
<p>错误信息没有记录下来，但是意思就是说这个操作是不支持的，反正就是没戏。具体为什么，还需要进一步了解。</p>
<h2 id="3-2-思路二：修改StatViewServlet的机制"><a href="#3-2-思路二：修改StatViewServlet的机制" class="headerlink" title="3.2 思路二：修改StatViewServlet的机制"></a>3.2 思路二：修改StatViewServlet的机制</h2><p>在第一个思路走不通之后，只能从其工作机制上入手。其原理分析已经在上文给出。</p>
<p>因为只要有JMX的连接就可以获取数据了，所以关键在于以下几点：</p>
<ol>
<li>持有多个jmx连接并且与不同的请求关联起来</li>
<li>根据配置去动态创建连接</li>
<li>将原本固定的几个页面与配置的多个监控对象动态地对应起来</li>
<li>配置能根据部署环境的不同而改变，并且发生变更的时候能轻易修改</li>
<li>列出所有被监控对象</li>
</ol>
<p>对于第一点，创建jmx连接只要有jmxUrl就够了，所以很容易做到，至于与请求关联起来，其实就是从请求的url里提取特征，用于表示不同的监控对象，然后将此特征映射到对应的jmx连接即可。</p>
<p>对于第二点，这其实就是普通的读取、解析配置，然后用配置信息去初始化jmx连接（当然还有登录名、密码和黑白名单等）。</p>
<p>第三点，转下弯，原有的逻辑是将url直接映射为资源文件，只要在这中间加一层解析即可。</p>
<p>第四点，简单的方案是配置多个配置文件，根据不同的环境打不同的包。但是这种做法不灵活，最好还是做成注册中心的形式，被监控对象启动的时候网注册中心写入信息，这边从注册中心读，还有下线机制。但是这种做法工作量大，而且要改被监控的一方，容易引入bug。要不就与配置中心集成，这样就只需改动web监控一端即可。这里的配置方案有多种，很适合采用SPI。</p>
<p>第五点，根据配置信息做个汇总，然后给个页面列出来就可以。</p>
<h1 id="4-实现"><a href="#4-实现" class="headerlink" title="4 实现"></a>4 实现</h1><p>上文提及的问题在这里基本上都解决了，思路都讲清楚了，实现就不再重复讲。请移步我github的仓库：<a href="https://github.com/bungder/druid-aggregated-monitor" target="_blank" rel="external">https://github.com/bungder/druid-aggregated-monitor</a></p>
<p>在这里提提失败重连的问题</p>
<h2 id="4-1重连失败的问题"><a href="#4-1重连失败的问题" class="headerlink" title="4.1重连失败的问题"></a>4.1重连失败的问题</h2><p>其重连失败的问题，在debug的时候发现其实并没有重连，它重连的条件是conn为null，但是实际上conn初始化之后就不会为null了，但是当连接失效之后，里面的<code>terminated</code>属性为<code>true</code>，而<code>MBeanServerConnection</code>是一个<code>interface</code>，本身没定义操作这个属性的方法，并且至少有两个类实现了这个接口，运行时的实际类型并不确定是否总是某个实现类型，所以也不好去强转类型进行操作。但是可以利用它本身的逻辑：既然它触发重连的条件是conn为null，我就将它设成null好了。当conn不为null但是获取数据又出错的时候，就可以判断连接有问题，不妨触发重试，即使这种情况下不一定是连接失效了，但是正常情况下不会出现这种现象，就将其当成是连接失效也无妨。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h1&gt;&lt;p&gt;druid本身提供了监控功能，具体在我另一篇博文《&lt;a href=&quot;/2017/08/27/druid-monitor/&quot;&gt;Druid连接池监控&lt;/a&gt;》里有介绍。当时提到有以下缺陷：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无法灵活监控多个目标&lt;/li&gt;
&lt;li&gt;切换环境不方便&lt;/li&gt;
&lt;li&gt;JMX重连不会成功&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此针对这些问题，对其进行改造。改造后的源码已经放在个人的github上：&lt;br&gt;&lt;a href=&quot;https://github.com/bungder/druid-aggregated-monitor&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/bungder/druid-aggregated-monitor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应本文的版本，已经打了tag：&lt;br&gt;&lt;a href=&quot;https://github.com/bungder/druid-aggregated-monitor/releases/tag/0.0.1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/bungder/druid-aggregated-monitor/releases/tag/0.0.1&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="druid" scheme="http://bungder.github.io/tags/druid/"/>
    
      <category term="连接池" scheme="http://bungder.github.io/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
      <category term="监控" scheme="http://bungder.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Druid连接池监控</title>
    <link href="http://bungder.github.io/2017/08/27/druid-monitor/"/>
    <id>http://bungder.github.io/2017/08/27/druid-monitor/</id>
    <published>2017-08-27T09:43:32.000Z</published>
    <updated>2017-09-01T13:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-普通的web监控"><a href="#1-普通的web监控" class="headerlink" title="1. 普通的web监控"></a>1. 普通的web监控</h1><p>阿里开源的连接池Druid自带了web监控的功能，具体的操作在其github的wiki上可以找到：<a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatViewServlet%E9%85%8D%E7%BD%AE" target="_blank" rel="external">配置_StatViewServlet配置 · alibaba/driud wiki</a></p>
<p>其实主要就是配置一个Servlet，但是github wiki上的做法只能在druid所在的项目中启用web服务的做法，在如今盛行的微服务架构中，很多时候druid所在的服务里并不提供web服务，这就需要额外的配置。其实druid本身也提供了这种功能，只是wiki里没有说。</p>
<p>druid本身可以通过启用JMX端口来将监控数据传输到远端进行处理，具体做法是：</p>
<ol>
<li>在启动服务的时候加上JVM启动参数（下文说）</li>
<li>在远端启用web服务，配置StatViewServlet，在initParam中指定JMX地址</li>
</ol>
<a id="more"></a>
<h2 id="1-1-JVM启动参数："><a href="#1-1-JVM启动参数：" class="headerlink" title="1.1 JVM启动参数："></a>1.1 JVM启动参数：</h2><blockquote>
<p>-Djava.net.preferIPv4Stack=true<br>-Dcom.sun.management.jmxremote<br>-Djava.rmi.server.hostname=192.168.199.123<br>-Dcom.sun.management.jmxremote.port=9876<br>-Dcom.sun.management.jmxremote.authenticate=false<br>-Dcom.sun.management.jmxremote.ssl=false</p>
</blockquote>
<p>其中，<code>-Djava.rmi.server.hostname</code>一项指定了服务所在的IP地址，<code>-Dcom.sun.management.jmxremote.port</code>一项指定了JMX端口。</p>
<h2 id="1-2-远程web工程Servlet配置"><a href="#1-2-远程web工程Servlet配置" class="headerlink" title="1.2 远程web工程Servlet配置"></a>1.2 远程web工程Servlet配置</h2><p>在web.xml里添加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DruidStatView<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.alibaba.druid.support.http.StatViewServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 远程访问JavaSE项目使用jmx连接 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>jmxUrl<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>service:jmx:rmi:///jndi/rmi://192.168.199.123:9876/jmxrmi<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>loginUsername<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>loginPassword<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DruidStatView<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/druid/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果想快速打包启动，不依赖外部web容器，可以采用SpringBoot，用嵌入式的web容器启动，原理也是一样。具体做法是：</p>
<ol>
<li>创建Servlet：</li>
</ol>
<figure class="highlight java"><figcaption><span>DruidStatViewServlet.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.tansc.test.springboot.config.druid;</div><div class="line">	</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.StatViewServlet;</div><div class="line">	</div><div class="line"><span class="keyword">import</span> javax.servlet.annotation.WebInitParam;</div><div class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</div><div class="line">	</div><div class="line"><span class="comment">/**</span></div><div class="line"> * StatViewServlet</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</div><div class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/druid/*"</span>,</div><div class="line">    initParams=&#123;</div><div class="line">            <span class="meta">@WebInitParam</span>(name=<span class="string">"loginUsername"</span>,value=<span class="string">"admin"</span>),<span class="comment">// 用户名</span></div><div class="line">            <span class="meta">@WebInitParam</span>(name=<span class="string">"loginPassword"</span>,value=<span class="string">"admin"</span>),<span class="comment">// 密码</span></div><div class="line">            <span class="meta">@WebInitParam</span>(name=<span class="string">"jmxUrl"</span>,value=<span class="string">"service:jmx:rmi:///jndi/rmi://192.168.199.123:9876/jmxrmi"</span>),</div><div class="line">            <span class="meta">@WebInitParam</span>(name=<span class="string">"resetEnable"</span>,value=<span class="string">"false"</span>)<span class="comment">// 禁用HTML页面上的“Reset All”功能</span></div><div class="line">    &#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidStatViewServlet</span> <span class="keyword">extends</span> <span class="title">StatViewServlet</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>在启动类上加上注解<code>@ServletComponentScan(&quot;com.tansc.test.springboot&quot;)</code>以扫描Servlet。</li>
</ol>
<h2 id="1-3-查看监控数据"><a href="#1-3-查看监控数据" class="headerlink" title="1.3 查看监控数据"></a>1.3 查看监控数据</h2><p>上面的都配置好之后，启动服务，等服务启动成功之后，启动远端的web服务，然后访问web服务的<code>/druid</code>目录（与上面配置的匹配即可），例如在我本地起的：<code>http://127.0.0.1:8080/druid</code></p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/druid-monitor.png" alt=""></p>
<h2 id="1-4-缺陷"><a href="#1-4-缺陷" class="headerlink" title="1.4 缺陷"></a>1.4 缺陷</h2><ol>
<li>这种做法是一对一的，也就是一个druid连接池实例必须对应一个StatViewServlet，一个StatViewServlet也只能对应一个druid实例。</li>
<li>切换环境不方便</li>
<li>JMX重连不会成功<ul>
<li>虽然远端会有重连机制，但是在服务重启之后，重连总是报Connection refused，只能将远端的web服务重启才能成功连上（后来发现这其实没有重连，报错只是使用一个已经terminated的连接获取数据报错，具体见下一篇博文）</li>
</ul>
</li>
</ol>
<h2 id="1-5-改进"><a href="#1-5-改进" class="headerlink" title="1.5 改进"></a>1.5 改进</h2><p>对于上面提到的两点缺陷，可以用以下两个思路去改进：</p>
<ol>
<li>动态创建servlet，模仿分布式服务的注册中心的形式来改造<ul>
<li>Servlet本身不提供这样的API，但是应该是可以做到的，具体要继续探索。</li>
</ul>
</li>
<li>使用配置文件<ul>
<li>web.xml里面本身不能读取配置文件的值，但是可以通过继承StatViewServlet来实现。</li>
</ul>
</li>
<li>需要分析源码</li>
</ol>
<p>（2017-08-31 目前已经改造了，见我下一篇博文：<a href="/2017/08/31/druid-monitor-remould/">Druid连接池监控的一次改造</a>）</p>
<h2 id="1-6-性能损耗"><a href="#1-6-性能损耗" class="headerlink" title="1.6 性能损耗"></a>1.6 性能损耗</h2><p>当远程的web服务启动并且在浏览器里访问统计页面之后，该服务的内存变化如下：<br><img src="http://otlnkjq1m.bkt.clouddn.com/JProfiler8-RecordedObjects.jpg" alt=""></p>
<h1 id="2-持久化-自定义传输监控记录"><a href="#2-持久化-自定义传输监控记录" class="headerlink" title="2. 持久化/自定义传输监控记录"></a>2. 持久化/自定义传输监控记录</h1><p>可以通过定制StatLogger实现，具体见其github的wiki：<br><a href="https://github.com/alibaba/druid/wiki/%E6%80%8E%E4%B9%88%E4%BF%9D%E5%AD%98Druid%E7%9A%84%E7%9B%91%E6%8E%A7%E8%AE%B0%E5%BD%95" target="_blank" rel="external">怎么保存Druid的监控记录 · alibaba/driud wiki</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>配置StatFilter · alibaba/driud wiki<br><a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatFilter" target="_blank" rel="external">https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatFilter</a></li>
<li>非web项目如何配置Druid监控 - 若鱼的专栏 - CSDN博客<br><a href="http://blog.csdn.net/goldenfish1919/article/details/68941237" target="_blank" rel="external">http://blog.csdn.net/goldenfish1919/article/details/68941237</a></li>
<li>Spring Boot 使用 Druid 和监控配置 - 小单的博客专栏 - CSDN博客<br><a href="http://blog.csdn.net/catoop/article/details/50925337" target="_blank" rel="external">http://blog.csdn.net/catoop/article/details/50925337</a></li>
<li>怎么保存Druid的监控记录 · alibaba/driud wiki<br><a href="https://github.com/alibaba/druid/wiki/%E6%80%8E%E4%B9%88%E4%BF%9D%E5%AD%98Druid%E7%9A%84%E7%9B%91%E6%8E%A7%E8%AE%B0%E5%BD%95" target="_blank" rel="external">https://github.com/alibaba/druid/wiki/%E6%80%8E%E4%B9%88%E4%BF%9D%E5%AD%98Druid%E7%9A%84%E7%9B%91%E6%8E%A7%E8%AE%B0%E5%BD%95</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-普通的web监控&quot;&gt;&lt;a href=&quot;#1-普通的web监控&quot; class=&quot;headerlink&quot; title=&quot;1. 普通的web监控&quot;&gt;&lt;/a&gt;1. 普通的web监控&lt;/h1&gt;&lt;p&gt;阿里开源的连接池Druid自带了web监控的功能，具体的操作在其github的wiki上可以找到：&lt;a href=&quot;https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatViewServlet%E9%85%8D%E7%BD%AE&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;配置_StatViewServlet配置 · alibaba/driud wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实主要就是配置一个Servlet，但是github wiki上的做法只能在druid所在的项目中启用web服务的做法，在如今盛行的微服务架构中，很多时候druid所在的服务里并不提供web服务，这就需要额外的配置。其实druid本身也提供了这种功能，只是wiki里没有说。&lt;/p&gt;
&lt;p&gt;druid本身可以通过启用JMX端口来将监控数据传输到远端进行处理，具体做法是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在启动服务的时候加上JVM启动参数（下文说）&lt;/li&gt;
&lt;li&gt;在远端启用web服务，配置StatViewServlet，在initParam中指定JMX地址&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="druid" scheme="http://bungder.github.io/tags/druid/"/>
    
      <category term="连接池" scheme="http://bungder.github.io/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
      <category term="监控" scheme="http://bungder.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>持续集成简述</title>
    <link href="http://bungder.github.io/2017/07/24/CI/"/>
    <id>http://bungder.github.io/2017/07/24/CI/</id>
    <published>2017-07-24T13:51:48.000Z</published>
    <updated>2017-08-28T12:47:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1    概述"></a>1    概述</h1><p>互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration, CI）。持续集成也被认为是敏捷开发的最重要实践之一。</p>
<p>本文主要介绍持续集成的概念以及一些工具与实践。</p>
<h1 id="2-概念"><a href="#2-概念" class="headerlink" title="2    概念"></a>2    概念</h1><p><img src="http://otlnkjq1m.bkt.clouddn.com/CI-notion-relation.png" alt="图2.1 持续集成概念示意图之一"><br>图2.1 持续集成概念示意图之一</p>
<p>上图来源于<a href="http://blog.flow.ci/cicd_difference/" target="_blank" rel="external">谈谈持续集成，持续交付，持续部署之间的区别</a>，这图很直观地描述了持续集成相关的概念之间的关系，与持续集成密切相关的概念还有持续交付、持续部署，因此在下文将会就这三个概念进行阐述。</p>
<a id="more"></a>
<h2 id="2-1-持续集成"><a href="#2-1-持续集成" class="headerlink" title="2.1    持续集成"></a>2.1    持续集成</h2><p>维基百科的定义（<a href="https://en.wikipedia.org/wiki/Continuous_integration" target="_blank" rel="external">Continuous integration - Wikipedia</a>）：</p>
<blockquote>
<p>在软件工程里，持续集成（Continuous Integration, CI）是指这样的一种实践：在一天里多次将所有开发人员的代码合并到一个共享的主干里，每次合并都会触发持续集成服务器进行自动构建，这个过程包括了编译、单元测试、集成测试、质量分析等步骤，结果只有两个：成功或者失败。如果得到失败的结果，说明有人提交了不合格的代码，这就能及时发现问题。</p>
</blockquote>
<p>在瀑布模型中，软件的开发过程被分为以下几个阶段：</p>
<ul>
<li>需求分析</li>
<li>系统设计</li>
<li>编码实现</li>
<li>测试</li>
<li>集成</li>
<li>部署</li>
<li>维护</li>
</ul>
<p>而一般在实际的开发中，基本也就遵循这些步骤进行开发，大部分情况下，不会完全按照瀑布流的方式执行，但是这些步骤都是有的，无非就是在文档的落实、步骤的次序与侧重有所变化。其中，所谓的集成，在平时的开发过程中很少直接提到这个名词，其含义是（见：<a href="https://en.wikipedia.org/wiki/System_integration" target="_blank" rel="external">System integration - Wikipedia</a>）：</p>
<blockquote>
<p>将子系统的组件整合到一个系统中并且确保子系统的功能可以组合为一个系统的过程。</p>
</blockquote>
<p>所以，所谓的『集成』就是在存在多个系统协作的情况下，将子系统集成为一个大系统的过程，这个概念与『集成测试』中的『集成』是同一个概念。但是有些文章在解释『持续集成』这个概念的时候，将其解释为『将代码集成到主干分支』，目前也没见到有人说这是错的。</p>
<p>如果只有一个系统，那么就不存在『系统集成』这一个步骤，但是『持续集成』这个做法还是可以应用其中的，因为『持续集成』的精髓不在于『集成』，而在于『持续』，而我所理解的『持续』，就是将一些重复的操作自动化，然后频繁地触发这个自动化过程。</p>
<p>所以，结合上面提到的瀑布模型的几个阶段，以及『持续集成』这个名字，图2.1应该改为这样：</p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/CI-notion-relation-2.png" alt="图2.2 持续集成概念示意图之二"><br>图2.2 持续集成概念示意图之二</p>
<p>从上图中看来，持续集成应该至少包括以下几部分:</p>
<ul>
<li>自动化构建</li>
<li>自动化测试</li>
<li>自动发布</li>
</ul>
<p><img src="http://7xsn88.com1.z0.glb.clouddn.com/image/f/82/6ce32afc227588c4b60b143501dcd.png" alt="图2.3 持续集成阶段示意图"><br>图2.3 持续集成阶段示意图</p>
<p>每一次的构建与测试，都应该得到一个结果：通过或者不通过，开发人员应该都能看到每一次构建与测试的结果，得到不通过的结果时应该能马上修复相关的缺陷，这就需要有一种合适的反馈渠道。</p>
<h3 id="2-1-1-自动化构建"><a href="#2-1-1-自动化构建" class="headerlink" title="2.1.1 自动化构建"></a>2.1.1 自动化构建</h3><p>自动化构建包括以下过程：</p>
<ul>
<li>将源码编译成为二进制码</li>
<li>打包二进制码</li>
<li>运行自动化测试</li>
<li>生成文档</li>
<li>生成分发媒体（例如：Debian DEB、Red Hat RPM或者Windows MSI文件）</li>
</ul>
<p>自动化构建可以通过两类工具实现：</p>
<ol>
<li>构建自动化软件（Build automation utility）<ul>
<li>例如Make、Ant、Maven、Gradle，目的是通过编译等活动来生成构建产物（build artifact）。</li>
</ul>
</li>
<li>构建自动化服务器（Build automation servers）<ul>
<li>一般是基于web的工具，通过计划任务或者是事件触发的方式调用构建自动化软件。一个CI服务器就是一类构建自动化服务器。</li>
</ul>
</li>
</ol>
<h3 id="2-1-2-自动化测试"><a href="#2-1-2-自动化测试" class="headerlink" title="2.1.2    自动化测试"></a>2.1.2    自动化测试</h3><p>自动化测试是持续集成必不可少的一部分，基本上，没有自动化测试的持续集成，都很难称之为真正的持续集成。我们希望持续集成能够尽早的暴露问题，但这远非配置一个 Hudson/Jenkins服务器那么简单，只有真正用心编写了较为完整的测试用例，并一直维护它们，持续集成才能孜孜不倦地运行测试并第一时间报告问题。</p>
<p>测试自动化是使用特定的软件（独立于被测试的软件）来控制测试的执行以及比较实际输出与预期输出。测试自动化可以将某些重复但必要的任务自动化，或者执行某些难以手动执行的额外测试。</p>
<p>自动化测试还包括单元测试、集成测试、系统测试、验收测试、性能测试等，在不同的场景下，它们都能为软件开发带来极大的价值。</p>
<h4 id="2-1-2-1-单元测试"><a href="#2-1-2-1-单元测试" class="headerlink" title="2.1.2.1    单元测试"></a>2.1.2.1    单元测试</h4><p>单元测试（Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</p>
<p>通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到预期的工作目标，没有程序错误。</p>
<h4 id="2-1-2-2-集成测试"><a href="#2-1-2-2-集成测试" class="headerlink" title="2.1.2.2    集成测试"></a>2.1.2.2    集成测试</h4><p>集成测试（Integration Testing，有时也叫Integration and Testing, I&amp;T）即对独立的软件模块组装起来看成是一个整体进行测试。集成测试一般在单元测试之后、系统测试之前进行。实践表明，有时模块虽然可以单独工作，但是并不能保证组装起来也可以同时工作。</p>
<p>集成与单元测试最大的区别是它需要尽可能的测试整个功能及相关环境，对于测试Web应用而言，通常有这么几步：</p>
<ol>
<li>启动Web容器</li>
<li>部署待测试Web应用</li>
<li>以Web客户端的角色运行测试用例</li>
<li>停止Web容器</li>
</ol>
<p>通常有三种手段实现集成测试：</p>
<ol>
<li><p>大爆炸（Big Bang）<br>将所有单元组合到一起一次性测试一遍。</p>
</li>
<li><p>自上而下（Top Down）<br>先测试高层次的单元，然后逐渐测试低层次的单元。</p>
</li>
<li><p>自下而上（Bottom Up）<br>先测试低层次的单元，然后逐渐测试高层次的单元。</p>
</li>
</ol>
<h2 id="2-2-持续交付"><a href="#2-2-持续交付" class="headerlink" title="2.2    持续交付"></a>2.2    持续交付</h2><p><img src="http://7xsn88.com1.z0.glb.clouddn.com/image/e/bd/d757dd642e93e33fede310325b155.png" alt=""><br>图2.4 持续交付示意图</p>
<p>持续交付（Continuous Delivery, CD）是一种软件工程的手段，让软件在短周期内产出，确保软件随时可以被可靠地发布。其目的在于更快、更频繁地构建、测试以及发布软件。通过加强对生产环境的应用进行渐进式更新，这种手段可以降低交付变更的成本与风险。一个简单直观的与可重复的部署过程对于持续交付来说是很重要的。</p>
<h3 id="2-2-1-与DevOps的关系"><a href="#2-2-1-与DevOps的关系" class="headerlink" title="2.2.1 与DevOps的关系"></a>2.2.1 与DevOps的关系</h3><p>持续交付与DevOps的含义很相似，所以经常被混淆。但是它们是不同的两个概念。DevOps的范围更广，它以文化变迁为中心，特别是软件交付过程所涉及的多个团队之间的合作（开发、运维、QA、管理部门等），并且将软件交付的过程自动化。另一方面，持续交付是一种自动化交付的手段，关注点在于将不同的过程集中起来，并且更快、更频繁地执行这些过程。因此，DevOps可以是持续交付的一个产物，持续交付直接汇入DevOps。</p>
<h3 id="2-2-2-与持续部署的关系"><a href="#2-2-2-与持续部署的关系" class="headerlink" title="2.2.2 与持续部署的关系"></a>2.2.2 与持续部署的关系</h3><p>有时候，持续交付也与持续部署混淆。持续部署意味着所有的变更都会被自动部署到生产环境中。持续交付意味着所有的变更都可以被部署到生产环境中，但是出于业务考虑，可以选择不部署。如果要实施持续部署，必须先实施持续交付。</p>
<h3 id="2-2-3-原则"><a href="#2-2-3-原则" class="headerlink" title="2.2.3 原则"></a>2.2.3 原则</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c3/Continuous_Delivery_process_diagram.svg" alt=""><br>图2.5 持续交付流水线示意图</p>
<p>持续交付将部署流水线（<strong>deployment pipeline</strong>）这个老生常谈的概念看作一种简单的防错方法：一系列的确认。通过这些确认，一款软件必须遵循特定的路径来发布。每当有变更被提交到源码控制仓库中时，代码要首先进行编译（有必要的话），然后由构建服务器进行打包，接着由一些不同的技术来进行测试，最后才可以将代码标记为可发布的（releasable）。</p>
<p>在一个持续交付环境中工作时，习惯了漫长开发周期的开发人员或许需要改变他们心态。任何代码提交在任何时间点都可能会向客户发布，明白这一点是很重要的。对于在早期提交尚未准备好让用户使用的代码，类似功能开关这样的模式是很有用的。使用NoSQL可以消除持续交付工作流中的数据迁移和模式变更的步骤、手工操作步骤以及异常情况。对于代码隔离的其他有用的技术——例如代码分支——在持续交付工作流中并未过时，但是必须加以修改以适应持续交付的原则。例如，运行多个长生命周期的代码分支是不实际的，因为一个可发布的产物如果要经历流水线的所有阶段，它必须从一个单独的分支中构建而来。</p>
<h2 id="2-3-持续部署"><a href="#2-3-持续部署" class="headerlink" title="2.3    持续部署"></a>2.3    持续部署</h2><p><img src="http://7xsn88.com1.z0.glb.clouddn.com/image/0/3a/6b241b45b65eb7d77927619015d84.png" alt=""><br>图2.6 持续部署示意图</p>
<p>如图所示，持续部署与持续交付之间的差异就是前者将部署自动化了。</p>
<p>在持续交付的实践中，交付的目标是QA，但是实际上，软件最终是要交付到客户手上的。在SaaS领域里，持续部署采用得比较广泛，因为服务比较容易做到静默升级。</p>
<p>采用持续部署的前提是自动化测试的覆盖率足够高。</p>
<p>采用持续部署的好处是能减少运维的工作量，缩短新特性从开发到实际交付的周期。</p>
<h1 id="3-代价与好处"><a href="#3-代价与好处" class="headerlink" title="3    代价与好处"></a>3    代价与好处</h1><h2 id="3-1-代价"><a href="#3-1-代价" class="headerlink" title="3.1    代价"></a>3.1    代价</h2><ol>
<li>构造自动测试用例会耗费大量的工作，而且要去覆盖不断增加的新功能点，也要随着代码的改动去修改测试用例。<ul>
<li>测试被视为软件开发的一种最佳实践。无论是否采用持续集成，在一些方法论里——例如测试驱动开发——自动化测试都是必不可少的一部分。</li>
<li>采用持续集成的时候也可以不使用任何测试用例，但是在发布一个产品之前的质量保证（Quality Assurance）成本就会变得很高，因为一切都要频繁地采用人手操作。</li>
</ul>
</li>
<li>要花费精力去部署一个构建系统，这有时候会比较复杂，难以灵活地修改<ul>
<li>然而，有大量的开源的持续集成软件项目，选择很多</li>
</ul>
</li>
<li>如果项目比较小，或者包含了未经测试的遗留代码，持续集成的价值就并不是那么大</li>
<li>持续集成所增加的价值依赖于测试的质量以及代码实际上的可测试程度。</li>
<li>团队规模大就意味着代码会非常频繁地提交到集成队列里，跟踪提交就会比较困难，并且排队进行构建会减慢每个人的工作，如果构建失败，整个开发团队必须停下手里的工作，立刻修复他们的错误。<ul>
<li>但是持续集成是可以灵活变通的，不一定要在一天里多次构建，可以配置每天下班前半小时自动构建，有错误的话开发人员可以在下班前进行处理；或者每天凌晨自动构建，第二天早上开发人员一上班就能看到构建的结果报告，然后进行处理。</li>
</ul>
</li>
<li>一天里有多个提交和合并，一个新功能的部分代码能轻易地推送上去，在新功能完成之前，集成测试都是不通过的。</li>
</ol>
<h2 id="3-2-好处"><a href="#3-2-好处" class="headerlink" title="3.2    好处"></a>3.2    好处</h2><ol>
<li>能快速发现错误和定位错误</li>
<li>避免在发布日期大家都在检查自己有冲突的版本，造成混乱</li>
<li>当单元测试不通过或者出现bug的时候，如果开发人员需要回滚代码，只会造成少量的改动丢失，因为集成是频繁的。</li>
<li>防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。</li>
<li>无论对于测试、demo还是发布的目的或需求，总是有一份当前的构建可用。</li>
<li>频繁的代码检查驱使开发人员编写模块化的、低复杂度的代码。</li>
</ol>
<h1 id="4-具体实践"><a href="#4-具体实践" class="headerlink" title="4    具体实践"></a>4    具体实践</h1><h2 id="4-1-工具"><a href="#4-1-工具" class="headerlink" title="4.1    工具"></a>4.1    工具</h2><table>
<thead>
<tr>
<th>名称</th>
<th>授权</th>
<th>价格</th>
<th>Git支持</th>
<th>Docker支持</th>
<th>自动测试</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Jenkins</td>
<td>MIT</td>
<td>免费</td>
<td>不支持</td>
<td>不支持</td>
<td>需插件支持</td>
<td></td>
</tr>
<tr>
<td>GitLab CI</td>
<td>MIT</td>
<td>免费</td>
<td>支持</td>
<td>支持</td>
<td>需自配测试服务</td>
<td></td>
</tr>
<tr>
<td>Phabricator</td>
<td>Apache 2.0</td>
<td>免费</td>
<td>支持</td>
<td></td>
<td></td>
<td>Facebook出品</td>
</tr>
<tr>
<td>Travis CI</td>
<td></td>
<td>免费</td>
<td>支持</td>
<td>支持</td>
<td></td>
<td>不支持私有部署</td>
</tr>
<tr>
<td>Bamboo</td>
<td></td>
<td>收费</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>Codeship</td>
<td></td>
<td>免费/收费</td>
<td>关联Github, GitLab</td>
<td>支持</td>
<td></td>
<td>不支持私有部署</td>
</tr>
<tr>
<td>CircleCI</td>
<td></td>
<td>免费/收费</td>
<td>关联Github</td>
<td>支持</td>
<td>支持大部分测试框架</td>
<td>不支持私有部署</td>
</tr>
<tr>
<td>Hudson</td>
<td>Eclipse Public License 1.0</td>
<td>免费</td>
<td>需插件</td>
<td>需插件</td>
<td></td>
</tr>
</tbody>
</table>
<p>其实这里的支持，意思应该是直接的支持，例如Jenkins，其实和git结合也很简单，通过脚本就可以实现。</p>
<h1 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5    参考资料"></a>5    参考资料</h1><ol>
<li>Maven实战（五）——自动化Web应用集成测试<br><a href="http://www.infoq.com/cn/news/2011/03/xxb-maven-5-integration-test" target="_blank" rel="external">http://www.infoq.com/cn/news/2011/03/xxb-maven-5-integration-test</a></li>
<li>单元测试 - 维基百科<br><a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95</a></li>
<li>Integration testing – Wikipedia<br><a href="https://en.wikipedia.org/wiki/Integration_testing" target="_blank" rel="external">https://en.wikipedia.org/wiki/Integration_testing</a></li>
<li>Continuous integration – Wikipedia<br><a href="https://en.wikipedia.org/wiki/Continuous_integration" target="_blank" rel="external">https://en.wikipedia.org/wiki/Continuous_integration</a></li>
<li>Continuous integration | ThoughtWorks<br><a href="https://www.thoughtworks.com/continuous-integration" target="_blank" rel="external">https://www.thoughtworks.com/continuous-integration</a></li>
<li>另一种声音：持续集成已死<br><a href="http://www.infoq.com/cn/news/2014/10/continuous-integration" target="_blank" rel="external">http://www.infoq.com/cn/news/2014/10/continuous-integration</a></li>
<li>持续集成是什么？<br><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html</a></li>
<li>25 best continuous integration tools as of 2017 - Slant<br><a href="https://www.slant.co/topics/799/~best-continuous-integration-tools" target="_blank" rel="external">https://www.slant.co/topics/799/~best-continuous-integration-tools</a></li>
<li>Bamboo vs Jenkins Comparison | Atlassian<br><a href="https://www.atlassian.com/software/bamboo/comparison/bamboo-vs-jenkins" target="_blank" rel="external">https://www.atlassian.com/software/bamboo/comparison/bamboo-vs-jenkins</a></li>
<li>通过Docker容器运行持续集成/持续部署<br><a href="http://dockone.io/article/468" target="_blank" rel="external">http://dockone.io/article/468</a></li>
<li>Continuous Integration, Deployment &amp; Delivery with Codeship<br><a href="https://codeship.com" target="_blank" rel="external">https://codeship.com</a></li>
<li>谈谈持续集成，持续交付，持续部署之间的区别<br><a href="http://blog.flow.ci/cicd_difference/" target="_blank" rel="external">http://blog.flow.ci/cicd_difference/</a></li>
<li>Continuous delivery – Wikipedia<br><a href="https://en.wikipedia.org/wiki/Continuous_delivery" target="_blank" rel="external">https://en.wikipedia.org/wiki/Continuous_delivery</a></li>
<li>Build automation – Wikipedia<br><a href="https://en.wikipedia.org/wiki/Build_automation" target="_blank" rel="external">https://en.wikipedia.org/wiki/Build_automation</a></li>
<li>List of build automation software – Wikipedia<br><a href="https://en.wikipedia.org/wiki/List_of_build_automation_software" target="_blank" rel="external">https://en.wikipedia.org/wiki/List_of_build_automation_software</a></li>
<li>Software development process - Wikipedia<br><a href="https://en.wikipedia.org/wiki/Software_development_process" target="_blank" rel="external">https://en.wikipedia.org/wiki/Software_development_process</a></li>
<li>System integration - Wikipedia<br><a href="https://en.wikipedia.org/wiki/System_integration" target="_blank" rel="external">https://en.wikipedia.org/wiki/System_integration</a></li>
<li>Continuous Integration - Martin Fowler<br><a href="https://martinfowler.com/articles/continuousIntegration.html#PracticesOfContinuousIntegration" target="_blank" rel="external">https://martinfowler.com/articles/continuousIntegration.html#PracticesOfContinuousIntegration</a></li>
<li>Integration Testing - Software Testing Fundamentals<br><a href="http://softwaretestingfundamentals.com/integration-testing/" target="_blank" rel="external">http://softwaretestingfundamentals.com/integration-testing/</a></li>
<li>Practical continuous deployment: a guide to automated software delivery<br><a href="https://www.atlassian.com/blog/continuous-delivery/practical-continuous-deployment" target="_blank" rel="external">https://www.atlassian.com/blog/continuous-delivery/practical-continuous-deployment</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1    概述&quot;&gt;&lt;/a&gt;1    概述&lt;/h1&gt;&lt;p&gt;互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration, CI）。持续集成也被认为是敏捷开发的最重要实践之一。&lt;/p&gt;
&lt;p&gt;本文主要介绍持续集成的概念以及一些工具与实践。&lt;/p&gt;
&lt;h1 id=&quot;2-概念&quot;&gt;&lt;a href=&quot;#2-概念&quot; class=&quot;headerlink&quot; title=&quot;2    概念&quot;&gt;&lt;/a&gt;2    概念&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://otlnkjq1m.bkt.clouddn.com/CI-notion-relation.png&quot; alt=&quot;图2.1 持续集成概念示意图之一&quot;&gt;&lt;br&gt;图2.1 持续集成概念示意图之一&lt;/p&gt;
&lt;p&gt;上图来源于&lt;a href=&quot;http://blog.flow.ci/cicd_difference/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;谈谈持续集成，持续交付，持续部署之间的区别&lt;/a&gt;，这图很直观地描述了持续集成相关的概念之间的关系，与持续集成密切相关的概念还有持续交付、持续部署，因此在下文将会就这三个概念进行阐述。&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件工程" scheme="http://bungder.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="持续集成" scheme="http://bungder.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>一种RESTful接口的约定</title>
    <link href="http://bungder.github.io/2017/07/24/REST/"/>
    <id>http://bungder.github.io/2017/07/24/REST/</id>
    <published>2017-07-24T13:05:13.000Z</published>
    <updated>2017-08-20T14:08:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h2 id="1-1-撰写目的"><a href="#1-1-撰写目的" class="headerlink" title="1.1 撰写目的"></a>1.1 撰写目的</h2><p>本文用于定义一种统一的RESTful接口设计方案，希望具有参考价值。本文所描述的方案比较学院派（死板），在上一家公司提出没有被采纳，在所了解到的有限的若干家声称采用了RESTful风格的公司里，发现他们也偏离甚远，而在书本以及网上大部分介绍RESTful的资料里，却都是这样的方案（URL命名风格、请求与响应的设计）。当然，他们这么做是有理由的，我也理解，这只是取舍问题。这篇文章其实是旧文了，2016年年底就已经写好，但是一直躺在电脑的硬盘里，不想白费了当时的功夫，因此在此公开。</p>
<h2 id="1-2-为什么采用REST"><a href="#1-2-为什么采用REST" class="headerlink" title="1.2    为什么采用REST"></a>1.2    为什么采用REST</h2><p>目的是为了服务端与客户端的解耦。SOA仅仅是从结构上将前后端分离，但是实际上数据逻辑还是没有实现解耦，服务端接口升级往往会影响客户端，两者的行为需要严格约定。而REST采用HTTP协议进行约定，客户端仅仅需要按照HTTP协议来理解服务端返回的数据，虽然与业务相关的数据结构还是需要约定，但是这确实进一步解耦了服务端与客户端。</p>
<p>另外，由于严格遵照HTTP协议进行数据返回，对于安全的接口，可以在返回的Header里设置缓存策略（接口安全性的概念在下文会解释）。</p>
<a id="more"></a>
<h2 id="1-3-文档结构"><a href="#1-3-文档结构" class="headerlink" title="1.3 文档结构"></a>1.3 文档结构</h2><p>第二部分将阐述关于RESTful的若干个关键的概念，明确第二部分阐述的几个概念有利于设计、实现优雅规范的接口。</p>
<p>第三部分就URL命名的问题进行约定。</p>
<p>第四部分对消息实体进行约定。</p>
<p>第五部分对『向RESTful接口发起请求』进行阐述，约定要实现的方法，约定请求的头部和body的格式。</p>
<p>第六部分对接口的响应格式进行约定，包括响应消息的头部、状态码、JSON实体。</p>
<p>第七部分对版本控制的问题进行约定。</p>
<p>第八部分对RESTful接口的实现提出了实现工具的建议。</p>
<h1 id="2-关键概念"><a href="#2-关键概念" class="headerlink" title="2    关键概念"></a>2    关键概念</h1><p>明确一些关键的概念是很重要的，虽然RESTful风格的API设计方案并没有统一的标准，但是还是需要符合一定的原则进行设计，否则就不能称为RESTful风格的API。因为许多人并没有对REST进行充分的了解就宣称自己的API是RESTful风格的API，以至于RESTful的提出者Fielding博士本人无法忍受，在2008年为此专门写了一篇博客『<strong>REST APIs must be hypertext-driven</strong>』，hypertext-driven与HATEOAS是同一个概念的不同表述，在下文会进行阐述。</p>
<h2 id="2-1-RESTful"><a href="#2-1-RESTful" class="headerlink" title="2.1     RESTful"></a>2.1     RESTful</h2><p><strong>REST</strong>不是一种协议，也不是一种文件格式，更不是一种开发框架。它是一系列的设计约束的集合：无状态性、将超媒体作为应用状态的引擎等。REST是<strong>Representation State Transfer</strong>的缩写，中文是『表述性状态转移』，这里就涉及到资源的表述与状态两个概念。</p>
<p>简单地说，资源可以看作是服务器上存储的所有数据，资源的表述则是服务器对外提供的指向这些资源的方式，使用JSON、XML等均可，一个资源可以有多种表述；资源的状态则是服务器的数据存储状态，例如在t时刻，服务器中存储了m条数据，这时候客户端向服务端提交了一个创建数据的请求，服务器处理了此请求并创建了一条数据，那么在t+1时刻，服务器中就存储了m+1条数据，这两个时刻的资源状态就是不一样的，t时刻发生的请求导致了资源状态的改变。</p>
<h2 id="2-2-HATEOAS"><a href="#2-2-HATEOAS" class="headerlink" title="2.2    HATEOAS"></a>2.2    HATEOAS</h2><p><strong>Hypermedia As The Engine Of Application State</strong>，超媒体作为应用程序状态的引擎。这是REST区别于其他SOA风格的主要特点。客户端与服务端进行互动的时候，完全是通过服务端动态提供的超媒体进行的。除了对超媒体的一般理解，客户端不需要知道其他额外的知识。相反，在一些SOA接口的设计中，客户端与服务端的通信是要事先进行约定的，例如通过文档或者接口描述语言（Interface Description Language, IDL）。而基于HTTP协议的REST设计里，一般采用的就是请求与响应的Header来体现HATEOAS原则（具体请参考：<a href="https://en.wikipedia.org/wiki/HATEOAS" target="_blank" rel="external">https://en.wikipedia.org/wiki/HATEOAS</a>）。这里也隐含这样一层含义：REST应尽可能地利用HTTP标准中现有的东西，例如Header、标准方法与状态码。</p>
<p>从标准的角度看，HTTP标准是一项RFC标准，世界认可；而其他自定义的SOA标准则可能是一项个人标准或者公司标准，最多是一项互联网草案（这对大部分公司来说都不可能），而一项标准越是被广为认可接受，其实现的通用性就越强。个人标准和公司标准都五花八门，这样对每一个标准都要参照其相关文档实现相应的行为逻辑是很麻烦的。</p>
<h2 id="2-3-安全性"><a href="#2-3-安全性" class="headerlink" title="2.3    安全性"></a>2.3    安全性</h2><p>一个方法被调用1次与被调用0次是一样的，此方法就是安全的，否则就是不安全的。例如，一个方法A仅仅是读取数据，并不创建或者修改数据，不论A方法被调用多少次，都不对数据记录产生任何影响，A方法是安全的。而假如有另一个方法B对数据进行删除，B方法被调用1次后，数据会被删除（或者标识位被修改），系统里的数据发生了变化，那么B方法是不安全的。</p>
<h2 id="2-4-幂等性"><a href="#2-4-幂等性" class="headerlink" title="2.4    幂等性"></a>2.4    幂等性</h2><p>一个方法被同样地调用1次与被调用多次是一样的，即同样的输入会得到同样的输出，此方法就是幂等的，否则就不是幂等的。</p>
<p>2.3节中A方法与B方法都是幂等的，一个安全的方法一定是幂等的，一个幂等的方法不一定是安全的。</p>
<p>假设一个方法C对某个全局计数器执行自增操作并写入数据库，每次调用C方法都会对系统数据产生影响，那么C方法就不是幂等的。</p>
<h1 id="3-URL命名"><a href="#3-URL命名" class="headerlink" title="3 URL命名"></a>3 URL命名</h1><p>URL用于标识资源，因此URL应该以名词进行命名，例如<code>/users</code>, <code>/users/children</code>等。</p>
<p>一般URL会内嵌参数，例如要获取id为313的user的信息，那么URL应该为<code>/users/313</code>，前面的user采用复数，如果要列出其所有后代，则URL应为<code>/users/313/children</code>，children为复数形式，如果要获取其id为499的后代，则URL应为<code>/users/313/children/499</code></p>
<h1 id="4-消息实体"><a href="#4-消息实体" class="headerlink" title="4    消息实体"></a>4    消息实体</h1><p>消息实体，就是请求和响应消息中的<code>entity-body</code>（也称为body），消息实体采用JSON字符串格式。</p>
<h1 id="5-请求"><a href="#5-请求" class="headerlink" title="5 请求"></a>5 请求</h1><h2 id="5-1-方法"><a href="#5-1-方法" class="headerlink" title="5.1    方法"></a>5.1    方法</h2><p>使用HTTP标准定义的请求方法。</p>
<h3 id="5-1-1-get"><a href="#5-1-1-get" class="headerlink" title="5.1.1    get"></a>5.1.1    get</h3><p>获取资源，单个参数一般写在URL上，多个参数则作为query parameter附在URL后面，例如：</p>
<ul>
<li>单个参数：/user/123, 表示id为123的user</li>
<li>多个参数：/user?name=tom&amp;phone=13787890987&amp;gender=male</li>
</ul>
<p>get方法应为幂等的，并且不对数据记录产生影响。对于汉字与特殊字符，应该进行urlencode。</p>
<h3 id="5-1-2-post"><a href="#5-1-2-post" class="headerlink" title="5.1.2    post"></a>5.1.2    post</h3><p>创建资源，请求的headers里设置<code>Content-type</code>为<code>application/json</code>，参数为json类型。</p>
<p>根据约定，在创建成功之后，返回的状态码应该是201（Created），并且在response的Header里设置Location为新创建的资源的URL，例如，创建了一个新的user，该user创建后id为888，那么Header里应该设置<code>Location</code>为<code>/users/888</code>，当然，这应该是一个完整的URL，这里只是给出了一个相对路径的URI以作为说明。返回了这些数据后，客户端可以自定义后续行为，或者查看创建后的user，或者刷新当前的user列表，这些行为服务端并不关心。</p>
<p>如果重复提交了相同的数据，第一次应该返回201，以后则应返回409（Conflict），并且在response的Header里设置Location指向已经存在的资源，说明冲突的来源。</p>
<h3 id="5-1-3-put"><a href="#5-1-3-put" class="headerlink" title="5.1.3    put"></a>5.1.3    put</h3><p>更新资源，对现有资源进行修改，请求的headers与post一样，参数也是。此方法应该是幂等的。</p>
<h3 id="5-1-4-delete"><a href="#5-1-4-delete" class="headerlink" title="5.1.4    delete"></a>5.1.4    delete</h3><p>删除资源。此方法应是幂等的。</p>
<h2 id="5-2-Header"><a href="#5-2-Header" class="headerlink" title="5.2    Header"></a>5.2    Header</h2><p>Content-type应设为application/json。</p>
<p>另外应设置一个version，指明所使用的接口版本。这不属于HTTP协议中的一部分，是自定义的，出于版本控制的考量，具体见第七章。</p>
<h2 id="5-3-body"><a href="#5-3-body" class="headerlink" title="5.3    body"></a>5.3    body</h2><p>采用JSON字符串，具体的结构有待商定，这不属于HTTP协议的一部分，是自定义的。</p>
<p>这里主要放置业务相关的数据。</p>
<p>借用<a href="http://www.infoq.com/cn/articles/rest-introduction" target="_blank" rel="external">一篇10年前的文章</a>的一张图：<br><img src="http://otlnkjq1m.bkt.clouddn.com/REST_resources.jpg" alt=""></p>
<h1 id="6-响应"><a href="#6-响应" class="headerlink" title="6    响应"></a>6    响应</h1><h2 id="6-1-Header"><a href="#6-1-Header" class="headerlink" title="6.1    Header"></a>6.1    Header</h2><p>根据响应的状态码不同，相应地设置头部，具体见下一节。</p>
<p>但是在我所了解的公司里，做法都是统一返回200，然后在返回的JSON字符串里设置消息码。我是不能理解的。据一位前端同学说，前端代码接收到了请求以后，不方便获取Http状态码。其实我也写过前端，不深入，但是一些基本的知识还是有的，我觉得这并不难做到，估计是他的代码封装的时候没有考虑到这一点，现在要改比较麻烦，所以不想大动干戈、伤筋动骨。</p>
<h2 id="6-2-状态码"><a href="#6-2-状态码" class="headerlink" title="6.2    状态码"></a>6.2    状态码</h2><table>
<thead>
<tr>
<th>状态码</th>
<th>语义</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>OK</td>
<td>正常返回消息，什么问题也没有</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>创建资源成功，Header里应设置Location指向新创建的资源</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>请求已被接收，但是处理过程较长，不能马上返回结果</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>没有任何修改发生</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>缺乏权限，指已经登录但是缺乏请求这个资源的权限</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>拒绝访问，可用于未登录时拦截返回的状态码，此时Header里应设置Location为登录页面的URL</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>不存在所请求的资源</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>请求没有被接收，参数约束校验不通过，或者其他业务类型的错误都可以返回这个状态码，response的body里应有表示错误信息的JSON实体。</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>请求的资源有冲突，例如多次提交一样的创建请求，response的Header里应设置Location为产生冲突的资源的URL</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器的非业务类错误，response的body里应有表示错误信息的JSON实体</td>
</tr>
</tbody>
</table>
<h2 id="6-3-body采用JSON字符串。"><a href="#6-3-body采用JSON字符串。" class="headerlink" title="6.3    body采用JSON字符串。"></a>6.3    body采用JSON字符串。</h2><p>JSON的结构分为两种：成功、失败。</p>
<p>一般而言，只有返回200的时候才需要读取成功的JSON，只有返回406和500的时候才需要读取失败的JSON，对于其他的状态码，客户端不需要服务器提供额外的消息。</p>
<p>对于成功的JSON，里面应该只包含一个result对象，而失败的JSON应该使用这样的结构：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    error: &#123;</div><div class="line">        code: xxx,</div><div class="line">        message: <span class="string">"xxx"</span>,</div><div class="line">        data: <span class="meta">&#123;...&#125;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>失败的JSON只有一个error对象，包含错误码、消息及相关数据，message应该是直接可读的消息，客户端毋需理解发生了什么错误，客户端只需将消息展示出来即可。在收到406的时候，客户端只需知道发生的错误是由客户端造成的即可，具体是什么类型并不需要知道，将消息直接展示出来，让使用的人知道是什么即可，所以message应该是人类可以理解的文本。同理，收到500的时候，只需知道这个错误是服务端的问题即可，客户端也毋需知道具体的错误类型，最多就将错误码和消息展示出来，让使用者有反馈的依据即可。</p>
<h1 id="7-版本控制"><a href="#7-版本控制" class="headerlink" title="7 版本控制"></a>7 版本控制</h1><p>考虑到接口有可能升级，升级的类型有几种：</p>
<ol>
<li>新增功能接口</li>
<li>原有接口返回数据增加字段</li>
<li>现有接口返回数据变更现有字段格式或删除现有字段</li>
<li>现有接口变更业务逻辑</li>
<li>删除接口</li>
</ol>
<p>其中，前两种升级并不会影响客户端，因此毋需处理。而后面三种会导致使用旧接口的客户端不能正常工作。</p>
<p>一般服务端升级与客户端升级都不是同步的，客户端升级往往会滞后，因此在服务端升级后应该保留旧版本的接口继续运行一段时间，让未升级的客户端可以继续工作一段时间，同时可以上线新版本的客户端。过一段时间后再将旧版本的接口下线。</p>
<p>而版本控制应该是向下兼容的，即假设当前版本是1.2，如果客户端请求1.3版本的服务，应当用当前版本提供服务。如果没有注明请求的版本号，应当提供当前版本的服务。</p>
<p>一般情况下，客户端请求需要带版本号，但是服务端并不需要对此进行处理，除非是同时运行新旧版本的同一个接口，才需要做差异处理。</p>
<h1 id="8-实现工具"><a href="#8-实现工具" class="headerlink" title="8 实现工具"></a>8 实现工具</h1><h2 id="8-1-Spring-HATEOAS"><a href="#8-1-Spring-HATEOAS" class="headerlink" title="8.1    Spring HATEOAS"></a>8.1    Spring HATEOAS</h2><p>Spring HATEOAS可以很方便地与Spring MVC结合来开发RESTful接口。具体参照其文档：<br><a href="http://docs.spring.io/spring-hateoas/docs/0.20.0.RELEASE/reference/html/#fundamentals.jaxb-json" target="_blank" rel="external">http://docs.spring.io/spring-hateoas/docs/0.20.0.RELEASE/reference/html/#fundamentals.jaxb-json</a></p>
<h1 id="9-缺陷"><a href="#9-缺陷" class="headerlink" title="9 缺陷"></a>9 缺陷</h1><p>其实这个方案基本就是网上一些被大部分人认可的做法的汇总，但是缺乏细节，例如分页，但是其实这些可以灵活变通，例如在查询字符串里加上分页参数。《<a href="https://ruby-china.org/topics/31822" target="_blank" rel="external">一次无后端的供应链系统开发实践 (上篇)： 前后端分离的 Restful 接口设计</a>》这篇文章的设计就比较全面，但是两者考量的问题范畴不同，他这个是serverless的设计，将业务逻辑都压在前端，后端仅仅作为前端与数据源之间的代理（数据源、客户端都在自己控制范围内的话其实没必要这样搞），这样的话，接口要表达的逻辑就比较复杂，而本文还是从传统的抽象思想去考虑，逻辑都在后端封装，因此接口并不需要表达多么复杂的逻辑。</p>
<h1 id="10-参考文献"><a href="#10-参考文献" class="headerlink" title="10 参考文献"></a>10 参考文献</h1><p>当时写的时候没记下来，所以就不列出来了，在此不保证来源的权威性，请读者自行鉴别。^_^</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-撰写目的&quot;&gt;&lt;a href=&quot;#1-1-撰写目的&quot; class=&quot;headerlink&quot; title=&quot;1.1 撰写目的&quot;&gt;&lt;/a&gt;1.1 撰写目的&lt;/h2&gt;&lt;p&gt;本文用于定义一种统一的RESTful接口设计方案，希望具有参考价值。本文所描述的方案比较学院派（死板），在上一家公司提出没有被采纳，在所了解到的有限的若干家声称采用了RESTful风格的公司里，发现他们也偏离甚远，而在书本以及网上大部分介绍RESTful的资料里，却都是这样的方案（URL命名风格、请求与响应的设计）。当然，他们这么做是有理由的，我也理解，这只是取舍问题。这篇文章其实是旧文了，2016年年底就已经写好，但是一直躺在电脑的硬盘里，不想白费了当时的功夫，因此在此公开。&lt;/p&gt;
&lt;h2 id=&quot;1-2-为什么采用REST&quot;&gt;&lt;a href=&quot;#1-2-为什么采用REST&quot; class=&quot;headerlink&quot; title=&quot;1.2    为什么采用REST&quot;&gt;&lt;/a&gt;1.2    为什么采用REST&lt;/h2&gt;&lt;p&gt;目的是为了服务端与客户端的解耦。SOA仅仅是从结构上将前后端分离，但是实际上数据逻辑还是没有实现解耦，服务端接口升级往往会影响客户端，两者的行为需要严格约定。而REST采用HTTP协议进行约定，客户端仅仅需要按照HTTP协议来理解服务端返回的数据，虽然与业务相关的数据结构还是需要约定，但是这确实进一步解耦了服务端与客户端。&lt;/p&gt;
&lt;p&gt;另外，由于严格遵照HTTP协议进行数据返回，对于安全的接口，可以在返回的Header里设置缓存策略（接口安全性的概念在下文会解释）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="REST" scheme="http://bungder.github.io/tags/REST/"/>
    
  </entry>
  
</feed>
