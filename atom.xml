<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Gordon</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://bungder.github.io/"/>
  <updated>2018-03-15T15:12:51.228Z</updated>
  <id>http://bungder.github.io/</id>
  
  <author>
    <name>Gordon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WebSocket简介</title>
    <link href="http://bungder.github.io/2018/03/15/websocket-abstract/"/>
    <id>http://bungder.github.io/2018/03/15/websocket-abstract/</id>
    <published>2018-03-15T14:53:40.000Z</published>
    <updated>2018-03-15T15:12:51.228Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h1><h2 id="1-1-comet"><a href="#1-1-comet" class="headerlink" title="1.1 comet"></a>1.1 comet</h2><p>天不生WS，万古如长夜。</p>
<p>在WebSocket出现之前，服务端主动推送消息给浏览器的需求就已经存在了，但是HTTP这个协议本来就不是设计用来进行双向通信的，所以机智的工程师们采取了各种hack的方式来实现这种功能，这些实现方式都统称为<code>comet</code>。</p>
<p>但是无可避免地，这些技术都存在缺陷，既然WebSocket都出现了，那么这些技术大概也能进博物馆了，除了实现Fallback方案时需要去了解之外，这些技术感觉价值不大了，所以不展开说，如果读者有兴趣，可以根据关键词找资料去了解。</p>
<a id="more"></a>
<blockquote>
<p>Comet is a web application model in which a long-held HTTPS request allows a web server to push data to a browser, without the browser explicitly requesting it</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Comet_(programming" target="_blank" rel="external">https://en.wikipedia.org/wiki/Comet_(programming)</a>)</p>
<blockquote>
<p>With long-polling we set the bar to cross-browser push. With XHR streaming and ActiveXObject(’htmlfile’) we raised it to cross-browser streaming. With SSE we’ve been trying to raise the bar to native, cross-browser streaming</p>
</blockquote>
<h3 id="1-1-1-实现"><a href="#1-1-1-实现" class="headerlink" title="1.1.1 实现"></a>1.1.1 实现</h3><h4 id="1-1-1-1-Streaming"><a href="#1-1-1-1-Streaming" class="headerlink" title="1.1.1.1 Streaming"></a>1.1.1.1 Streaming</h4><h5 id="1-1-1-1-1-Hidden-iframe"><a href="#1-1-1-1-1-Hidden-iframe" class="headerlink" title="1.1.1.1.1 Hidden iframe"></a>1.1.1.1.1 Hidden iframe</h5><h5 id="1-1-1-1-2-XMLHttpRequest"><a href="#1-1-1-1-2-XMLHttpRequest" class="headerlink" title="1.1.1.1.2 XMLHttpRequest"></a>1.1.1.1.2 XMLHttpRequest</h5><h4 id="1-1-1-2-Ajax-Long-pulling"><a href="#1-1-1-2-Ajax-Long-pulling" class="headerlink" title="1.1.1.2 Ajax Long-pulling"></a>1.1.1.2 Ajax Long-pulling</h4><h5 id="1-1-1-2-1-XMLHttpRequest-long-polling"><a href="#1-1-1-2-1-XMLHttpRequest-long-polling" class="headerlink" title="1.1.1.2.1 XMLHttpRequest long polling"></a>1.1.1.2.1 XMLHttpRequest long polling</h5><h5 id="1-1-1-2-2-Script-tag-long-polling"><a href="#1-1-1-2-2-Script-tag-long-polling" class="headerlink" title="1.1.1.2.2 Script tag long polling"></a>1.1.1.2.2 Script tag long polling</h5><h2 id="1-2-WebSocket协议"><a href="#1-2-WebSocket协议" class="headerlink" title="1.2 WebSocket协议"></a>1.2 WebSocket协议</h2><p>WebSocket是一种在单个TCP连接上进行全双工通讯的协议。是有别于HTTP的另一个TCP协议，它们都属于OSI模型中的第七层:</p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/osi.png" alt=""></p>
<p><a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="external"><strong>RFC 6455</strong></a> states that WebSocket “is designed to work over HTTP ports 80 and 443 as well as to support HTTP proxies and intermediaries” thus making it <strong>compatible with the HTTP</strong> protocol.</p>
<p>原文为：</p>
<blockquote>
<p>The WebSocket Protocol attempts to address the<br>goals of existing bidirectional HTTP technologies in the context of<br>the existing HTTP infrastructure; as such, <b>it is designed to work<br>over HTTP ports 80 and 443 as well as to support HTTP proxies and<br>intermediaries</b>, even if this implies some complexity specific to the<br>current environment.</p>
</blockquote>
<h3 id="1-2-1-握手"><a href="#1-2-1-握手" class="headerlink" title="1.2.1 握手"></a>1.2.1 握手</h3><blockquote>
<p>To establish a WebSocket connection, the client sends a WebSocket handshake request, for which the server returns a WebSocket handshake response, as shown in the example below:</p>
</blockquote>
<ul>
<li><p>客户端请求</p>
  <figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">GET</span> <span class="string">/</span> HTTP/1.1</div><div class="line"><span class="attribute">Upgrade</span>: websocket    </div><div class="line"><span class="attribute">Connection</span>: Upgrade</div><div class="line"><span class="attribute">Host</span>: example.com</div><div class="line"><span class="attribute">Origin</span>: http://example.com</div><div class="line"><span class="attribute">Sec-WebSocket-Key</span>: sN9cRrP/n9NdMgdcy2VJFQ==</div><div class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</div></pre></td></tr></table></figure>
</li>
<li><p>服务器回应</p>
  <figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">HTTP/1.1 <span class="number">101</span> Switching Protocols</div><div class="line"><span class="attribute">Upgrade</span>: websocket</div><div class="line"><span class="attribute">Connection</span>: Upgrade</div><div class="line"><span class="attribute">Sec-WebSocket-Accept</span>: fFBooB7FAkLlXgRSz0BT3v4hq5s=</div><div class="line"><span class="attribute">Sec-WebSocket-Location</span>: ws://example.com/</div></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>The handshake resembles HTTP in allowing servers to handle HTTP connections as well as WebSocket connections on the same port. Once the connection is established, communication switches to a bidirectional binary protocol which doesn’t conform to the HTTP protocol.</p>
</blockquote>
<h3 id="1-2-2-Frame"><a href="#1-2-2-Frame" class="headerlink" title="1.2.2 Frame"></a>1.2.2 Frame</h3><p>WebSocket传输的数据是基于帧的，一帧数据里包含两部分：数据主体和控制帧</p>
<blockquote>
<p>there are types for textual data (which is interpreted as UTF-8 [RFC3629]<br>text), binary data (whose interpretation is left up to the<br>application), and control frames (which are not intended to carry<br>data for the application but instead for protocol-level signaling,<br>such as to signal that the connection should be closed)</p>
</blockquote>
<p>为了避免混淆网络中间件（例如拦截代理）以及出于安全原因，</p>
<ul>
<li>客户端必须屏蔽（mask）所有发送给服务器的帧，如果服务器收到了未屏蔽的帧，必须关闭连接。在这种情况下，服务器可以发送一个<code>Close</code>帧，状态码为<code>1002</code>。</li>
<li>服务器不能屏蔽任何发送给客户端的帧，如果客户端收到了屏蔽过的帧，必须关闭连接。这种情况下，也可以利用状态码<code>1002</code>。</li>
<li></li>
</ul>
<p>基本的帧协议（The Base Framing Protocol）简单地定义以下部分：</p>
<p>Frame：</p>
<ul>
<li>opcode：操作码，用于定义一个帧的类型</li>
<li>Payload data<ul>
<li>Extension data：<ul>
<li>payload length：载荷长度</li>
<li>designated locations：指定位置</li>
</ul>
</li>
<li>Application Data</li>
</ul>
</li>
</ul>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/websocket-frame.png" alt=""></p>
<h3 id="1-2-3-心跳"><a href="#1-2-3-心跳" class="headerlink" title="1.2.3 心跳"></a>1.2.3 心跳</h3><p>一端发送<code>Ping</code>帧，另一端发送<code>Pong</code>帧作为响应</p>
<ul>
<li>The <code>Ping</code> frame contains an opcode of <code>0x9</code>.</li>
<li>The <code>Pong</code> frame contains an opcode of <code>0xA</code>.</li>
</ul>
<h3 id="1-2-4-优点"><a href="#1-2-4-优点" class="headerlink" title="1.2.4 优点"></a>1.2.4 优点</h3><blockquote>
<ul>
<li>较少的控制开销。在连接创建后，服务器和客户端之间交换数据时，用于协议控制的数据包头部相对较小。在不包含扩展的情况下，对于服务器到客户端的内容，此头部大小只有2至10字节（和数据包长度有关）；对于客户端到服务器的内容，此头部还需要加上额外的4字节的掩码。相对于HTTP请求每次都要携带完整的头部，此项开销显著减少了。</li>
<li>更强的实时性。由于协议是全双工的，所以服务器可以随时主动给客户端下发数据。相对于HTTP请求需要等待客户端发起请求服务端才能响应，延迟明显更少；即使是和Comet等类似的长轮询比较，其也能在短时间内更多次地传递数据。</li>
<li>保持连接状态。于HTTP不同的是，Websocket需要先创建连接，这就使得其成为一种有状态的协议，之后通信时可以省略部分状态信息。而HTTP请求可能需要在每个请求都携带状态信息（如身份认证等）。</li>
<li>更好的二进制支持。Websocket定义了二进制帧，相对HTTP，可以更轻松地处理二进制内容。</li>
<li>可以支持扩展。Websocket定义了扩展，用户可以扩展协议、实现部分自定义的子协议。如部分浏览器支持压缩等。</li>
<li>更好的压缩效果。相对于HTTP压缩，Websocket在适当的扩展支持下，可以沿用之前内容的上下文，在传递类似的数据时，可以显著地提高压缩率。</li>
</ul>
</blockquote>
<h1 id="2-API"><a href="#2-API" class="headerlink" title="2 API"></a>2 API</h1><h2 id="2-1-JavaScript-API"><a href="#2-1-JavaScript-API" class="headerlink" title="2.1 JavaScript API"></a>2.1 JavaScript API</h2><p><a href="https://www.w3.org/TR/websockets/" target="_blank" rel="external">The WebSocket API</a>:</p>
<p>The WebSocket Interface<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">interface WebSocket : EventTarget &#123;</div><div class="line">  readonly attribute DOMString url;</div><div class="line"></div><div class="line">  <span class="comment">// ready state</span></div><div class="line">  <span class="keyword">const</span> unsigned short CONNECTING = <span class="number">0</span>;</div><div class="line">  <span class="keyword">const</span> unsigned short OPEN = <span class="number">1</span>;</div><div class="line">  <span class="keyword">const</span> unsigned short CLOSING = <span class="number">2</span>;</div><div class="line">  <span class="keyword">const</span> unsigned short CLOSED = <span class="number">3</span>;</div><div class="line">  readonly attribute unsigned short readyState;</div><div class="line">  readonly attribute unsigned long bufferedAmount;</div><div class="line"></div><div class="line">  <span class="comment">// networking</span></div><div class="line">           attribute EventHandler onopen;</div><div class="line">           attribute EventHandler onerror;</div><div class="line">           attribute EventHandler onclose;</div><div class="line">  readonly attribute DOMString extensions;</div><div class="line">  readonly attribute DOMString protocol;</div><div class="line">  <span class="keyword">void</span> close([Clamp] optional unsigned short code, optional DOMString reason);</div><div class="line"></div><div class="line">  <span class="comment">// messaging</span></div><div class="line">           attribute EventHandler onmessage;</div><div class="line">           attribute DOMString binaryType;</div><div class="line">  <span class="keyword">void</span> send(DOMString data);</div><div class="line">  <span class="keyword">void</span> send(Blob data);</div><div class="line">  <span class="keyword">void</span> send(<span class="built_in">ArrayBuffer</span> data);</div><div class="line">  <span class="keyword">void</span> send(ArrayBufferView data);</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/websocket-prototype.png" alt=""></p>
<h2 id="2-2-Java-API"><a href="#2-2-Java-API" class="headerlink" title="2.2 Java API"></a>2.2 Java API</h2><h3 id="2-2-1-Java-EE"><a href="#2-2-1-Java-EE" class="headerlink" title="2.2.1 Java EE"></a>2.2.1 Java EE</h3><p><a href="http://www.oracle.com/technetwork/articles/java/jsr356-1937161.html" target="_blank" rel="external">JSR 356, Java API for WebSocket</a></p>
<p>JSR 356是Java EE 7标准的一部分。</p>
<p>开源实现有：</p>
<ul>
<li>GlassFish</li>
<li>Jetty 9.1.+</li>
</ul>
<p>以下是一个典型的例子：<br><img src="http://otlnkjq1m.bkt.clouddn.com/server-client-sample.png" alt=""></p>
<p>服务端由Java实现，用JSR 356的一个实现来处理WebSocket协议的细节。<br>客户端中，JavaFX客户端可以依赖任何符合JSR 356的客户端来处理WebSocket协议，而其他客户端则可以使用符合RFC 6455的实现来与服务器通信。</p>
<p>兼容JSR 356的好处：</p>
<ul>
<li>防止供应商锁定（vendor-lock），可以自由地选择库和应用服务器</li>
</ul>
<p>JSR 356的缺点：</p>
<p><a href="https://books.google.com/books?id=EkBPDwAAQBAJ&amp;pg=PA282&amp;lpg=PA282&amp;dq=netty+jsr+356&amp;source=bl&amp;ots=9nbhtR3VEn&amp;sig=wVmL3ImgmRmE_69OCpHLHjrYv2c&amp;hl=zh-CN&amp;sa=X&amp;ved=0ahUKEwiYnY7rse3ZAhUMzGMKHX_kDBg4ChDoAQgvMAE#v=onepage&amp;q=netty%20jsr%20356&amp;f=false" target="_blank" rel="external">Learning Spring Boot 2.0: Simplify the development of lightning fast … - Greg L. Turnquist - Google 图书</a></p>
<ul>
<li>基于Servlet 3.1<br>  目前兼容Servlet 3.1的有tomcat，但是如果在使用Netty，则不兼容了<br>  <img src="http://otlnkjq1m.bkt.clouddn.com/not-suing-jsr356.png" alt=""></li>
<li>J2EE标准前景不太好<br>  J2EE标准发布比较慢，RFC6455在2011年12月就正式发布了，而相应的JSR 356却在2013年5月才发布，相应地，Jetty在2013年11月才发布对JSR 356支持的稳定版本，从RFC标准发布到JSR标准实现之间相距了2年。</li>
<li>考虑到在一般的场景下，WebSocket客户端都不是Java客户端，所以花费精力去适配JSR 356没必要，别的语言才不管J2EE的标准。</li>
</ul>
<h3 id="2-2-2-非Java-EE"><a href="#2-2-2-非Java-EE" class="headerlink" title="2.2.2 非Java EE"></a>2.2.2 非Java EE</h3><p>实现了RFC6455标准即可。</p>
<h1 id="3-Fallback"><a href="#3-Fallback" class="headerlink" title="3 Fallback"></a>3 Fallback</h1><p>目前主流的浏览器基本都支持WebSocket，但是，IE 10（不含10）以下的版本不支持，而这些版本的IE用户量还是不少的，因此需要有后备方案。</p>
<h2 id="3-1-sockjs"><a href="#3-1-sockjs" class="headerlink" title="3.1 sockjs"></a>3.1 sockjs</h2><p>项目主页：<br><a href="https://github.com/sockjs/sockjs-client" target="_blank" rel="external">https://github.com/sockjs/sockjs-client</a></p>
<ul>
<li>The API should follow HTML5 Websockets API as closely as possible.</li>
<li>All the transports must support cross domain connections out of the box. It’s possible and recommended to host a SockJS server on a different server than your main web site.</li>
<li>There is support for at least one streaming protocol for every major browser.</li>
<li>Streaming transports should work cross-domain and should support cookies (for cookie-based sticky sessions).</li>
<li>Polling transports are used as a fallback for old browsers and hosts behind restrictive proxies.</li>
<li>Connection establishment should be fast and lightweight.</li>
<li>No Flash inside (no need to open port 843 - which doesn’t work through proxies, no need to host ‘crossdomain.xml’, no need to wait for 3 seconds in order to detect problems)</li>
</ul>
<hr>
<ul>
<li>API尽量接近HTML5 WebSocket的API</li>
<li>开箱即用地对所有协议支持跨域连接，可以在主站点以外架设SockJS服务器，并且也推荐这样做。</li>
<li>对每个主流的浏览器至少支持一种streaming协议</li>
<li>流传输（streaming transports）应该能跨域工作，并且支持cookies（基于cookies的会话）</li>
<li>Polling传输作为一种后备方案，支持老版本的浏览器和被限制性代理所限制的主机</li>
<li>连接的建立应该是快速和轻量级的</li>
<li>不包含Flash（不必开启843端口）</li>
</ul>
<p>协议：<br><a href="http://sockjs.github.io/sockjs-protocol/sockjs-protocol-0.3.3.html" target="_blank" rel="external">sockjs-protocol-0.3.3.py</a></p>
<p>在底层的实现上，SockJS会首先尝试使用原生的WebSocket，如果失败了，再根据浏览器来决定采取相应的传输协议。</p>
<blockquote>
<p>Under the hood SockJS tries to use native WebSockets first. If that fails it can use a variety of browser-specific transport protocols and presents them through WebSocket-like abstractions.</p>
</blockquote>
<p>Supported transports, by browser (html served from http:// or https://)</p>
<table>
<thead>
<tr>
<th>_Browser_</th>
<th>_Websockets_</th>
<th>_Streaming_</th>
<th>_Polling_</th>
</tr>
</thead>
<tbody>
<tr>
<td>IE 6, 7</td>
<td>no</td>
<td>no</td>
<td>jsonp-polling</td>
</tr>
<tr>
<td>IE 8, 9 (cookies=no)</td>
<td>no</td>
<td>xdr-streaming &dagger;</td>
<td>xdr-polling &dagger;</td>
</tr>
<tr>
<td>IE 8, 9 (cookies=yes)</td>
<td>no</td>
<td>iframe-htmlfile</td>
<td>iframe-xhr-polling</td>
</tr>
<tr>
<td>IE 10</td>
<td>rfc6455</td>
<td>xhr-streaming</td>
<td>xhr-polling</td>
</tr>
<tr>
<td>Chrome 6-13</td>
<td>hixie-76</td>
<td>xhr-streaming</td>
<td>xhr-polling</td>
</tr>
<tr>
<td>Chrome 14+</td>
<td>hybi-10 / rfc6455</td>
<td>xhr-streaming</td>
<td>xhr-polling</td>
</tr>
<tr>
<td>Firefox &lt;10</td>
<td>no &Dagger;</td>
<td>xhr-streaming</td>
<td>xhr-polling</td>
</tr>
<tr>
<td>Firefox 10+</td>
<td>hybi-10 / rfc6455</td>
<td>xhr-streaming</td>
<td>xhr-polling</td>
</tr>
<tr>
<td>Safari 5.x</td>
<td>hixie-76</td>
<td>xhr-streaming</td>
<td>xhr-polling</td>
</tr>
<tr>
<td>Safari 6+</td>
<td>rfc6455</td>
<td>xhr-streaming</td>
<td>xhr-polling</td>
</tr>
<tr>
<td>Opera 10.70+</td>
<td>no &Dagger;</td>
<td>iframe-eventsource</td>
<td>iframe-xhr-polling</td>
</tr>
<tr>
<td>Opera 12.10+</td>
<td>rfc6455</td>
<td>xhr-streaming</td>
<td>xhr-polling</td>
</tr>
<tr>
<td>Konqueror</td>
<td>no</td>
<td>no</td>
<td>jsonp-polling</td>
</tr>
</tbody>
</table>
<h1 id="4-实现"><a href="#4-实现" class="headerlink" title="4 实现"></a>4 实现</h1><h2 id="4-1-Netty"><a href="#4-1-Netty" class="headerlink" title="4.1 Netty"></a>4.1 Netty</h2><p><a href="http://netty.io/" target="_blank" rel="external">http://netty.io/</a></p>
<h2 id="4-2-Undertow"><a href="#4-2-Undertow" class="headerlink" title="4.2 Undertow"></a>4.2 Undertow</h2><p><a href="http://undertow.io/" target="_blank" rel="external">http://undertow.io/</a></p>
<h2 id="4-3-Jetty"><a href="#4-3-Jetty" class="headerlink" title="4.3 Jetty"></a>4.3 Jetty</h2><h2 id="4-4-Vert-x"><a href="#4-4-Vert-x" class="headerlink" title="4.4 Vert.x"></a>4.4 Vert.x</h2><p><a href="http://http//vertx.io" target="_blank" rel="external">http://http//vertx.io</a></p>
<h2 id="4-5-Spray-WebSocket"><a href="#4-5-Spray-WebSocket" class="headerlink" title="4.5 Spray-WebSocket"></a>4.5 Spray-WebSocket</h2><p><a href="https://github.com/dcaoyuan/spray-websocket" target="_blank" rel="external">https://github.com/dcaoyuan/spray-websocket</a></p>
<h2 id="4-6-nodejs-websocket"><a href="#4-6-nodejs-websocket" class="headerlink" title="4.6 nodejs-websocket"></a>4.6 nodejs-websocket</h2><p><a href="https://github.com/sitegui/nodejs-websocket" target="_blank" rel="external">https://github.com/sitegui/nodejs-websocket</a></p>
<h2 id="4-7-Grizzly"><a href="#4-7-Grizzly" class="headerlink" title="4.7 Grizzly"></a>4.7 Grizzly</h2><p><a href="https://javaee.github.io/grizzly/" target="_blank" rel="external">https://javaee.github.io/grizzly/</a></p>
<h2 id="4-8-Go"><a href="#4-8-Go" class="headerlink" title="4.8 Go"></a>4.8 Go</h2><h1 id="5-进一步封装的协议"><a href="#5-进一步封装的协议" class="headerlink" title="5 进一步封装的协议"></a>5 进一步封装的协议</h1><p><strong>为什么不直接使用WebSocket协议？</strong></p>
<ol>
<li>数据的解析是未定义的。<br> WebSocket支持text和binary两种传输数据格式，无论是哪种格式，客户端和服务器都需要约定如何包装、解析数据。因此在WebSocket协议的基础上，还需要再定义一层协议，客户端和服务端才能完成协作。</li>
<li>兼容Fallback方案。<br> 当WebSocket不能工作的时候（例如在IE 6上），采用后备方案实现消息推送，除了通信的实现方式改变之外，数据解析的协议应当保持不变。</li>
</ol>
<h2 id="5-1-STOMP"><a href="#5-1-STOMP" class="headerlink" title="5.1 STOMP"></a>5.1 STOMP</h2><blockquote>
<p>Simple (or Streaming) Text Orientated Messaging Protocol 的缩写。</p>
</blockquote>
<p>项目主页：<br><a href="http://stomp.github.io" target="_blank" rel="external">http://stomp.github.io</a></p>
<p>STOMP是基于帧的消息协议。</p>
<blockquote>
<p>A frame consists of a command, a set of optional headers and an optional body. It is an alternative to other open messaging protocols such as AMQP and implementation specific wire protocols used in JMS brokers such as OpenWire. </p>
<p>STOMP is text based but also allows for the transmission of binary messages. </p>
</blockquote>
<h3 id="5-1-1-采用STOMP的理由"><a href="#5-1-1-采用STOMP的理由" class="headerlink" title="5.1.1 采用STOMP的理由"></a>5.1.1 采用STOMP的理由</h3><ul>
<li>目前RabbitMQ和Spring都支持STOMP协议，表明STOMP已经是一个主流的消息协议之一，基于主流的协议，可以替换各种实现；</li>
<li>STOMP协议的帧格式比较简洁，由command + headers + body构成，各部分使用<code>EOL</code>进行划分，冗余字符较少，不会浪费带宽。（EOL（end-of-line，consists of an OPTIONAL carriage return (octet 13) followed by a REQUIRED line feed (octet 10)））</li>
<li>支持发布/订阅模型和事务<br>  每个STOMP客户端既可以作为生产者，也可以作为消费者</li>
</ul>
<h3 id="5-1-2-帧"><a href="#5-1-2-帧" class="headerlink" title="5.1.2 帧"></a>5.1.2 帧</h3><p>STOMP消息帧由以下部分组成：</p>
<ul>
<li>Command</li>
<li>Headers（Optional）</li>
<li>Body（Optional）</li>
</ul>
<p>示例：<br><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">COMMAND</div><div class="line"><span class="symbol">header1:</span>value1</div><div class="line"><span class="symbol">header2:</span>value2</div><div class="line"></div><div class="line">Body^@</div></pre></td></tr></table></figure></p>
<h3 id="5-1-3-Heart-beating"><a href="#5-1-3-Heart-beating" class="headerlink" title="5.1.3 Heart-beating"></a>5.1.3 Heart-beating</h3><p>略。</p>
<h3 id="5-1-4-发布-订阅模型"><a href="#5-1-4-发布-订阅模型" class="headerlink" title="5.1.4 发布-订阅模型"></a>5.1.4 发布-订阅模型</h3><p>通过以下帧来控制：</p>
<ul>
<li>SUBSCRIBE</li>
<li>UNSUBSCRIBE</li>
</ul>
<p>在RFC 6455里，限制了一个客户端到一个host的连接数：</p>
<blockquote>
<p>If the client already has a WebSocket connection to the remote<br>       host (IP address) identified by /host/ and port /port/ pair, even<br>       if the remote host is known by another name, the client MUST wait<br>       until that connection has been established or for that connection<br>       to have failed.  There MUST be no more than one connection in a<br>       CONNECTING state.  If multiple connections to the same IP address<br>       are attempted simultaneously, the client MUST serialize them so<br>       that there is no more than one connection at a time running<br>       through the following steps.</p>
</blockquote>
<p>因此，如果直接利用原始的WebSocket全双工通信连接进行通信，在适配业务逻辑的时候很可能会耗费大量的工作，而通过发布-订阅模型，则可以复用同一个连接实现不同主题消息的分发</p>
<h3 id="5-1-5-事务"><a href="#5-1-5-事务" class="headerlink" title="5.1.5 事务"></a>5.1.5 事务</h3><p>通过以下帧来控制：</p>
<ul>
<li>ACK</li>
<li>NACK</li>
<li>BEGIN</li>
<li>COMMIT</li>
<li>ABORT</li>
</ul>
<h2 id="5-2-SocketIO"><a href="#5-2-SocketIO" class="headerlink" title="5.2 SocketIO"></a>5.2 SocketIO</h2><p><a href="https://github.com/socketio/socket.io-protocol" target="_blank" rel="external">socketio/socket.io-protocol: Socket.IO 1.0 Protocol specification and parser component / node.js module.</a></p>
<p>SocketIO实际上也定义了发布订阅模型。通过namespace来订阅不同的『主题』，namespace下继续划分room，，类似于二级主题。</p>
<h3 id="5-2-1-协议定义"><a href="#5-2-1-协议定义" class="headerlink" title="5.2.1 协议定义"></a>5.2.1 协议定义</h3><h3 id="5-2-2-实现"><a href="#5-2-2-实现" class="headerlink" title="5.2.2 实现"></a>5.2.2 实现</h3><h4 id="5-2-2-1-socket-io"><a href="#5-2-2-1-socket-io" class="headerlink" title="5.2.2.1 socket.io"></a>5.2.2.1 socket.io</h4><p><a href="https://github.com/socketio/socket.io/" target="_blank" rel="external">https://github.com/socketio/socket.io/</a></p>
<h4 id="5-2-2-2-netty-socketio"><a href="#5-2-2-2-netty-socketio" class="headerlink" title="5.2.2.2 netty-socketio"></a>5.2.2.2 netty-socketio</h4><p><a href="https://github.com/mrniko/netty-socketio" target="_blank" rel="external">https://github.com/mrniko/netty-socketio</a></p>
<h1 id="6-测试"><a href="#6-测试" class="headerlink" title="6 测试"></a>6 测试</h1><p><a href="https://github.com/crossbario/autobahn-testsuite" target="_blank" rel="external">https://github.com/crossbario/autobahn-testsuite</a></p>
<h1 id="7-FAQ"><a href="#7-FAQ" class="headerlink" title="7 FAQ"></a>7 FAQ</h1><h2 id="7-1-Socket和WebSocket有什么关系？"><a href="#7-1-Socket和WebSocket有什么关系？" class="headerlink" title="7.1 Socket和WebSocket有什么关系？"></a>7.1 Socket和WebSocket有什么关系？</h2><p>就像Java和JavaScript，并没有什么太大的关系，但又不能说完全没关系。</p>
<p>通常所说的<strong>Socket</strong> API，是指操作系统中（也可能不是操作系统）提供的对于传输层（TCP/UDP）抽象的接口。</p>
<p><strong>WebSocket</strong>是一种在单个TCP连接上进行全双工通讯的协议。</p>
<p><a href="http://blog.jobbole.com/106009/" target="_blank" rel="external">WebSocket这个名称的由来</a>：</p>
<blockquote>
<p>08年6月18日，一群WHATWG的工程师在讨论一些技术问题，一个工程师提到说「我们之前讨论的那个东西，不要叫TCPConnection 了，还是起个别的名字吧 」，接着几个名字被提及，DuplexConnection，TCPSocket，SocketConnection ，一个叫mcarter（Michael Carter ）的工程师说他马上要写一篇关于Comet的文章，如果可以确定这个名称，想在文章中引用这个名字。</p>
<p>Socket一直以来都被人用来表示网络中一个连接的两端，考虑到怎么让工程师更容易接受，后来Hixie说了一句「我看WebSocket这个名字就很适合嘛（Hixie briefly pops back online to record that “WebSocket” would probably be a good new name for the TCPConnection object）」，大家都没有异议，紧接着mcarter在Comet Daily中发表了文章<a href="http://cometdaily.com/2008/07/04/html5-websocket/index.html" target="_blank" rel="external">Independence Day: HTML5 WebSocket Liberates Comet From Hacks</a>，后来随着各大浏览器对WebSocket的支持，它变成了实际的标准，IETF也沿用了这个名字。</p>
</blockquote>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="http://colobu.com/2015/07/14/performance-comparison-of-7-websocket-frameworks/" target="_blank" rel="external">七种WebSocket框架的性能比较</a></li>
<li><a href="https://github.com/smallnest/C1000K-Servers" target="_blank" rel="external">smallnest/C1000K-Servers - GitHub</a></li>
<li><a href="http://colobu.com/2015/05/22/implement-C1000K-servers-by-spray-netty-undertow-and-node-js/" target="_blank" rel="external">使用四种框架分别实现百万websocket常连接的服务器</a></li>
<li><a href="https://en.wikipedia.org/wiki/WebSocket" target="_blank" rel="external">WebSocket - Wikipedia</a></li>
<li><a href="https://tools.ietf.org/html/rfc6455" target="_blank" rel="external">RFC 6455</a></li>
<li><a href="http://stomp.github.io" target="_blank" rel="external">STOMP</a></li>
<li><a href="http://jmesnil.net/stomp-websocket/doc/" target="_blank" rel="external">STOMP Over WebSocket</a></li>
<li><a href="http://stomp.github.io/stomp-specification-1.2.html" target="_blank" rel="external">STOMP Protocol Specification, Version 1.2</a></li>
<li><a href="https://github.com/sockjs/sockjs-client" target="_blank" rel="external">sockjs/sockjs-client</a></li>
<li><a href="http://blog.jobbole.com/106009/" target="_blank" rel="external">WebSocket 和 Socket 的区别 - 文章 - 伯乐在线</a></li>
<li><a href="http://cometdaily.com/2008/07/04/html5-websocket/index.html" target="_blank" rel="external">Comet Daily  » Blog Archive   » Independence Day: HTML5 WebSocket Liberates Comet From Hacks</a></li>
<li><a href="https://www.w3.org/TR/websockets/" target="_blank" rel="external">The WebSocket API</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-概念&quot;&gt;&lt;a href=&quot;#1-概念&quot; class=&quot;headerlink&quot; title=&quot;1 概念&quot;&gt;&lt;/a&gt;1 概念&lt;/h1&gt;&lt;h2 id=&quot;1-1-comet&quot;&gt;&lt;a href=&quot;#1-1-comet&quot; class=&quot;headerlink&quot; title=&quot;1.1 comet&quot;&gt;&lt;/a&gt;1.1 comet&lt;/h2&gt;&lt;p&gt;天不生WS，万古如长夜。&lt;/p&gt;
&lt;p&gt;在WebSocket出现之前，服务端主动推送消息给浏览器的需求就已经存在了，但是HTTP这个协议本来就不是设计用来进行双向通信的，所以机智的工程师们采取了各种hack的方式来实现这种功能，这些实现方式都统称为&lt;code&gt;comet&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;但是无可避免地，这些技术都存在缺陷，既然WebSocket都出现了，那么这些技术大概也能进博物馆了，除了实现Fallback方案时需要去了解之外，这些技术感觉价值不大了，所以不展开说，如果读者有兴趣，可以根据关键词找资料去了解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="WebSocket" scheme="http://bungder.github.io/tags/WebSocket/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区域</title>
    <link href="http://bungder.github.io/2018/03/12/jvm-run-time-data-area/"/>
    <id>http://bungder.github.io/2018/03/12/jvm-run-time-data-area/</id>
    <published>2018-03-12T07:51:06.000Z</published>
    <updated>2018-03-13T05:08:57.049Z</updated>
    
    <content type="html"><![CDATA[<p>根据 <a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf" target="_blank" rel="external">The Java<sup>&reg;</sup> Virtual Machine Specification - Java SE 8 Edition</a>，可以整理出其定义的JVM内存结构如下：</p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/runtime2.png" alt=""><br>JVM Specification定义的运行时数据区域模型↑↑↑</p>
<p>其中，方法区所属的区域并没有强制要求。不同的JVM实现，其内存分布细节会不同。</p>
<a id="more"></a>
<h1 id="1-PCR（程序计数寄存器-The-Program-Counter-Register）"><a href="#1-PCR（程序计数寄存器-The-Program-Counter-Register）" class="headerlink" title="1 PCR（程序计数寄存器 The Program Counter Register）"></a>1 PCR（程序计数寄存器 The Program Counter Register）</h1><blockquote>
<p>The Java Virtual Machine can support many threads of execution at once (JLS §17). Each Java Virtual Machine thread has its own pc (program counter) register. At any point, each Java Virtual Machine thread is executing the code of a single method, namely the $current method$ (§2.6) for that thread. </p>
<ul>
<li>If that method is <strong>not native</strong>, the pc register contains the <strong>address</strong> of the Java Virtual Machine instruction currently being executed. </li>
<li>If the method currently being executed by the thread is <strong>native</strong>, the value of the Java Virtual Machine’s pc register is <strong>undefined</strong>. The Java Virtual Machine’s pc register is wide enough to hold a returnAddress or a native pointer on the specific platform.</li>
</ul>
</blockquote>
<h1 id="2-JVM-Stack"><a href="#2-JVM-Stack" class="headerlink" title="2 JVM Stack"></a>2 JVM Stack</h1><h2 id="2-1-Frames-栈帧"><a href="#2-1-Frames-栈帧" class="headerlink" title="2.1 Frames 栈帧"></a>2.1 Frames 栈帧</h2><blockquote>
<p>A $frame$ is used to store data and partial results, as well as to perform dynamic linking, return values for methods, and dispatch exceptions.</p>
<p><strong>A new frame is created each time a method is invoked</strong>. <strong>A frame is destroyed when its method invocation completes, whether that completion is normal or abrupt</strong> (it throws an uncaught exception). Frames are <strong>allocated from the Java Virtual Machine stack (§2.5.2) of the thread creating the frame</strong>. Each frame has its own <strong>array of local variables</strong> (§2.6.1), its own <strong>operand stack</strong> (§2.6.2), and <strong>a reference to the run- time constant pool (§2.5.5) of the class of the current method</strong>.<br>The sizes of the local variable array and the operand stack are determined at compile-time and are supplied along with the code for the method associated with the frame (§4.7.3). Thus the size of the frame data structure depends only on the implementation of the Java Virtual Machine, and the memory for these structures can be allocated simultaneously on method invocation.<br>Only one frame, the frame for the executing method, is active at any point in a given thread of control. This frame is referred to as the $current frame$, and its method is known as the $current method$. The class in which the current method is defined is the $current class$. Operations on local variables and the operand stack are typically with reference to the current frame.<br>A frame <strong>ceases to be current</strong> if its method <strong>invokes another method</strong> or if its <strong>method completes</strong>. When a method is invoked, a new frame is created and becomes current when control transfers to the new method. On method return, the current frame passes back the result of its method invocation, if any, to the previous frame. The current frame is then discarded as the previous frame becomes the current one.<br>Note that a frame created by a thread is local to that thread and cannot be referenced by any other thread.</p>
</blockquote>
<h3 id="2-1-1-Local-Variables-本地变量表"><a href="#2-1-1-Local-Variables-本地变量表" class="headerlink" title="2.1.1 Local Variables 本地变量表"></a>2.1.1 Local Variables 本地变量表</h3><p>A <strong>single</strong> local variable can hold a value of type </p>
<ul>
<li>boolean, </li>
<li>byte, </li>
<li>char, </li>
<li>short, </li>
<li>int, </li>
<li>float, </li>
<li>reference</li>
<li>returnAddress. </li>
</ul>
<p>A <strong>pair</strong> of local variables can hold a value of type <strong>long</strong> or <strong>double</strong>.</p>
<p>本地变量表通过索引来处理，第一个本地变量的下标（index）为0.</p>
<blockquote>
<p>The Java Virtual Machine uses local variables to pass parameters on method invocation. On class method invocation, any parameters are passed in consecutive local variables starting from local variable 0. On instance method invocation, local variable 0 is always used to pass a reference to the object on which the instance method is being invoked (<code>this</code> in the Java programming language). Any parameters are subsequently passed in consecutive local variables starting from local variable 1.</p>
</blockquote>
<p>Java虚拟机使用局部变量在方法调用上传递参数。 在<strong>类方法</strong>（静态方法）调用中，任何参数都是<strong>从局部变量0开始</strong>的连续局部变量中传递的。在<strong>实例方法</strong>调用中，局部变量0用于将引用（<code>this</code>）传递给调用者。 随后从局部变量1开始，连续的局部变量传递任何参数。</p>
<h3 id="2-1-2-Operand-Stacks-操作数栈"><a href="#2-1-2-Operand-Stacks-操作数栈" class="headerlink" title="2.1.2 Operand Stacks 操作数栈"></a>2.1.2 Operand Stacks 操作数栈</h3><blockquote>
<p>The maximum depth of the operand stack of a frame is determined at compile-time and is supplied along with the code for the method associated with the frame</p>
</blockquote>
<p>用处：</p>
<blockquote>
<p>The operand stack is empty when the frame that contains it is created. The Java Virtual Machine supplies instructions to <strong>load constants or values from local variables or fields onto the operand stack</strong>. Other Java Virtual Machine instructions <strong>take operands from the operand stack, operate on them, and push the result back onto the operand stack</strong>. The operand stack is also used to <strong>prepare parameters to be passed to methods</strong> and to <strong>receive method results</strong>.</p>
</blockquote>
<h3 id="2-1-3-Return-Value"><a href="#2-1-3-Return-Value" class="headerlink" title="2.1.3 Return Value"></a>2.1.3 Return Value</h3><h3 id="2-1-4-Dynamic-Linking"><a href="#2-1-4-Dynamic-Linking" class="headerlink" title="2.1.4 Dynamic Linking"></a>2.1.4 Dynamic Linking</h3><blockquote>
<p>Each frame (§2.6) contains <strong>a reference to the run-time constant pool</strong> (§2.5.5) for the type of the current method to support $dynamic linking$ of the method code. The class file code for a method refers to methods to be invoked and variables to be accessed via symbolic references. Dynamic linking translates these symbolic method references into concrete method references, loading classes as necessary to resolve as-yet-undefined symbols, and translates variable accesses into appropriate offsets in storage structures associated with the run-time location of these variables.</p>
</blockquote>
<p><a href="http://ifeve.com/jvm-internals/" target="_blank" rel="external">JVM内部原理</a>:</p>
<blockquote>
<p><strong>每个栈帧都包含了运行时常量池的引用</strong>。这个引用指向了这个栈帧正在执行的方法所在的类的常量池，它对动态链接提供了支持。</p>
<p>C/C++ 代码通常编译成一个对象文件，然后多个文件被链接起来生成一个可用的文件比如一个可执行文件或者动态链接库。在链接阶段，符号引用在每个对象文件里被替换成一个和最终执行相关的实际的内存地址。在Java里，这个链接过程在运行时是自动发生的。</p>
<p>当Java文件被编译时，所有的变量和方法引用都作为符号引用保存在class文件的常量池里。一个符号引用是一个逻辑引用并不是一个实际的指向一个物理内存地址的引用。不同的JVM实现能选择什么时候去解决符号引用，它通常发生在class文件加载后的验证，加载完成，立即调用或者静态解析等阶段，另外一种发生的时候是当符号引用第一次被使用，也叫做延迟或者延期解析。无论如何当每个引用第一次使用的时候，JVM必须保证解析发生，并抛出任何解析错误。<strong>绑定是一个字段、方法或者类在符号引用被替换为直接引用的过程</strong>，这仅仅发生一次，因为符号引用是完全替换的。如果符号引用关联到某个类，而这个类却还没准备好，就会引发类加载。每个直接引用被保存为偏移地址而不是和变量或者方法在运行时的位置相关的存储结构。</p>
</blockquote>
<h1 id="3-Heap-堆"><a href="#3-Heap-堆" class="headerlink" title="3 Heap 堆"></a>3 Heap 堆</h1><blockquote>
<p>The Java Virtual Machine has a heap that is <strong>shared among all Java Virtual Machine threads</strong>. The heap is the <strong>run-time data area from which memory for all class instances and arrays is allocated</strong>.<br>…<br><strong>Heap storage for objects is reclaimed by</strong> an automatic storage management system (known as a <strong>garbage collector</strong>); objects are never explicitly deallocated.</p>
</blockquote>
<p><a href="https://www.zhihu.com/question/49044988/answer/113961406" target="_blank" rel="external">https://www.zhihu.com/question/49044988/answer/113961406</a> 评论里：</p>
<blockquote>
<p>如果“堆”是说<strong>Java heap</strong>，那么这个也对也错。因为JVM规范对抽象的“Java heap”的定义是“存储Java对象的地方”，也就是说Java对象在哪里，哪里就是Java heap。HotSpot的PermGen里是会存储部分Java对象的，例如说一些java.lang.String实例。这些String实例占的部分就得算是Java heap。</p>
<p>如果“堆”是说<strong>GC heap</strong>，那么这个错误。<strong>PermGen是HotSpot的GC heap的一部分</strong>。</p>
<p>一般说“native memory”都是跟GC heap相对的，所以一般取上述后者的定义</p>
</blockquote>
<h1 id="4-Method-Area"><a href="#4-Method-Area" class="headerlink" title="4 Method Area"></a>4 Method Area</h1><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf" target="_blank" rel="external">The Java<sup>&reg;</sup> Virtual Machine Specification - Java SE 8 Edition</a>:</p>
<blockquote>
<p>The Java Virtual Machine has a method area that <strong>is shared among all Java Virtual Machine threads</strong>.</p>
<p>It stores per-class structures such as the <strong>run-time constant pool</strong>, <strong>field</strong> and <strong>method data</strong>, and <strong>the code for methods and constructors</strong>, including the special methods (§2.9) used in class and instance initialization and interface initialization.</p>
</blockquote>
<hr>
<blockquote>
<p>Although the method area is logically part of the heap, simple implementations may choose not to either garbage collect or compact it. This specification does not mandate the location of the method area or the policies used to manage compiled code.</p>
</blockquote>
<p>尽管方法区域在逻辑上是堆的一部分，但是简单的实现可以选择不垃圾收集或压缩它。 本规范不要求方法区域的位置或用于管理编译代码的策略</p>
<hr>
<h2 id="4-1-Run-Time-Const-Pool"><a href="#4-1-Run-Time-Const-Pool" class="headerlink" title="4.1 Run-Time Const Pool"></a>4.1 Run-Time Const Pool</h2><blockquote>
<p>A run-time constant pool is a <strong>per-class or per-interface</strong> run-time representation of the constant_pool table in a class file.<br>…<br>The run-time constant pool for a class or interface <strong>is constructed when the class or interface is created</strong> (§5.3) by the Java Virtual Machine.</p>
</blockquote>
<p>根据上面这段引用，可知以下几点：</p>
<ol>
<li>每个类（或者interface，为便于行文，下面都统称为类）对应一个run-time constant pool</li>
<li>是class文件中constant_pool的运行时表达</li>
<li>在类被JVM加载时创建</li>
</ol>
<p>那么，要理清其结构，需要先了解class文件的结构。可参见我的另一篇博文：<a href="/2018/03/10/java-class-file-format/">Java class文件格式</a></p>
<p style="color:red;font-weight:bold">其余具体的存储结构，JVM规范并没有作进一步阐述。</p>

<h2 id="4-2-Field"><a href="#4-2-Field" class="headerlink" title="4.2 Field"></a>4.2 Field</h2><p style="color:red;font-weight:bold">具体的存储结构，JVM规范并没有作进一步阐述。</p>

<h2 id="4-3-Method-Data"><a href="#4-3-Method-Data" class="headerlink" title="4.3 Method Data"></a>4.3 Method Data</h2><p style="color:red;font-weight:bold">具体的存储结构，JVM规范并没有作进一步阐述。</p>

<h2 id="4-4-Code"><a href="#4-4-Code" class="headerlink" title="4.4 Code"></a>4.4 Code</h2><p style="color:red;font-weight:bold">具体的存储结构，JVM规范并没有作进一步阐述。</p>

<h1 id="5-Native-Method-Stacks"><a href="#5-Native-Method-Stacks" class="headerlink" title="5 Native Method Stacks"></a>5 Native Method Stacks</h1><blockquote>
<p>Java Virtual Machine implementations that cannot load native methods and that do not themselves rely on conventional stacks need not supply native method stacks. If supplied, <strong>native method stacks are typically allocated per thread when each thread is created</strong>.</p>
</blockquote>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="http://ifeve.com/jvm-internals/" target="_blank" rel="external">JVM内部原理 | 并发编程网 – ifeve.com</a></li>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf" target="_blank" rel="external">The Java<sup>&reg;</sup> Virtual Machine Specification - Java SE 8 Edition</a></li>
<li><a href="http://openjdk.java.net/jeps/122" target="_blank" rel="external">JEP 122: Remove the Permanent Generation</a></li>
<li><a href="https://www.zhihu.com/question/49044988/answer/113961406" target="_blank" rel="external">方法区的Class信息,又称为永久代,是否属于Java堆？ - 知乎</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;根据 &lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;The Java&lt;sup&gt;&amp;reg;&lt;/sup&gt; Virtual Machine Specification - Java SE 8 Edition&lt;/a&gt;，可以整理出其定义的JVM内存结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://otlnkjq1m.bkt.clouddn.com/runtime2.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;JVM Specification定义的运行时数据区域模型↑↑↑&lt;/p&gt;
&lt;p&gt;其中，方法区所属的区域并没有强制要求。不同的JVM实现，其内存分布细节会不同。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://bungder.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="http://bungder.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM加载、启动和初始化</title>
    <link href="http://bungder.github.io/2018/03/10/jvm-loading-linking-initializing/"/>
    <id>http://bungder.github.io/2018/03/10/jvm-loading-linking-initializing/</id>
    <published>2018-03-09T17:08:12.000Z</published>
    <updated>2018-03-12T08:01:51.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0 概述"></a>0 概述</h1><p>这实际上是<a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf" target="_blank" rel="external">《The Java<sup>&reg;</sup> Virtual Machine Specification - Java SE 8 Edition》</a>中第五章内容（Loading, Linking, and Initializing）的部分翻译。主要目的是整理阅读笔记，让我自己看得明白，在这个前提下，尽量让别人看得明白，如果读者觉得我写得很混乱，还请自行阅读原文，不便之处敬请见谅。如有错误，还请指正（拉到页面底部点击『联系我』就可以发邮件给我）。</p>
<p>阅读本文内容需要先对java的class文件结构有所了解。如果尚不了解，不妨参考我的另一篇博文 <a href="/2018/03/10/java-class-file-format/">Java class文件格式</a></p>
<hr>
<ul>
<li><strong>加载</strong>是这样一个过程：寻找一个特定名称的class或者interface的二进制表达形式（binary representation），然后从这个二进制表达形式中创建出一个class或者interface。</li>
<li><strong>链接</strong>是这样一个过程：取得class或者interface，然后将其结合到JVM的运行时状态，使得它可以被执行。</li>
<li><strong>初始化</strong>一个class或者interface的过程就是执行这个class或者interface的初始化方法<code>&lt;clinit&gt;</code>的过程。</li>
</ul>
<a id="more"></a>
<h1 id="1-运行时常量池（Run-Time-Constant-Pool）"><a href="#1-运行时常量池（Run-Time-Constant-Pool）" class="headerlink" title="1 运行时常量池（Run-Time Constant Pool）"></a>1 运行时常量池（Run-Time Constant Pool）</h1><p>在class或interface被创建的时候，用二进制形式的class文件中的<code>constant_pool</code>表来构造运行时常量池。运行时常量池中的所有引用最初都是符号引用。运行时常量池中的符号引用来自二进制表达形式中的以下结构：</p>
<table>
<thead>
<tr>
<th>Symbolic Reference to</th>
<th>Structure in class file</th>
</tr>
</thead>
<tbody>
<tr>
<td>class</td>
<td>CONSTANT_Class_info</td>
</tr>
<tr>
<td>field</td>
<td>CONSTANT_Fieldref_info</td>
</tr>
<tr>
<td>class method</td>
<td>CONSTANT_Methodref_info</td>
</tr>
<tr>
<td>interface method</td>
<td>CONSTANT_InterfaceMethodref_info</td>
</tr>
<tr>
<td>method handle</td>
<td>CONSTANT_MethodHandle_info</td>
</tr>
<tr>
<td>method type</td>
<td>CONSTANT_MethodType_info</td>
</tr>
<tr>
<td>call site specifier</td>
<td>CONSTANT_InvokeDynamic_info</td>
</tr>
</tbody>
</table>
<p>另外，某些不是符号引用的运行时值则来自<code>constant_pool</code>表中的以下结构：</p>
<ul>
<li>字符串字面量  <code>CONSTANT_String_info</code></li>
<li>运行时常量值 <code>CONSTANT_Integer_info</code> <code>CONSTANT_Float_info</code> <code>CONSTANT_Long_info</code> <code>CONSTANT_Double_info</code></li>
</ul>
<p><code>constant_pool</code>里剩下的结构则只会被间接使用：</p>
<ul>
<li><code>CONSTANT_NameAndType_info</code></li>
<li><code>CONSTANT_Utf8_info</code></li>
</ul>
<h1 id="2-JVM启动"><a href="#2-JVM启动" class="headerlink" title="2 JVM启动"></a>2 JVM启动</h1><p>JVM通过使用引导类加载器（<strong>bootstrap class loader</strong>）创建初始类来启动，初始类的指定方式与实现相关。</p>
<p>然后，JVM链接初始类，初始化它，并调用<code>public static void main(String[])</code>方法。此方法的调用将驱动所有进一步的执行。执行构成 main 方法的JVM指令可能会导致附加类和接口的链接（链接之后进而创建），以及调用其他方法。</p>
<p>在JVM的实现中，初始类可以作为命令行参数提供。或者， JVM的实现可以提供一个初始类来设置类加载程序，然后加载一个应用程序。可以选择其他初始类，只要它们与前一段中给出的规范一致即可。</p>
<h1 id="3-创建和加载（Creation-and-Loading）"><a href="#3-创建和加载（Creation-and-Loading）" class="headerlink" title="3 创建和加载（Creation and Loading）"></a>3 创建和加载（Creation and Loading）</h1><p><span id="creationAndLoading"></span></p>
<h2 id="符号约定"><a href="#符号约定" class="headerlink" title="符号约定"></a>符号约定</h2><p>class或者interface $C$ 用其类名 $N$ 来表示，其创建过程由另一个class or interface $D$ 触发，$D$通过运行时常量池引用$C$。class or interface的创建也可以通过$D$调用Java SE平台的特定class libraries中的方法来触发，例如反射。</p>
<p>如果$C$不是数组类，则通过使用class loader加载$C$的二进制表达来创建。</p>
<p>数组类没有外部的二进制表达，由JVM来创建，而不是class loader。</p>
<p>类加载器 $L$可以通过以下两种方式来创建$C$：</p>
<ul>
<li>直接定义$C$    </li>
<li>委托给另一个class loader</li>
</ul>
<p>如果$L$委托了另一个class loader来加载$C$，则说$L$启动了$C$的加载（$L$ <em>initiates loading of</em> $C$），或者等价地说，$L$是$C$的<code>initiating loader</code>。$N^L$ 表示由$L$ initiates loading的$C$。</p>
<p>如果$L$直接创建$C$，则我们说$L$定义了$C$（$L$ <em>defines</em> $C$），或者等价地说，$L$是$C$的 <code>defining loader</code>。&lt;$N, L$&gt; 表示由$L$ defines的$C$。同时，$L$也是$C$的<code>initiating loader</code>。</p>
<h2 id="3-1-用Bootstrap-Class-Loader加载"><a href="#3-1-用Bootstrap-Class-Loader加载" class="headerlink" title="3.1 用Bootstrap Class Loader加载"></a>3.1 用Bootstrap Class Loader加载</h2><p>下面的步骤用于加载、从而创建由$N$表示的、非数组类型的类或者接口$C$。</p>
<ol>
<li><p>首先，JVM判断bootstrap class loader是否已经被标记为由$N$表示的类或接口的initiating loader。如果是，这个类或者接口就是$C$，后续没有创建过程。</p>
<p> 否则，JVM将$N$作为参数来调用bootstrap class loader的方法，用平台依赖的方式来搜索给出的$C$的表达形式。</p>
<p> 通常，类或接口会使用分层文件系统中的文件来表达，并且其名称会编码在文件的路径名（pathname）中。</p>
<p> 这个阶段需要检查以下错误：</p>
<ul>
<li>如果找不到给出的$C$的表达形式，抛出<code>ClassNotFoundException</code></li>
</ul>
</li>
<li><p>然后，JVM尝试使用<a href="TBD">加载算法</a>，从给出的表达形式中取得$N$表示的类，将结果作为$C$。</p>
</li>
</ol>
<h2 id="3-2-用User-defined-Class-Loader加载"><a href="#3-2-用User-defined-Class-Loader加载" class="headerlink" title="3.2 用User-defined Class Loader加载"></a>3.2 用User-defined Class Loader加载</h2><p>下面的步骤用于使用<strong>用户定义的类加载器（user-defined class loader）</strong> $L$加载、从而创建由$N$表示的、非数组类型的类或者接口$C$。</p>
<ol>
<li>首先，JVM判断$L$是否已经被标记为由$N$表示的类或接口的initiating loader。如果是，这个类或者接口就是$C$，后续没有创建过程。</li>
<li>否则，JVM调用$L$的<code>loadClass(N)</code>方法，这个调用的返回值就是创建后的类或接口$C$。</li>
<li>然后JVM将$L$记录为$C$的initiating loader。</li>
</ol>
<p>当使用$N$来调用$L$的<code>loadClass</code>方法时，$L$必须执行以下两个操作之一来加载$C$：</p>
<ol>
<li>$L$可以创建一个byte数组，这个数组表达了$C$的<code>ClassFile</code>结构；然后它必须调用<code>ClassLoader</code>类的<code>defineClass</code>方法，执行这个方法使得JVM用$L$使用<a href="TBD">加载算法</a>从byte数组中取得$C$。</li>
<li>$L$可以将加载过程委托给另一个类加载器$L’$，将参数$N$直接或者间接地传给$L’$的方法调用（一般是<code>loadClass</code>方法）。方法调用的结果是$C$。</li>
</ol>
<p>在上述两个步骤中，无论处于任何原因无法加载$N$所表示的类或接口时，都必须抛出<code>ClassNotFoundException</code>。</p>
<h2 id="3-3-创建数组类（Array-Classes）"><a href="#3-3-创建数组类（Array-Classes）" class="headerlink" title="3.3 创建数组类（Array Classes）"></a>3.3 创建数组类（Array Classes）</h2><p>下面的步骤用于使用类加载器$L$来加载、从而创建由$N$表示的、数组类型的类$C$。</p>
<p>如果$L$已被记录为与$N$相同的组件类型（component type）的数组类的initiating loader，则该类为$C$，并且不需要再进行任何数组类创建。</p>
<p>否则，执行下面的步骤来创建$C$：</p>
<ol>
<li>如果组件类型是引用类型（reference type），则使用$L$递归地应用<a href="#creationAndLoading">本节的算法</a>，以加载、从而创建$C$的组件类型；</li>
<li>JVM使用指定的组件类型和维数创建一个新的数组类。<ul>
<li>如果组件类型是一个引用类型，$C$会被标记为 『已被组件类型的defining class loader定义了』（<em>having been defined by the defining class loader of the component type</em>）。否则，$C$会被标记为『已被bootstrap class loader定义了』（<em>having been defined by the bootstrap class loader</em>）。</li>
<li>无论如何，JVM都会将$L$记录为$C$的initiating loader。</li>
<li>如果组件类型是一个引用类型，那么这个数组类的可见性（accessibility）和组件类型一致，否则可见性为<code>public</code></li>
</ul>
</li>
</ol>
<h2 id="3-4-加载的约束"><a href="#3-4-加载的约束" class="headerlink" title="3.4 加载的约束"></a>3.4 加载的约束</h2><p>在class loader出现的时候，确保类型安全链接要特别小心。有可能存在这样一种情况：两个不同的class loader触发了由$N$表示的class or interface的加载，而$N$在每个class loader里可能表示了不同的class or interface。</p>
<p style="color:red;font-size:30px;font-weight:BOLD">（TBD）</p>

<h2 id="3-5-从class文件表达形式中获得Class"><a href="#3-5-从class文件表达形式中获得Class" class="headerlink" title="3.5 从class文件表达形式中获得Class"></a>3.5 从class文件表达形式中获得<code>Class</code></h2><p>将一个非数组类型的class或者interface $C$ 记为 $N$，下面是用loader $L$从class文件格式中加载$C$为Class对象的步骤：</p>
<ol>
<li>JVM判断$L$是否已经被标记为$N$的initiating loader，如果是，创建过程将不可用，并且抛出<code>LinkageError</code></li>
<li>否则，JVM尝试解析给出的表达。但是，给出的表达不一定是$C$的一个有效的表达。这个加载阶段必须检查以下错误：<ul>
<li>如果给出的表达形式不是<code>ClassFile</code>结构，抛出<code>ClassFormatError</code></li>
<li>否则，如果给出的表达不在支持的版本范围内（major version和minor version），抛出<code>UnsupportedClassVersionError</code></li>
<li>否则，如果给出的表达不是类名$N$的实际表达，抛出<code>NoClassDefFoundError</code>或者其子类</li>
</ul>
</li>
<li>如果$C$有直接父类，就用<a href="#ClassAndInterfaceResolution">Class and Interface Resolution</a>算法来解析出$C$到其直接父类的符号链接。<br> 这个阶段要检查以下错误：<ul>
<li>如果其直接父类实际上是一个interface，抛出<code>IncompatibleClassChangeError</code></li>
<li>否则，如果$C$任意父类是$C$本身，抛出<code>ClassCircularityError</code></li>
</ul>
</li>
<li>如果$C$有任何直接父接口，则使用 <a href="#ClassAndInterfaceResolution">Class and Interface Resolution</a> 算法来解析出$C$到其直接父接口的符号链接。<br> 这个阶段要检查以下错误：<ul>
<li>如果其直接父接口实际上不是一个interface，抛出<code>IncompatibleClassChangeError</code></li>
<li>如果$C$的任何一个父接口是$C$本身，抛出<code>ClassCircularityError</code></li>
</ul>
</li>
<li>JVM将$C$标记为拥有$L$作为其defining class loader，并且标记$L$是$C$的initiating loader</li>
</ol>
<h1 id="4-链接（Linking）"><a href="#4-链接（Linking）" class="headerlink" title="4 链接（Linking）"></a>4 链接（Linking）</h1><p>链接一个class或者interface包括<strong>验证</strong>和<strong>准备</strong>阶段，涉及到的对象有：</p>
<ul>
<li>该class或interface本身</li>
<li>其直接父类</li>
<li>其直接父接口</li>
<li>如果这是数组类型，还涉及其元素类型</li>
</ul>
<p>解析class或interface中的符号链接是链接阶段可选的一部分。</p>
<p>该规范允许实现的灵活性，以便在链接活动（以及由于递归、加载）发生时，只要保持以下所有属性：</p>
<ul>
<li>一个class或interface在链接前要被完全加载</li>
<li>一个class或interface在初始化前要被完全验证</li>
<li>程序执行的一些操作可能直接或间接地要求链接涉及错误的class或interface，当这些错误被检测到时，必须在发生这些操作的地方抛出这些错误。</li>
</ul>
<p>例如，一个JVM实现可能选择在使用到一个class或interface的时候才去解析其中的每个符号链接（懒加载或者延迟加载，”lazy” or “late” resolution），或者在验证class的时候一次性解析其中所有的符号链接（”eager” or “static” resolution）。这意味着在某些实现中，在class或interface初始化之后还有可能继续执行解析过程。无论采用哪种策略，在解析期间检测到的任何错误都必须在程序中的使用对class或interface的符号引用的地方抛出，不论是直接还是间接地使用到。</p>
<p>由于链接阶段涉及到新数据结构的分配（allocation），有可能因<code>OutOfMEmoryError</code>而失败。</p>
<h2 id="4-1-验证（Verification）"><a href="#4-1-验证（Verification）" class="headerlink" title="4.1 验证（Verification）"></a>4.1 验证（Verification）</h2><p>验证阶段确保了class或interface的二进制表达在结构上是正确的。验证阶段有可能引起其他类或接口被加载，但是不需要导致它们被验证或者准备。</p>
<p>如果class或interface的二进制表达不满足<a href="/2018/03/10/java-class-file-format/#ConstraintsOnJavaVirtualMachineCode">The class File Format - Constraints on Java Virtual Machine Code</a>中列出的静态约束或结构型约束，那么在程序中导致class或interface被校验的地方必须要抛出<code>VerifyError</code>。</p>
<p>如果因为抛出了LinkageError（或子类）实例错误导致JVM尝试验证class或interface失败，则随后尝试验证class或interface始终会失败，并抛出相同的错误 作为初步验证尝试的结果。</p>
<h2 id="4-2-准备（Preparation）"><a href="#4-2-准备（Preparation）" class="headerlink" title="4.2 准备（Preparation）"></a>4.2 准备（Preparation）</h2><p>准备阶段包括创建class or interface的static fields，并初始化默认值。这个过程不需要执行任何JVM代码。静态字段的显式初始值设定是作为初始化的一部分执行，而不是准备阶段。</p>
<p>在class or interface $C$ 的准备阶段，JVM有以下约束：</p>
<p>令$L_1$为$C$的defining loader，$m$为$C$中覆盖自父类或者父接口&lt;$D, L_2$&gt;的方法，对于每个$m$，令其返回值为$T_r$，形参为$T_{f_1},…,T_{f_n}$，那么：</p>
<ul>
<li>如果$T_r$不是数组类型，令$T_0$为$T_r$；否则令$T_0$为$T_r$的元素类型；</li>
<li>对于$i=1, …, n$，如果$T_{f_i}$不是数组类型，令$T_i$为$T_{f_i}$；否则令$T_i$为$T_{f_i}$的元素类型</li>
</ul>
<p>则有：<br>$$ {T_i}^{L_1} = {T_i}^{L_2}, i=0, …, n $$</p>
<p>更进一步的情况，如果$C$实现了父接口&lt;$I, L_3$&gt;中的方法$m$，但是$C$没有声明方法$m$，但是$C$的父类&lt;$D, L_2$&gt;声明了方法$m$的实现，则有以下约束：</p>
<p>$m$的返回类型记为$T_r$，$m$的形参类型记为$T_{f1}, …, T_{fn}$，则：<br>如果$T_r$不是数组类型，令$T_0$为$T_r$，否则令$T_0$为$T_r$的元素类型（element type）。<br>对于所有$i=0, …, n$：如果$T_{fi}$不是数组类型，则$T_i$为$T_{fi}$，否则$T_i$为$T_{fi}$的元素类型。<br>那么有<br>$$ {T_i}^{L_2}={T_i}^{L_3}, i=0, …, n $$</p>
<h2 id="4-3-解析（Resolution）"><a href="#4-3-解析（Resolution）" class="headerlink" title="4.3 解析（Resolution）"></a>4.3 解析（Resolution）</h2><p>以下JVM指令对运行时常量池做了符号引用，执行任何这些指令都需要解析其符号引用：<br><code>anewarray</code>, <code>checkcast</code>, <code>getfield</code>, <code>getstatic</code>, <code>instanceof</code>, <code>invokedynamic</code>, <code>invokeinterface</code>, <code>invokespecial</code>, <code>invokestatic</code>, <code>invokevirtual</code>, <code>ldc</code>, <code>ldc_w</code>, <code>multianewarray</code>, <code>new</code>, <code>putfield</code>, and <code>putstatic</code>。</p>
<p>解析是从运行时常量池中的符号引用中动态确定具体值的过程。</p>
<p>解析某次出现的invokedynamic指令中的符号引用并不意味着该符号引用对于其它任何invokedynamic指令来说都被解析了。</p>
<p>对于其他指令来说，解析了某次出现的指令中的符号引用，确实意味着该符号应用对于其他任意的非invokedynamic指令来说都视为被解析了。</p>
<p>上文的意思是，由一个特定的invokedynamic指令确定的具体值是一个绑定到该特定invokedynamic指令的<code>call site object</code>。</p>
<p style="color:red;font-size:30px;font-weight:BOLD">（TBD）</p>

<p>下面部分阐述对一个class或interface $D$所引用的、尚在运行时常量池中的符号引用的解析过程。符号引用的类型不同，解析的细节也不同。</p>
<h3 id="4-3-1-Class-and-Interface-Resolution-类和接口解析"><a href="#4-3-1-Class-and-Interface-Resolution-类和接口解析" class="headerlink" title="4.3.1 Class and Interface Resolution 类和接口解析"></a>4.3.1 Class and Interface Resolution 类和接口解析</h3><p><span id="ClassAndInterfaceResolution"></span></p>
<p>执行以下步骤来将$D$所引用的、未解析的符号引用解析为由$N$表示的class或interface $C$：</p>
<ol>
<li>用$D$的defining class loader来创建由$N$表示的class或interface，细节在<a href="#creationAndLoading">第三节（Creation and Loading）</a>给出了。<br> 在创建过程中抛出的任何作为失败结果的exception都可以作为解析过程的失败结果抛出。</li>
<li>如果$C$是数组类并且其元素类型是一个引用类型，则递归地调用<a href="#ClassAndInterfaceResolution">上一小节（Class and Interface Resolution）</a>中的算法来解析其元素类型的符号引用。</li>
<li>最后，检查$C$的访问授权：<ul>
<li>如果$C$不能被$D$访问，抛出<code>IllegalAccessError</code><br>  这种情况举例：如果$C$这个类本来是被声明为public的，但是在$D$编译完之后被改为了非public了。</li>
</ul>
</li>
</ol>
<p>如果第1、2步成功执行但是第3步失败了，$C$仍然是有效和可用的。尽管如此，这个解析过程也是失败了的，并且$D$也禁止访问$C$。</p>
<h3 id="4-3-2-Field-Resolution-字段解析"><a href="#4-3-2-Field-Resolution-字段解析" class="headerlink" title="4.3.2 Field Resolution 字段解析"></a>4.3.2 Field Resolution 字段解析</h3><p>为了将$D$中未解析的符号引用解析为一个class或interface $C$中的一个字段（field），由字段引用（field reference）给出的到$C$的符号引用必须首先被解析（<a href="#ClassAndInterfaceResolution">4.3.1</a>）。</p>
<p>在解析字段引用的时候，字段解析（field resolution）首先尝试查找在$C$及其父类中引用的字段：</p>
<ol>
<li>如果$C$使用了由字段引用指定的名称和描述符来声明一个字段，则字段查找（field lookup）成功。所声明的字段就是查找结果。</li>
<li>否则，对$C$的直接父接口递归地进行字段查找。</li>
<li>否则，如果$C$具有父类$S$，对$S$递归地进行字段查找。</li>
<li>否则，字段查找失败。</li>
</ol>
<p>然后：</p>
<ul>
<li>如果字段查找失败了，字段解析抛出<code>NoSuchFieldError</code></li>
<li>否则，如果字段查找成功了，但是$D$不能访问该引用字段，抛出<code>IllegalAccessError</code></li>
<li>否则，令实际声明该引用字段的class或interface为&lt;$E, L_1$&gt;，令$L_2$为$D$的defining loading<br>  假设引用字段的类型为$T_f$，如果$T_f$不是数组类型，则$T$为$T_f$，如果$T_f$为数组类型，则$T$为$T_f$的元素类型。<br>  JVM必须保证$T^{L_1}=T^{L_2}$的约束。</li>
</ul>
<h3 id="4-3-3-Method-Resolution-方法解析"><a href="#4-3-3-Method-Resolution-方法解析" class="headerlink" title="4.3.3 Method Resolution 方法解析"></a>4.3.3 Method Resolution 方法解析</h3><p>为了将$D$中的符号引用解析为class $C$中的方法，由该方法引用给出的到$C$的符号引用要首先被解析（<a href="#ClassAndInterfaceResolution">4.3.1</a>）。</p>
<p>当解析一个方法引用时：</p>
<ol>
<li>如果$C$是一个interface，抛出<code>IncompatibleClassChangeError</code></li>
<li><p>否则，方法解析（method resolution）尝试在$C$及其父类中定位该引用方法：</p>
<ul>
<li><p>如果$C$刚好声明了一个由该方法引用指定的名字的方法，并且声明的方法是一个<em>signature polymorphic method</em>，那么方法查找成功。描述符中声明的所有类名都被解析了。</p>
<blockquote>
<p>The resolved method is the signature polymorphic method declaration. It is not necessary for C to declare a method with the descriptor specified by the method reference.</p>
</blockquote>
<p>  <strong>signature polymorphic method</strong>这个概念在<a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf" target="_blank" rel="external">《The Java<sup>&reg;</sup> Virtual Machine Specification - Java SE 8 Edition》</a>的 2.9 Special Methods 中定义：</p>
<blockquote>
<p>  A method is signature polymorphic if all of the following are true:<br>  • It is declared in the java.lang.invoke.MethodHandle class.<br>  • It has a single formal parameter of type Object[].<br>  • It has a return type of Object.<br>  • It has the ACC_VARARGS and ACC_NATIVE flags set.</p>
</blockquote>
</li>
<li><p>否则，如果$C$用该方法引用指定的名字和描述符声明了一个方法，方法查找成功。</p>
</li>
<li>否则，如果$C$有父类，对$C$的直接父类递归地调用步骤2。</li>
</ul>
</li>
<li>否则，方法解析尝试在$C$的父接口中定位引用方法：<ul>
<li>If the maximally-specific superinterface methods of C for the name and descriptor specified by the method reference include exactly one method that does not have its <code>ACC_ABSTRACT</code> flag set, then this method is chosen and method lookup succeeds.</li>
<li>Otherwise, if any superinterface of C declares a method with the name and descriptor specified by the method reference that has neither its <code>ACC_PRIVATE</code> flag nor its <code>ACC_STATIC</code> flag set, one of these is arbitrarily chosen and method lookup succeeds.</li>
<li>Otherwise, method lookup fails.</li>
</ul>
</li>
</ol>
<p>A maximally-specific superinterface method of a class or interface $C$ for a particular method name and descriptor is any method for which all of the following are true:</p>
<ul>
<li>The method is declared in a superinterface (direct or indirect) of $C$.</li>
<li>The method is declared with the specified name and descriptor.</li>
<li>The method has neither its <code>ACC_PRIVATE</code> flag nor its <code>ACC_STATIC</code> flag set.</li>
<li>Where the method is declared in interface I, there exists no other maximally- specific superinterface method of $C$ with the specified name and descriptor that is declared in a subinterface of $I$.</li>
</ul>
<p>The result of method resolution is determined by whether method lookup succeeds or fails:</p>
<ul>
<li>If method lookup fails, method resolution throws a <code>NoSuchMethodError</code>.</li>
<li>Otherwise, if method lookup succeeds and the referenced method is not<br>accessible (§5.4.4) to $D$, method resolution throws an <code>IllegalAccessError</code>.</li>
<li><p>Otherwise,let&lt;$E,L_1$&gt;be the class or interface in which the referenced method $m$ is actually declared, and let $L_2$ be the defining loader of $D$.<br>  Given that the return type of $m$ is $T_r$, and that the formal parameter types of $m$<br>are $T_{f_1}, …, T_{f_n}$, then:<br>  If $T_r$ is not an array type, let $T_0$ be $T_r$; otherwise, let $T_0$ be the element type (§2.4) of $T_r$.<br>  For $i = 1, …, n$: If $T_{f_i}$ is not an array type, let $T_i$ be $T_{f_i}$; otherwise, let $T_i$ be the element type (§2.4) of $T_{f_i}$.<br>  The Java Virtual Machine must impose the loading constraints $T^{L_1} = T^{L_2}$ for $i = 0, …, n$ (§5.3.4).<br>  When resolution searches for a method in the class’s superinterfaces, the best outcome is to identify a maximally-specific non-<code>abstract</code> method. It is possible that this method will be chosen by method selection, so it is desirable to add class loader constraints for it.<br>  Otherwise, the result is nondeterministic. This is not new: <em>The Java<sup>®</sup> Virtual Machine Specification</em> has never identified exactly which method is chosen, and how “ties” should be broken. Prior to Java SE 8, this was mostly an unobservable distinction. However, beginning with Java SE 8, the set of interface methods is more heterogenous, so care must be taken to avoid problems with nondeterministic behavior. Thus:</p>
<ul>
<li>Superinterface methods that are <code>private</code> and <code>static</code> are ignored by resolution. This is consistent with the Java programming language, where such interface methods are not inherited.</li>
<li><p>Any behavior controlled by the resolved method should not depend on whether the method is <code>abstract</code> or not.</p>
<p>Note that if the result of resolution is an abstract method, the referenced class $C$ may be non-abstract. Requiring $C$ to be <code>abstract</code> would conflict with the nondeterministic choice of superinterface methods. Instead, resolution assumes that the run time class of the invoked object has a concrete implementation of the method.</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-3-4-Interface-Method-Resolution"><a href="#4-3-4-Interface-Method-Resolution" class="headerlink" title="4.3.4 Interface Method Resolution"></a>4.3.4 Interface Method Resolution</h3><p style="color:red;font-size:30px;font-weight:BOLD">（TBD）</p>

<h3 id="4-3-5-Method-Type-and-Method-Handle-Resolution"><a href="#4-3-5-Method-Type-and-Method-Handle-Resolution" class="headerlink" title="4.3.5 Method Type and Method Handle Resolution"></a>4.3.5 Method Type and Method Handle Resolution</h3><p style="color:red;font-size:30px;font-weight:BOLD">（TBD）</p>

<h3 id="4-3-6-Call-Site-Specifier-Resolution"><a href="#4-3-6-Call-Site-Specifier-Resolution" class="headerlink" title="4.3.6 Call Site Specifier Resolution"></a>4.3.6 Call Site Specifier Resolution</h3><p style="color:red;font-size:30px;font-weight:BOLD">（TBD）</p>


<h2 id="4-4-访问控制（Access-Control）"><a href="#4-4-访问控制（Access-Control）" class="headerlink" title="4.4 访问控制（Access Control）"></a>4.4 访问控制（Access Control）</h2><p>当且仅当以下都为真时，class或interface $C$对class或interface $D$来说是可访问的：</p>
<ul>
<li>$C$为<code>public</code>；</li>
<li>$C$和$D$是同一个运行时包（run-time package）的成员。</li>
</ul>
<p>当且仅当以下都为真时，一个字段或方法$R$对class或interface $D$来说是可访问的：</p>
<ul>
<li>$R$为<code>public</code>；</li>
<li>$R$为<code>protected</code>并且在类$C$中被声明，同时$D$是$C$的子类或者是$C$本身。更进一步，如果$R$不是<code>static</code>的，指向$R$的符号引用必须包含指向类$T$的符号引用，这个$T$是$D$的子类或者是$D$的父类或者是$D$本身；</li>
<li>$R$是<code>protected</code>的，或者具有默认的访问级别（即没有显式声明访问修饰符，非<code>public</code>、非<code>protected</code>、非<code>private</code>），并且和$D$是同一个运行时包（run-time package）的成员；</li>
<li>$R$是<code>private</code>的并且在$D$里声明。</li>
</ul>
<p>上述访问控制的讨论省略了调用<code>protected</code>方法或者访问<code>protected</code>字段的目标的相关限制（目标必须是$D$或者是$D$的子类型）。这种约束是<a href="/2018/03/10/java-class-file-format/#VerificationOfClassFiles">验证阶段</a>的一部分，不是链接时的访问控制。</p>
<h2 id="4-5-覆盖（Overriding）"><a href="#4-5-覆盖（Overriding）" class="headerlink" title="4.5 覆盖（Overriding）"></a>4.5 覆盖（Overriding）</h2><p>有$C$类中声明的实例方法$m_C$和$A$类中声明的另一个实例方法$m_A$，当$m_C$和$m_A$一样或者下列条件都为真时，我们说$m_C$覆盖了$m_A$：</p>
<ul>
<li>$C$是$A$的子类</li>
<li>$m_C$和$m_A$具有同样的名称和描述符</li>
<li>$M_C$没有标记为<code>ACC_PRIVATE</code></li>
<li>以下其中一个为真：<ul>
<li>$m_A$被标记为<code>ACC_PUBLIC</code>；或者被标记为<code>ACC_PROTECTED</code>；或者都没有标记为<code>ACC_PUBLIC</code>、<code>ACC_PROTECTED</code>、<code>ACC_PRIVATE</code>并且$A$和$C$属于同一个运行时包。</li>
<li>$m_C$覆盖了方法$m’$（$m’$与$m_C$和$m_A$都不同），而$m’$覆盖了$m_A$</li>
</ul>
</li>
</ul>
<h1 id="5-初始化（Initialization）"><a href="#5-初始化（Initialization）" class="headerlink" title="5 初始化（Initialization）"></a>5 初始化（Initialization）</h1><p style="color:red;font-size:30px;font-weight:BOLD">（TBD）</p>

<h1 id="6-绑定本地方法实现（Binding-Native-Method-Implementations）"><a href="#6-绑定本地方法实现（Binding-Native-Method-Implementations）" class="headerlink" title="6 绑定本地方法实现（Binding Native Method Implementations）"></a>6 绑定本地方法实现（Binding Native Method Implementations）</h1><p>绑定是这样一个过程：一种用Java以外的语言编写的、实现本地方法的函数被集成到JVM中以便执行。</p>
<p>虽然这个过程通常被称为链接，但术语『绑定』在这个规范中用来避免与JVM的类或接口链接混淆。</p>
<h1 id="7-JVM-Exit"><a href="#7-JVM-Exit" class="headerlink" title="7 JVM Exit"></a>7 JVM Exit</h1><p>某个线程调用了<strong><code>Runtime</code>或<code>System</code>类的<code>exit</code></strong>方法或者<strong><code>Runtime</code>类的<code>halt</code></strong>方法、并且<code>exit</code>或<code>halt</code>操作得到了安全管理器（security manager）的准许时，JVM退出。</p>
<p>另外，JNI（Java Native Interface）规范描述了当JNI Invocation API被用于加载和卸载JVM时JVM的终止。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf" target="_blank" rel="external">The Java<sup>&reg;</sup> Virtual Machine Specification - Java SE 8 Edition</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-概述&quot;&gt;&lt;a href=&quot;#0-概述&quot; class=&quot;headerlink&quot; title=&quot;0 概述&quot;&gt;&lt;/a&gt;0 概述&lt;/h1&gt;&lt;p&gt;这实际上是&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《The Java&lt;sup&gt;&amp;reg;&lt;/sup&gt; Virtual Machine Specification - Java SE 8 Edition》&lt;/a&gt;中第五章内容（Loading, Linking, and Initializing）的部分翻译。主要目的是整理阅读笔记，让我自己看得明白，在这个前提下，尽量让别人看得明白，如果读者觉得我写得很混乱，还请自行阅读原文，不便之处敬请见谅。如有错误，还请指正（拉到页面底部点击『联系我』就可以发邮件给我）。&lt;/p&gt;
&lt;p&gt;阅读本文内容需要先对java的class文件结构有所了解。如果尚不了解，不妨参考我的另一篇博文 &lt;a href=&quot;/2018/03/10/java-class-file-format/&quot;&gt;Java class文件格式&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;加载&lt;/strong&gt;是这样一个过程：寻找一个特定名称的class或者interface的二进制表达形式（binary representation），然后从这个二进制表达形式中创建出一个class或者interface。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;链接&lt;/strong&gt;是这样一个过程：取得class或者interface，然后将其结合到JVM的运行时状态，使得它可以被执行。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;初始化&lt;/strong&gt;一个class或者interface的过程就是执行这个class或者interface的初始化方法&lt;code&gt;&amp;lt;clinit&amp;gt;&lt;/code&gt;的过程。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://bungder.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="http://bungder.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java class文件格式</title>
    <link href="http://bungder.github.io/2018/03/10/java-class-file-format/"/>
    <id>http://bungder.github.io/2018/03/10/java-class-file-format/</id>
    <published>2018-03-09T17:02:29.000Z</published>
    <updated>2018-03-13T00:52:21.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-概述"><a href="#0-概述" class="headerlink" title="0 概述"></a>0 概述</h1><p>这实际上是<a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf" target="_blank" rel="external">《The Java<sup>&reg;</sup> Virtual Machine Specification - Java SE 8 Edition》</a>中第四章内容（The class File Format）的部分翻译。主要目的是整理阅读笔记，让我自己看得明白，在这个前提下，尽量让别人看得明白，如果读者觉得我写得很混乱，还请自行阅读原文，不便之处敬请见谅。如有错误，还请指正（拉到页面底部点击『联系我』就可以发邮件给我）。</p>
<hr>
<p>每一个class文件都包含了一个单独的class或者interface的定义。尽管一个class或者interface并不是有一个以文件形式存在的外部表达，但是下面还是通俗地将class或interface的任何有效表达称为类文件格式（<em>the class file format</em>）。</p>
<p>一个类文件由一个<code>8位字节流</code>组成。 所有的16位，32位和64位量分别通过读取2、4、8个连续的8位字节来构造。 多字节数据项总是以<code>big-endian顺序</code>存储，其中高字节排在第一位。 在Java SE平台中，此格式由接口<code>java.io.DataInput</code>和<code>java.io.DataOutput</code>以及类如<code>java.io.DataInputStream</code>和<code>java.io.DataOutputStream</code>支持。</p>
<a id="more"></a>
<p>本章定义了自己的一组表示类文件数据的数据类型：</p>
<ul>
<li>类型<code>u1</code>，<code>u2</code>和<code>u4</code>分别表示一个无符号的一个，两个或四个字节数量（即1 byte、2 byte和4 byte）。</li>
</ul>
<p>在Java SE平台中，这些类型可以通过接口<code>java.io.DataInput</code>的<code>readUnsignedByte</code>，<code>readUnsignedShort</code>和<code>readInt</code>等方法读取。</p>
<h1 id="1-ClassFile结构"><a href="#1-ClassFile结构" class="headerlink" title="1 ClassFile结构"></a>1 <code>ClassFile</code>结构</h1><p>一个class文件包含一个单独的<code>ClassFile</code>结构：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="section">ClassFile</span> &#123;</div><div class="line">   <span class="attribute">u4</span>             magic;</div><div class="line">   <span class="attribute">u2</span>             minor_version;</div><div class="line">   <span class="attribute">u2</span>             major_version;</div><div class="line">   <span class="attribute">u2</span>             constant_pool_count;</div><div class="line">   <span class="attribute">cp_info</span>        constant_pool[constant_pool_count-<span class="number">1</span>];</div><div class="line">   <span class="attribute">u2</span>             access_flags;</div><div class="line">   <span class="attribute">u2</span>             this_class;</div><div class="line">   <span class="attribute">u2</span>             super_class;</div><div class="line">   <span class="attribute">u2</span>             interfaces_count;</div><div class="line">   <span class="attribute">u2</span>             interfaces[interfaces_count];</div><div class="line">   <span class="attribute">u2</span>             fields_count;</div><div class="line">   <span class="attribute">field_info</span>     fields[fields_count];</div><div class="line">   <span class="attribute">u2</span>             methods_count;</div><div class="line">   <span class="attribute">method_info</span>    methods[methods_count];</div><div class="line">   <span class="attribute">u2</span>             attributes_count;</div><div class="line">   <span class="attribute">attribute_info</span> attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>ClassFile</code>结构中的各个<code>item</code>含义如下：</p>
<h2 id="1-1-magic"><a href="#1-1-magic" class="headerlink" title="1.1 magic"></a>1.1 magic</h2><p>魔法数字，用于标识class文件格式，固定为<code>0xCAFEBABE</code></p>
<h2 id="1-2-minor-version-major-version"><a href="#1-2-minor-version-major-version" class="headerlink" title="1.2 minor_version, major_version"></a>1.2 minor_version, major_version</h2><p>minor_version和major_version组合到一起，决定了class文件格式的版本。</p>
<p>假设class文件的major_version为$M$，minor_version为$m$，那么我们将class文件格式的版本记为$M.m$，因此，这个版本号可以按字典序排序，例如$1.5&lt;2.0&lt;2.1$。</p>
<p>一个JVM的实现可以支持的class文件格式版本记为$v$，当且仅当$v$落在连续区间 $M_i.0 \leq v \leq M_j.m$ 时成立。</p>
<p>JVM实现所遵循的Java SE平台的<strong>release level</strong>决定了其支持范围。</p>
<p>例如</p>
<ul>
<li>Oracle对JDK release 1.0.2的JVM实现支持的class文件格式版本为$[45.0, 45.3]$</li>
<li>JDK release 1.1.* 支持$[45.0, 45.65535]$</li>
<li>对于$k \geq 2$，JDK release $1.k$ 支持范围为$[45.0, 44+k.0]$</li>
</ul>
<h2 id="1-3-constant-pool-count"><a href="#1-3-constant-pool-count" class="headerlink" title="1.3 constant_pool_count"></a>1.3 constant_pool_count</h2><p><code>constant_pool[]</code>中的条目数量+1</p>
<h2 id="1-4-constant-pool"><a href="#1-4-constant-pool" class="headerlink" title="1.4 constant_pool[]"></a>1.4 constant_pool[]</h2><p>constant_pool是一个结构表，表示<code>ClassFile</code>结构及其子结构中引用的各种</p>
<ul>
<li>字符串常量</li>
<li>类和接口名</li>
<li>字段名</li>
<li>其他常量。</li>
</ul>
<p>每个constant_pool表项的格式由第一个“标记(tag)”字节表示。<br>constant_pool表下标的取值范围是$[1,\ constant\_pool\_count)$</p>
<h2 id="1-5-access-flags"><a href="#1-5-access-flags" class="headerlink" title="1.5 access_flags"></a>1.5 access_flags</h2><p>access_flags 项的值是用于<strong>表示对此类或接口的访问权限和属性</strong>的标志的掩码。</p>
<p>16bit</p>
<table>
<thead>
<tr>
<th>Flag Name</th>
<th>Value</th>
<th>二进制</th>
<th>十进制表示</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td>ACC_PUBLIC</td>
<td>0x0001</td>
<td>00000000 00000001</td>
<td>1</td>
<td>声明<code>public</code></td>
</tr>
<tr>
<td>ACC_FINAL</td>
<td>0x0010</td>
<td>00000000 00010000</td>
<td>16</td>
<td>声明<code>final</code></td>
</tr>
<tr>
<td>ACC_SUPER</td>
<td>0x0020</td>
<td>00000000 00100000</td>
<td>32</td>
<td>当调用<code>invokespecial</code>指令时，特殊对待父类方法</td>
</tr>
<tr>
<td>ACC_INTERFACE</td>
<td>0x0200</td>
<td>00000010 00000000</td>
<td>512</td>
<td>指明这是<code>interface</code>而非<code>class</code></td>
</tr>
<tr>
<td>ACC_ABSTRACT</td>
<td>0x0400</td>
<td>00000100 00000000</td>
<td>1024</td>
<td>声明<code>abstract</code></td>
</tr>
<tr>
<td>ACC_SYNTHETIC</td>
<td>0x1000</td>
<td>00010000 00000000</td>
<td>4096</td>
<td>声明synthetic，在源码中不存在</td>
</tr>
<tr>
<td>ACC_ANNOTATION</td>
<td>0x2000</td>
<td>00100000 00000000</td>
<td>8192</td>
<td>指明这是注解</td>
</tr>
<tr>
<td>ACC_ENUM</td>
<td>0x4000</td>
<td>01000000 00000000</td>
<td>16384</td>
<td>指明这是<code>enum</code></td>
</tr>
</tbody>
</table>
<h2 id="1-6-this-class"><a href="#1-6-this-class" class="headerlink" title="1.6 this_class"></a>1.6 this_class</h2><p><code>this_class</code>的值必须是<code>constant_pool[]</code>的有效下标。<code>constant_pool[this_class]</code>必须为<code>CONSTANT_Class_info</code>结构，表示了在此class文件中定义的类或者接口。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="section">CONSTANT_Class_info</span> &#123;</div><div class="line">   <span class="attribute">u1</span> tag;</div><div class="line">   <span class="attribute">u2</span> name_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1-7-super-class"><a href="#1-7-super-class" class="headerlink" title="1.7 super_class"></a>1.7 super_class</h2><p><code>super_class</code>的值也必须是<code>constant_pool[]</code>的有效下标。</p>
<p>对于类来说，</p>
<ul>
<li>如果此值不是0， 则<code>constant_pool[super_class]</code>必须为<code>CONSTANT_Class_info</code>结构，表示了此class文件定义的类的直接父类。</li>
<li>如果此值为0，则此class文件必须表示<code>Object</code>类，这是唯一没有直接父类的类或者接口。</li>
</ul>
<p>对于接口来说，没有规定。</p>
<h2 id="1-8-interfaces-count"><a href="#1-8-interfaces-count" class="headerlink" title="1.8 interfaces_count"></a>1.8 interfaces_count</h2><p>指明了此类的直接父接口的数量。</p>
<h2 id="1-9-interfaces"><a href="#1-9-interfaces" class="headerlink" title="1.9 interfaces[]"></a>1.9 interfaces[]</h2><p>里面的每个值都必须是<code>constant_pool[]</code>的有效下标。所指向的<code>constant_pool</code>中的条目必须为<code>CONSTANT_Class_info</code>结构，指明了其直接父接口。</p>
<h2 id="1-10-fileds-count"><a href="#1-10-fileds-count" class="headerlink" title="1.10 fileds_count"></a>1.10 fileds_count</h2><p>给出<code>fields[]</code>中<code>field_info</code>结构的数量。<code>field_info</code>结构表示了此类或接口所声明的所有field，包括class variables和instance virables（也就是静态变量和实例变量）。</p>
<h2 id="1-11-fields"><a href="#1-11-fields" class="headerlink" title="1.11 fields[]"></a>1.11 fields[]</h2><p>所有值都必须为<code>field_info</code>结构，给出对变量的完整描述。只包含由此类或者接口声明的变量，不包括继承而来的。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="section">field_info</span> &#123;</div><div class="line">   <span class="attribute">u2</span>             access_flags;</div><div class="line">   <span class="attribute">u2</span>             name_index;</div><div class="line">   <span class="attribute">u2</span>             descriptor_index;</div><div class="line">   <span class="attribute">u2</span>             attributes_count;</div><div class="line">   <span class="attribute">attribute_info</span> attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1-12-methods-count"><a href="#1-12-methods-count" class="headerlink" title="1.12 methods_count"></a>1.12 methods_count</h2><p>给出<code>methods[]</code>中<code>method_info</code>结构的数量</p>
<h2 id="1-13-methods"><a href="#1-13-methods" class="headerlink" title="1.13 methods[]"></a>1.13 methods[]</h2><p>所有值都必须为<code>method_info</code>结构。</p>
<p>如果<code>ACC_NATIVE</code>和<code>ACC_ABSTRACT</code>标志都没有在<code>method_info</code>里的<code>access_flags</code>中设置，实现此方法的JVM指令也要提供。</p>
<p><code>methods[]</code>表达了此class or intreface声明的所有方法，包括实例方法、类方法、实例初始化方法和class or interface 初始化方法，不包括继承而来的方法。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="section">method_info</span> &#123;</div><div class="line">   <span class="attribute">u2</span>             access_flags;</div><div class="line">   <span class="attribute">u2</span>             name_index;</div><div class="line">   <span class="attribute">u2</span>             descriptor_index;</div><div class="line">   <span class="attribute">u2</span>             attributes_count;</div><div class="line">   <span class="attribute">attribute_info</span> attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="1-14-attributes-count"><a href="#1-14-attributes-count" class="headerlink" title="1.14 attributes_count"></a>1.14 attributes_count</h2><p>size of <code>attributes[]</code></p>
<h2 id="1-15-attributes"><a href="#1-15-attributes" class="headerlink" title="1.15 attributes[]"></a>1.15 attributes[]</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="section">attribute_info</span> &#123;</div><div class="line">   <span class="attribute">u2</span> attribute_name_index;</div><div class="line">   <span class="attribute">u4</span> attribute_length;</div><div class="line">   <span class="attribute">u1</span> <span class="literal">info</span>[attribute_length];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="2-The-Internal-Form-of-Names"><a href="#2-The-Internal-Form-of-Names" class="headerlink" title="2 The Internal Form of Names"></a>2 The Internal Form of Names</h1><p><span id="internalFormOfNames"></span></p>
<h2 id="2-1-Binary-Class-and-Interface-Names"><a href="#2-1-Binary-Class-and-Interface-Names" class="headerlink" title="2.1 Binary Class and Interface Names"></a>2.1 Binary Class and Interface Names</h2><p>class文件结构中，class和interface的名字总是以一种全限定（fully qualified）的形式表达的，被称为<code>binary names</code>（JLS §13.1）。这些名字总是表达为<code>CONSTANT_Utf8_info</code>结构。</p>
<p>类和接口名称是从那些<code>CONSTANT_NameAndType_info</code>结构中引用的, 它们的名称是其描述符的一部分, 并且来自所有<code>CONSTANT_Class_info</code>结构</p>
<p>由于历史原因, 类文件结构中出现的binary names的语法不同于JLS §13.1中记录的二进制名称的语法。标识符（identifiers）构成了binary names，通常用ASCII码（<code>.</code>）分割各个标识符，在这种内部形式中，替换为了ASCII码（<code>/</code>）。标识符本身必须是未限定的名称（unqualified names）。</p>
<h2 id="2-2-Unqualified-Names-未限定的名称"><a href="#2-2-Unqualified-Names-未限定的名称" class="headerlink" title="2.2 Unqualified Names 未限定的名称"></a>2.2 Unqualified Names 未限定的名称</h2><p>方法、field、本地变量和形式参数的名称都存储为<code>unqualified names</code>。</p>
<p>一个<code>unqualified names</code>必须包含至少一个Unicode码（Unicode code point），并且不能包含以下ASCII字符：<code>.</code>, <code>;</code>, <code>[</code>, <code>/</code>（即，句号、分号、左方括号和斜线）。</p>
<p>方法名的约束还要加上不能出现ASCII字符<code>&lt;</code>、<code>&gt;</code>（即左尖括号和右尖括号），例外方法为</p>
<ul>
<li><code>&lt;init&gt;</code></li>
<li><code>&lt;clinit&gt;</code></li>
</ul>
<h1 id="3-Descriptors-描述符"><a href="#3-Descriptors-描述符" class="headerlink" title="3 Descriptors 描述符"></a>3 Descriptors 描述符</h1><p>描述符是用于表示field或者方法的字符串。</p>
<h2 id="3-1-Grammer-Notaion-语法符号"><a href="#3-1-Grammer-Notaion-语法符号" class="headerlink" title="3.1 Grammer Notaion 语法符号"></a>3.1 Grammer Notaion 语法符号</h2><p>（先定义用于描述描述符构成的语法）：<br>描述符是使用语法指定的。语法是一组生产、 描述字符序列如何形成各种语法正确的描述符。</p>
<ul>
<li>语法的终端符号以固定宽度字体显示。</li>
<li>非终结名称符号以斜体类型显示。</li>
<li>非终结名称的定义由定义的非终结名称的名称引入，后跟冒号。</li>
<li>非终结名称的一个或多个可选定义随后将跟随后续行。</li>
<li>生产右侧的语法 {x} 表示 x 的零个或多个匹配项。</li>
<li>生产右侧的短语 (one of) 表示以下行或行上的每个终端符号都是可选的定义。</li>
</ul>
<h2 id="3-2-Field-Descriptors"><a href="#3-2-Field-Descriptors" class="headerlink" title="3.2 Field Descriptors"></a>3.2 Field Descriptors</h2><p><img src="http://otlnkjq1m.bkt.clouddn.com/FieldDescriptors.jpeg" alt=""></p>
<p>field descriptors的说明：</p>
<table>
<thead>
<tr>
<th>FieldType term</th>
<th>Type</th>
<th>Interpretation</th>
</tr>
</thead>
<tbody>
<tr>
<td>B</td>
<td>byte</td>
<td>signed byte  </td>
</tr>
<tr>
<td>C</td>
<td>char</td>
<td>Unicode character code point in the Basic Multilingual Plane, encoded with UTF-16 </td>
</tr>
<tr>
<td>D</td>
<td>double</td>
<td>double-precision floating-point value </td>
</tr>
<tr>
<td>F</td>
<td>float</td>
<td>single-precision floating-point value </td>
</tr>
<tr>
<td>I</td>
<td>int</td>
<td>integer  </td>
</tr>
<tr>
<td>J</td>
<td>long</td>
<td>long integer </td>
</tr>
<tr>
<td>L ClassName ;</td>
<td>reference</td>
<td>an instance of class ClassName </td>
</tr>
<tr>
<td>S</td>
<td>short</td>
<td>signed short </td>
</tr>
<tr>
<td>Z</td>
<td>boolean</td>
<td>true or false </td>
</tr>
<tr>
<td>[</td>
<td>reference</td>
<td>one array dimension </td>
</tr>
</tbody>
</table>
<p>例子：</p>
<ul>
<li>一个Object实例表示为：<code>Ljava/lang/Object;</code></li>
<li>一个多维数组<code>double[][][]</code>表示为<code>[[[D</code></li>
</ul>
<h2 id="3-3-Method-Descriptors-方法描述符"><a href="#3-3-Method-Descriptors-方法描述符" class="headerlink" title="3.3 Method Descriptors 方法描述符"></a>3.3 Method Descriptors 方法描述符</h2><p><img src="http://otlnkjq1m.bkt.clouddn.com/MethodDescriptors.jpeg" alt=""></p>
<p>例子：</p>
<ul>
<li><p>1</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Object <span class="title">m</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">double</span> d, Thread t)</span> </span>&#123;...&#125;</div></pre></td></tr></table></figure>
<p>  描述符为：<code>(IDLjava/lang/Thread;)Ljava/lang/Object;</code></p>
</li>
</ul>
<h1 id="4-The-Constant-Pool"><a href="#4-The-Constant-Pool" class="headerlink" title="4 The Constant Pool"></a>4 The Constant Pool</h1><p>Java 虚拟机指令不依赖于类、接口、类实例或数组的运行时布局。相反, 指令指的是 constant_pool 表中的符号信息。</p>
<p><code>constant_pool</code>中的所有条目都具有以下的一般结构：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="section">cp_info</span> &#123;</div><div class="line">    <span class="attribute">u1</span> tag;</div><div class="line">    <span class="attribute">u1</span> <span class="literal">info</span>[]; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，<code>tag</code>用于指示<code>cp_info</code>条目的类型，<code>info</code>数组的内容随<code>tag</code>的值而变化。每个标记字节必须后跟两个或多个字节, 以提供有关特定常量的信息。<code>tag</code>的取值范围如下：</p>
<table>
<thead>
<tr>
<th>Constant Type</th>
<th>Value</th>
</tr>
</thead>
<tbody>
<tr>
<td>CONSTANT_Class</td>
<td>7</td>
</tr>
<tr>
<td>CONSTANT_Fieldref</td>
<td>9</td>
</tr>
<tr>
<td>CONSTANT_Methodref</td>
<td>10</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref</td>
<td>11</td>
</tr>
<tr>
<td>CONSTANT_String</td>
<td>8</td>
</tr>
<tr>
<td>CONSTANT_Integer</td>
<td>3</td>
</tr>
<tr>
<td>CONSTANT_Float</td>
<td>4</td>
</tr>
<tr>
<td>CONSTANT_Long</td>
<td>5</td>
</tr>
<tr>
<td>CONSTANT_Double</td>
<td>6</td>
</tr>
<tr>
<td>CONSTANT_NameAndType</td>
<td>12</td>
</tr>
<tr>
<td>CONSTANT_Utf8</td>
<td>1</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle</td>
<td>15</td>
</tr>
<tr>
<td>CONSTANT_MethodType</td>
<td>16</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic</td>
<td>18</td>
</tr>
</tbody>
</table>
<h2 id="4-1-CONSTANT-Class-info"><a href="#4-1-CONSTANT-Class-info" class="headerlink" title="4.1 CONSTANT_Class_info"></a>4.1 CONSTANT_Class_info</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="section">CONSTANT_Class_info</span> &#123;</div><div class="line">    <span class="attribute">u1</span> tag;</div><div class="line">    <span class="attribute">u2</span> name_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>tag</code>的值为<code>7</code>，表示这是一个<code>CONSTANT_Class</code>，<code>name_index</code>必须是<code>constant_pool</code>的有效下标，指向的必须是一个<code>CONSTANT_Utf8_info</code>结构。也就是说指向了常量池中表示类名的字符串常量。类名表达为<a href="#internalFormOfNames"><code>internal form</code></a>，例如：</p>
<ul>
<li><code>int[][]</code>表达为<code>[[I</code></li>
<li><code>Thread[]</code>表达为<code>[Ljava/lang/Thread;</code></li>
</ul>
<h2 id="4-2-CONSTANT-Fieldref-info-CONSTANT-Methodref-info和CONSTANT-InterfaceMethodref-info"><a href="#4-2-CONSTANT-Fieldref-info-CONSTANT-Methodref-info和CONSTANT-InterfaceMethodref-info" class="headerlink" title="4.2 CONSTANT_Fieldref_info, CONSTANT_Methodref_info和CONSTANT_InterfaceMethodref_info"></a>4.2 CONSTANT_Fieldref_info, CONSTANT_Methodref_info和CONSTANT_InterfaceMethodref_info</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="section">CONSTANT_Fieldref_info</span> &#123;</div><div class="line">   <span class="attribute">u1</span> tag;</div><div class="line">   <span class="attribute">u2</span> class_index;</div><div class="line">   <span class="attribute">u2</span> name_and_type_index;</div><div class="line">&#125;</div><div class="line"><span class="section">CONSTANT_Methodref_info</span> &#123;</div><div class="line">   <span class="attribute">u1</span> tag;</div><div class="line">   <span class="attribute">u2</span> class_index;</div><div class="line">   <span class="attribute">u2</span> name_and_type_index;</div><div class="line">&#125;</div><div class="line"><span class="section">CONSTANT_InterfaceMethodref_info</span> &#123;</div><div class="line">   <span class="attribute">u1</span> tag;</div><div class="line">   <span class="attribute">u2</span> class_index;</div><div class="line">   <span class="attribute">u2</span> name_and_type_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-3-CONSTANT-String-info"><a href="#4-3-CONSTANT-String-info" class="headerlink" title="4.3 CONSTANT_String_info"></a>4.3 CONSTANT_String_info</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="section">CONSTANT_String_info</span> &#123;</div><div class="line">   <span class="attribute">u1</span> tag;</div><div class="line">   <span class="attribute">u2</span> string_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>string_index<br>必须是<code>constant_pool</code>的有效下标，必须指向<code>CONSTANT_Utf8_info</code>结构。</li>
</ul>
<h2 id="4-4-CONSTANT-Integer-info和CONSTANT-Float-info结构"><a href="#4-4-CONSTANT-Integer-info和CONSTANT-Float-info结构" class="headerlink" title="4.4 CONSTANT_Integer_info和CONSTANT_Float_info结构"></a>4.4 CONSTANT_Integer_info和CONSTANT_Float_info结构</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="section">CONSTANT_Integer_info</span> &#123;</div><div class="line">    <span class="attribute">u1</span> tag;</div><div class="line">    <span class="attribute">u4</span> bytes; </div><div class="line">&#125;</div><div class="line"><span class="section">CONSTANT_Float_info</span> &#123;</div><div class="line">    <span class="attribute">u1</span> tag;</div><div class="line">    <span class="attribute">u4</span> bytes; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>bytes<br>表达实际值</li>
</ul>
<h2 id="4-5-CONSTANT-Long-info和CONSTANT-Double-info结构"><a href="#4-5-CONSTANT-Long-info和CONSTANT-Double-info结构" class="headerlink" title="4.5 CONSTANT_Long_info和CONSTANT_Double_info结构"></a>4.5 CONSTANT_Long_info和CONSTANT_Double_info结构</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="section">CONSTANT_Long_info</span> &#123;</div><div class="line">   <span class="attribute">u1</span> tag;</div><div class="line">   <span class="attribute">u4</span> high_bytes;</div><div class="line">   <span class="attribute">u4</span> low_bytes;</div><div class="line">&#125;</div><div class="line"><span class="section">CONSTANT_Double_info</span> &#123;</div><div class="line">   <span class="attribute">u1</span> tag;</div><div class="line">   <span class="attribute">u4</span> high_bytes;</div><div class="line">   <span class="attribute">u4</span> low_bytes;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-6-CONSTANT-NameAndType-info"><a href="#4-6-CONSTANT-NameAndType-info" class="headerlink" title="4.6 CONSTANT_NameAndType_info"></a>4.6 CONSTANT_NameAndType_info</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="section">CONSTANT_NameAndType_info</span> &#123;</div><div class="line">   <span class="attribute">u1</span> tag;</div><div class="line">   <span class="attribute">u2</span> name_index;</div><div class="line">   <span class="attribute">u2</span> descriptor_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-7-CONSTANT-Utf8-info"><a href="#4-7-CONSTANT-Utf8-info" class="headerlink" title="4.7 CONSTANT_Utf8_info"></a>4.7 CONSTANT_Utf8_info</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="section">CONSTANT_Utf8_info</span> &#123;</div><div class="line">    <span class="attribute">u1</span> tag;</div><div class="line">    <span class="attribute">u2</span> length;</div><div class="line">    <span class="attribute">u1</span> bytes[length];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-8-CONSTANT-MethodHandle-info"><a href="#4-8-CONSTANT-MethodHandle-info" class="headerlink" title="4.8 CONSTANT_MethodHandle_info"></a>4.8 CONSTANT_MethodHandle_info</h2><p><span id="CONSTANT_MethodHandle_info"></span></p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="section">CONSTANT_MethodHandle_info</span> &#123;</div><div class="line">   <span class="attribute">u1</span> tag;</div><div class="line">   <span class="attribute">u1</span> reference_kind;</div><div class="line">   <span class="attribute">u2</span> reference_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li><p>reference_kind</p>
<blockquote>
<p>  The value of the reference_kind item must be in the range <strong>1 to 9</strong>. The value denotes the kind of this method handle, which characterizes its bytecode behavior (§5.4.3.5)(Chapter 5: Loading, Linking, and Initializing).</p>
</blockquote>
</li>
<li>reference_index<br>  必须是<code>constant_pool</code>的有效下标，指向的结构根据<code>reference_kind</code>的不同而有不同的要求：<ul>
<li>如果<code>reference_kind</code>为1、2、3、4，必须指向<code>CONSTANT_Fieldref_info</code>结构</li>
<li>如果<code>reference_kind</code>为5、8，必须指向<code>CONSTANT_Methodref_info</code>，而此结构表达了类的方法或构造器</li>
<li>如果<code>reference_kind</code>为6、7，然后<ul>
<li>如果class文件的版本号小于52.0，必须指向<code>CONSTANT_Methodref_info</code>结构，此结构表示类的方法；</li>
<li>如果class文件的版本号大于或等于52.0，则必须指向<code>CONSTANT_Methodref_info</code>结构或者<code>CONSTANT_InterfaceMethodref_info</code>结构，表达了类或接口的方法；</li>
</ul>
</li>
<li>如果<code>reference_kind</code>为9，必须指向<code>CONSTANT_InterfaceMethodref_info</code>结构，表达了接口方法。</li>
</ul>
</li>
</ul>
<h2 id="4-9-CONSTANT-MethodType-info"><a href="#4-9-CONSTANT-MethodType-info" class="headerlink" title="4.9 CONSTANT_MethodType_info"></a>4.9 CONSTANT_MethodType_info</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="section">CONSTANT_MethodType_info</span> &#123;</div><div class="line">   <span class="attribute">u1</span> tag;</div><div class="line">   <span class="attribute">u2</span> descriptor_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-10-CONSTANT-InvokeDynamic-info"><a href="#4-10-CONSTANT-InvokeDynamic-info" class="headerlink" title="4.10 CONSTANT_InvokeDynamic_info"></a>4.10 CONSTANT_InvokeDynamic_info</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="section">CONSTANT_InvokeDynamic_info</span> &#123;</div><div class="line">   <span class="attribute">u1</span> tag;</div><div class="line">   <span class="attribute">u2</span> bootstrap_method_attr_index;</div><div class="line">   <span class="attribute">u2</span> name_and_type_index;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>bootstrap_method_attr_index<blockquote>
<p>The value of the bootstrap_method_attr_index item must be a valid index into the <strong>bootstrap_methods</strong> array of the <a href="#TheBootstrapMethodsAttribute">bootstrap method table (§4.7.23)</a> of this class file.</p>
</blockquote>
</li>
</ul>
<h1 id="5-Fields"><a href="#5-Fields" class="headerlink" title="5 Fields"></a>5 Fields</h1><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="section">field_info</span> &#123;</div><div class="line">   <span class="attribute">u2</span>             access_flags;</div><div class="line">   <span class="attribute">u2</span>             name_index;</div><div class="line">   <span class="attribute">u2</span>             descriptor_index;</div><div class="line">   <span class="attribute">u2</span>             attributes_count;</div><div class="line">   <span class="attribute">attribute_info</span> attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>attributes[]<br>里面的每个item都必须是<a href="#attributeInfo"><code>attribute_info</code></a>结构</li>
</ul>
<h1 id="6-Methods"><a href="#6-Methods" class="headerlink" title="6 Methods"></a>6 Methods</h1><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="section">method_info</span> &#123;</div><div class="line">       <span class="attribute">u2</span>             access_flags;</div><div class="line">       <span class="attribute">u2</span>             name_index;</div><div class="line">       <span class="attribute">u2</span>             descriptor_index;</div><div class="line">       <span class="attribute">u2</span>             attributes_count;</div><div class="line">       <span class="attribute">attribute_info</span> attributes[attributes_count];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>attributes[]<br>里面的每个item都必须是<a href="#attributeInfo"><code>attribute_info</code></a>结构</li>
</ul>
<h1 id="7-Attributes"><a href="#7-Attributes" class="headerlink" title="7 Attributes"></a>7 Attributes</h1><p><span id="attributeInfo"><br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="section">attribute_info</span> &#123;</div><div class="line">   <span class="attribute">u2</span> attribute_name_index;</div><div class="line">   <span class="attribute">u4</span> attribute_length;</div><div class="line">   <span class="attribute">u1</span> <span class="literal">info</span>[attribute_length];</div><div class="line">&#125;</div></pre></td></tr></table></figure></span></p>
<h2 id="The-Code-Attribute"><a href="#The-Code-Attribute" class="headerlink" title="The Code Attribute"></a>The Code Attribute</h2><figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">Code_attribute &#123;</div><div class="line">    u2 attribute_name_index<span class="comment">;</span></div><div class="line">    u4 attribute_length<span class="comment">;</span></div><div class="line">    u2 max_stack<span class="comment">;</span></div><div class="line">    u2 max_locals<span class="comment">;</span></div><div class="line">    u4 code_length<span class="comment">;</span></div><div class="line">    u1 code[code_length]<span class="comment">;</span></div><div class="line">    u2 exception_table_length<span class="comment">;</span></div><div class="line">    &#123;   u2 start_pc<span class="comment">;</span></div><div class="line">        u2 end_pc<span class="comment">;</span></div><div class="line">        u2 handler_pc<span class="comment">;</span></div><div class="line">        u2 catch_type<span class="comment">;</span></div><div class="line">    &#125; exception_table[exception_table_length]<span class="comment">;</span></div><div class="line">    u2 attributes_count<span class="comment">;</span></div><div class="line">    attribute_info attributes[attributes_count]<span class="comment">;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>max_stack<br>给出在方法执行的任意地方操作数栈的最大深度</li>
<li>max_locals<br>给出方法调用时本地方法表的最大容量</li>
<li><strong>code[]</strong><br><strong>给出了实现方法的JVM代码的实际字节（byte）。</strong></li>
</ul>
<h2 id="The-BootstrapMethods-Attribute"><a href="#The-BootstrapMethods-Attribute" class="headerlink" title="The BootstrapMethods Attribute"></a>The BootstrapMethods Attribute</h2><p><span id="TheBootstrapMethodsAttribute"></span></p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">BootstrapMethods_attribute </span>&#123;</div><div class="line">       u2 attribute_name_index<span class="comment">;</span></div><div class="line">       u4 attribute_length<span class="comment">;</span></div><div class="line">       u2 num_bootstrap_methods<span class="comment">;</span></div><div class="line">       &#123;   u2 <span class="keyword">bootstrap_method_ref;</span></div><div class="line">           u2 num_bootstrap_arguments<span class="comment">;</span></div><div class="line">           u2 <span class="keyword">bootstrap_arguments[num_bootstrap_arguments];</span></div><div class="line">       &#125; <span class="keyword">bootstrap_methods[num_bootstrap_methods];</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>bootstrap_methods[]<ul>
<li>bootstrap_method_ref<br>其值必须是<code>constant_pool</code>中的有效下标，指向的必须是<a href="#CONSTANT_MethodHandle_info"><code>CONSTANT_MethodHandle_info</code></a>结构</li>
</ul>
</li>
</ul>
<h1 id="8-Format-Checking"><a href="#8-Format-Checking" class="headerlink" title="8 Format Checking"></a>8 Format Checking</h1><p style="color:red;font-size:30px;font-weight:BOLD">（TBD）</p>

<h1 id="9-Constraints-on-Java-Virtual-Machine-Code"><a href="#9-Constraints-on-Java-Virtual-Machine-Code" class="headerlink" title="9 Constraints on Java Virtual Machine Code"></a>9 Constraints on Java Virtual Machine Code</h1><p><span id="ConstraintsOnJavaVirtualMachineCode"></span></p>
<p style="color:red;font-size:30px;font-weight:BOLD">（TBD）</p>

<h1 id="10-Verification-of-class-Files"><a href="#10-Verification-of-class-Files" class="headerlink" title="10 Verification of class Files"></a>10 Verification of class Files</h1><p><span id="VerificationOfClassFiles"></span></p>
<p style="color:red;font-size:30px;font-weight:BOLD">（TBD）</p>

<h2 id="10-1-Verification-by-Type-Checking"><a href="#10-1-Verification-by-Type-Checking" class="headerlink" title="10.1 Verification by Type Checking"></a>10.1 Verification by Type Checking</h2><h2 id="10-2-Verification-by-Type-Inference"><a href="#10-2-Verification-by-Type-Inference" class="headerlink" title="10.2 Verification by Type Inference"></a>10.2 Verification by Type Inference</h2><h1 id="11-JVM的限制"><a href="#11-JVM的限制" class="headerlink" title="11 JVM的限制"></a>11 JVM的限制</h1><ul>
<li><code>ClassFile</code>结构中16-bit的<code>constant_pool_count</code>限制了per-class或者per-interface的常量池最多只有<strong>65535</strong>个条目（entries）。这对单个类或接口的总体复杂性起到了内部限制作用。</li>
<li><code>ClassFile</code>结构中的<code>fields_count</code>限制了一个class or interface能声明的<code>field</code>数量不能超过<strong>65535</strong>。（不包括继承的）</li>
<li>方法数量限制同上。（<code>methods_count</code>）</li>
<li>直接父接口的数量限制同上（<code>interfaces_count</code>）</li>
<li>方法调用时创建的帧里面，本地变量表中的本地变量数量最多为<strong>65535</strong>，由<code>Code</code> attribute中的<code>max_locals</code> item所限制，以及由JVM指令集的16-bit本地变量索引所限制。<br>其中，<code>long</code>和<code>double</code>类型视为两个本地变量</li>
<li><code>Code</code> attribute中的<code>max_stack</code> item限制了frame中的操作数栈的大小为<strong>65535</strong><br>其中，<code>long</code>和<code>double</code>类型的操作数视为两个单元</li>
<li><code>method descriptor</code>的定义限制了方法参数的数量最多为<strong>255</strong><br>其中，实例方法的<code>this</code>占了一个单元，<code>long</code>和<code>double</code>类型的会占两个单元</li>
<li>field和方法的名称、field和方法的descriptor以及其他string常量值（包括被<code>ConstantValue</code> attribute引用的）最多为<strong>65535</strong>个<strong>byte</strong>，由<code>CONSTANT_Utf8_info</code>结构中的16-bit无符号<code>length</code> item所限制</li>
<li><p>数组的维度最多为<strong>255</strong>，由<code>multianewarray</code>指令中的opcode <code>dimensions</code>的大小所限制</p>
<blockquote>
<p>  The number of dimensions in an array is limited to 255 by the size of the dimensions opcode of the multianewarray instruction and by the constraints imposed on the multianewarray, anewarray, and newarray instructions</p>
</blockquote>
</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf" target="_blank" rel="external">The Java<sup>&reg;</sup> Virtual Machine Specification - Java SE 8 Edition</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;0-概述&quot;&gt;&lt;a href=&quot;#0-概述&quot; class=&quot;headerlink&quot; title=&quot;0 概述&quot;&gt;&lt;/a&gt;0 概述&lt;/h1&gt;&lt;p&gt;这实际上是&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/jvms8.pdf&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;《The Java&lt;sup&gt;&amp;reg;&lt;/sup&gt; Virtual Machine Specification - Java SE 8 Edition》&lt;/a&gt;中第四章内容（The class File Format）的部分翻译。主要目的是整理阅读笔记，让我自己看得明白，在这个前提下，尽量让别人看得明白，如果读者觉得我写得很混乱，还请自行阅读原文，不便之处敬请见谅。如有错误，还请指正（拉到页面底部点击『联系我』就可以发邮件给我）。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;每一个class文件都包含了一个单独的class或者interface的定义。尽管一个class或者interface并不是有一个以文件形式存在的外部表达，但是下面还是通俗地将class或interface的任何有效表达称为类文件格式（&lt;em&gt;the class file format&lt;/em&gt;）。&lt;/p&gt;
&lt;p&gt;一个类文件由一个&lt;code&gt;8位字节流&lt;/code&gt;组成。 所有的16位，32位和64位量分别通过读取2、4、8个连续的8位字节来构造。 多字节数据项总是以&lt;code&gt;big-endian顺序&lt;/code&gt;存储，其中高字节排在第一位。 在Java SE平台中，此格式由接口&lt;code&gt;java.io.DataInput&lt;/code&gt;和&lt;code&gt;java.io.DataOutput&lt;/code&gt;以及类如&lt;code&gt;java.io.DataInputStream&lt;/code&gt;和&lt;code&gt;java.io.DataOutputStream&lt;/code&gt;支持。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://bungder.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="http://bungder.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Druid连接池监控的一次改造</title>
    <link href="http://bungder.github.io/2017/08/31/druid-monitor-remould/"/>
    <id>http://bungder.github.io/2017/08/31/druid-monitor-remould/</id>
    <published>2017-08-30T17:32:07.000Z</published>
    <updated>2017-09-20T08:31:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h1><p>druid本身提供了监控功能，具体在我另一篇博文《<a href="/2017/08/27/druid-monitor/">Druid连接池监控</a>》里有介绍。当时提到有以下缺陷：</p>
<ol>
<li>无法灵活监控多个目标</li>
<li>切换环境不方便</li>
<li>JMX重连不会成功</li>
</ol>
<p>因此针对这些问题，对其进行改造。改造后的源码已经放在个人的github上：<br><a href="https://github.com/bungder/druid-aggregated-monitor" target="_blank" rel="external">https://github.com/bungder/druid-aggregated-monitor</a></p>
<p>对应本文的版本，已经打了tag：<br><a href="https://github.com/bungder/druid-aggregated-monitor/releases/tag/0.0.1" target="_blank" rel="external">https://github.com/bungder/druid-aggregated-monitor/releases/tag/0.0.1</a></p>
<a id="more"></a>
<p>对于在同一个工程里进行监控和展示的情况不进行考虑，具体原因见刚刚提到的博文。</p>
<h1 id="2-原理分析"><a href="#2-原理分析" class="headerlink" title="2. 原理分析"></a>2. 原理分析</h1><p>首先，监控数据的展示是通过<code>com.alibaba.druid.support.http.StatViewServlet</code>实现的，将其源码贴上来分析：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> com.alibaba.druid.support.http;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.HashMap;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.management.MBeanServerConnection;</div><div class="line"><span class="keyword">import</span> javax.management.ObjectName;</div><div class="line"><span class="keyword">import</span> javax.management.remote.JMXConnector;</div><div class="line"><span class="keyword">import</span> javax.management.remote.JMXConnectorFactory;</div><div class="line"><span class="keyword">import</span> javax.management.remote.JMXServiceURL;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletException;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.alibaba.druid.stat.DruidStatService;</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.support.logging.Log;</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.support.logging.LogFactory;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 注意：避免直接调用Druid相关对象例如DruidDataSource等，相关调用要到DruidStatManagerFacade里用反射实现</div><div class="line"> * </div><div class="line"> * <span class="doctag">@author</span> sandzhang&lt;sandzhangtoo@gmail.com&gt;</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StatViewServlet</span> <span class="keyword">extends</span> <span class="title">ResourceServlet</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Log      LOG                     = LogFactory.getLog(StatViewServlet.class);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span>     serialVersionUID        = <span class="number">1L</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String    PARAM_NAME_RESET_ENABLE = <span class="string">"resetEnable"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String    PARAM_NAME_JMX_URL      = <span class="string">"jmxUrl"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String    PARAM_NAME_JMX_USERNAME = <span class="string">"jmxUsername"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String    PARAM_NAME_JMX_PASSWORD = <span class="string">"jmxPassword"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> DruidStatService      statService             = DruidStatService.getInstance();</div><div class="line"></div><div class="line">    <span class="comment">/** web.xml中配置的jmx的连接地址 */</span></div><div class="line">    <span class="keyword">private</span> String                jmxUrl                  = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">/** web.xml中配置的jmx的用户名 */</span></div><div class="line">    <span class="keyword">private</span> String                jmxUsername             = <span class="keyword">null</span>;</div><div class="line">    <span class="comment">/** web.xml中配置的jmx的密码 */</span></div><div class="line">    <span class="keyword">private</span> String                jmxPassword             = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">private</span> MBeanServerConnection conn                    = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StatViewServlet</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">super</span>(<span class="string">"support/http/resources"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">        <span class="keyword">super</span>.init();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            String param = getInitParameter(PARAM_NAME_RESET_ENABLE);</div><div class="line">            <span class="keyword">if</span> (param != <span class="keyword">null</span> &amp;&amp; param.trim().length() != <span class="number">0</span>) &#123;</div><div class="line">                param = param.trim();</div><div class="line">                <span class="keyword">boolean</span> resetEnable = Boolean.parseBoolean(param);</div><div class="line">                statService.setResetEnable(resetEnable);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            String msg = <span class="string">"initParameter config error, resetEnable : "</span> + getInitParameter(PARAM_NAME_RESET_ENABLE);</div><div class="line">            LOG.error(msg, e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 获取jmx的连接配置信息</span></div><div class="line">        String param = readInitParam(PARAM_NAME_JMX_URL);</div><div class="line">        <span class="keyword">if</span> (param != <span class="keyword">null</span>) &#123;</div><div class="line">            jmxUrl = param;</div><div class="line">            jmxUsername = readInitParam(PARAM_NAME_JMX_USERNAME);</div><div class="line">            jmxPassword = readInitParam(PARAM_NAME_JMX_PASSWORD);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                initJmxConn();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                LOG.error(<span class="string">"init jmx connection error"</span>, e);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 读取servlet中的配置参数.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> key 配置参数名</div><div class="line">     * <span class="doctag">@return</span> 配置参数值，如果不存在当前配置参数，或者为配置参数长度为0，将返回null</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">readInitParam</span><span class="params">(String key)</span> </span>&#123;</div><div class="line">        String value = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            String param = getInitParameter(key);</div><div class="line">            <span class="keyword">if</span> (param != <span class="keyword">null</span>) &#123;</div><div class="line">                param = param.trim();</div><div class="line">                <span class="keyword">if</span> (param.length() &gt; <span class="number">0</span>) &#123;</div><div class="line">                    value = param;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            String msg = <span class="string">"initParameter config ["</span> + key + <span class="string">"] error"</span>;</div><div class="line">            LOG.warn(msg, e);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 初始化jmx连接</div><div class="line">     * </div><div class="line">     * <span class="doctag">@throws</span> IOException</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initJmxConn</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (jmxUrl != <span class="keyword">null</span>) &#123;</div><div class="line">            JMXServiceURL url = <span class="keyword">new</span> JMXServiceURL(jmxUrl);</div><div class="line">            Map&lt;String, String[]&gt; env = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">if</span> (jmxUsername != <span class="keyword">null</span>) &#123;</div><div class="line">                env = <span class="keyword">new</span> HashMap&lt;String, String[]&gt;();</div><div class="line">                String[] credentials = <span class="keyword">new</span> String[] &#123; jmxUsername, jmxPassword &#125;;</div><div class="line">                env.put(JMXConnector.CREDENTIALS, credentials);</div><div class="line">            &#125;</div><div class="line">            JMXConnector jmxc = JMXConnectorFactory.connect(url, env);</div><div class="line">            conn = jmxc.getMBeanServerConnection();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 根据指定的url来获取jmx服务返回的内容.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> connetion jmx连接</div><div class="line">     * <span class="doctag">@param</span> url url内容</div><div class="line">     * <span class="doctag">@return</span> the jmx返回的内容</div><div class="line">     * <span class="doctag">@throws</span> Exception the exception</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getJmxResult</span><span class="params">(MBeanServerConnection connetion, String url)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ObjectName name = <span class="keyword">new</span> ObjectName(DruidStatService.MBEAN_NAME);</div><div class="line"></div><div class="line">        String result = (String) conn.invoke(name, <span class="string">"service"</span>, <span class="keyword">new</span> String[] &#123; url &#125;,</div><div class="line">                                             <span class="keyword">new</span> String[] &#123; String.class.getName() &#125;);</div><div class="line">        <span class="keyword">return</span> result;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 程序首先判断是否存在jmx连接地址，如果不存在，则直接调用本地的duird服务； 如果存在，则调用远程jmx服务。在进行jmx通信，首先判断一下jmx连接是否已经建立成功，如果已经</div><div class="line">     * 建立成功，则直接进行通信，如果之前没有成功建立，则会尝试重新建立一遍。.</div><div class="line">     * </div><div class="line">     * <span class="doctag">@param</span> url 要连接的服务地址</div><div class="line">     * <span class="doctag">@return</span> 调用服务后返回的json字符串</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">process</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">        String resp = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (jmxUrl == <span class="keyword">null</span>) &#123;</div><div class="line">            resp = statService.service(url);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;<span class="comment">// 连接在初始化时创建失败</span></div><div class="line">                <span class="keyword">try</span> &#123;<span class="comment">// 尝试重新连接</span></div><div class="line">                    initJmxConn();</div><div class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                    LOG.error(<span class="string">"init jmx connection error"</span>, e);</div><div class="line">                    resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR,</div><div class="line">                                                             <span class="string">"init jmx connection error"</span> + e.getMessage());</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;<span class="comment">// 连接成功</span></div><div class="line">                    <span class="keyword">try</span> &#123;</div><div class="line">                        resp = getJmxResult(conn, url);</div><div class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                        LOG.error(<span class="string">"get jmx data error"</span>, e);</div><div class="line">                        resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR, <span class="string">"get data error:"</span></div><div class="line">                                                                                                     + e.getMessage());</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">// 连接成功</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    resp = getJmxResult(conn, url);</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    LOG.error(<span class="string">"get jmx data error"</span>, e);</div><div class="line">                    resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR,</div><div class="line">                                                             <span class="string">"get data error"</span> + e.getMessage());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> resp;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>首先，现在需要搞清楚的问题有：</p>
<ol>
<li>配置信息是如何生效的</li>
<li>监控数据是怎么流动的</li>
<li>权限控制是怎样实现的</li>
<li>为什么重连会失败</li>
</ol>
<p>逐个方法去看，<code>init</code>方法是初始化的，应该能找到『配置信息是如何生效的』的答案。里面调用了<code>readInitparam</code>方法来读取，而这个方法又调用了<code>getInitParameter</code>方法，进入方法后发现此方法是<code>javax.servlet.GenericServlet</code>里的，已经不是druid的代码，意味着读取参数是通过调用容器的api实现的，这个过程无法进行篡改。</p>
<p>这里只是读取参数值，还没使用，让我们一步步回退回<code>init</code>方法，在读取了参数值之后就调用<code>initJmxConn</code>方法，该方法初始化了与监控目标之间的JMX连接，是关键的地方。但是里面也没多少东西，主要就是根据url去获取连接，对于『为什么重连会失败』，应该也是一个切入点。但是一路点进去看都没发现有重试的机制。</p>
<p>接着往下看，剩下<code>getJmxResult</code>和<code>process</code>两个方法，其注释里已经讲得很明白了。可以发现，在<code>process</code>方法里有重连的机制，那么还是没搞清楚为什么无法重连成功。</p>
<p>在看完这个类之后，可以发现请求的调用链并没有体现出来，所以看它的父类<code>ResourceServlet</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div><div class="line">224</div><div class="line">225</div><div class="line">226</div><div class="line">227</div><div class="line">228</div><div class="line">229</div><div class="line">230</div><div class="line">231</div><div class="line">232</div><div class="line">233</div><div class="line">234</div><div class="line">235</div><div class="line">236</div><div class="line">237</div><div class="line">238</div><div class="line">239</div><div class="line">240</div><div class="line">241</div><div class="line">242</div><div class="line">243</div><div class="line">244</div><div class="line">245</div><div class="line">246</div><div class="line">247</div><div class="line">248</div><div class="line">249</div><div class="line">250</div><div class="line">251</div><div class="line">252</div><div class="line">253</div><div class="line">254</div><div class="line">255</div><div class="line">256</div><div class="line">257</div><div class="line">258</div><div class="line">259</div><div class="line">260</div><div class="line">261</div><div class="line">262</div><div class="line">263</div><div class="line">264</div><div class="line">265</div><div class="line">266</div><div class="line">267</div><div class="line">268</div><div class="line">269</div><div class="line">270</div><div class="line">271</div><div class="line">272</div><div class="line">273</div><div class="line">274</div><div class="line">275</div><div class="line">276</div><div class="line">277</div><div class="line">278</div><div class="line">279</div><div class="line">280</div><div class="line">281</div><div class="line">282</div><div class="line">283</div><div class="line">284</div><div class="line">285</div><div class="line">286</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"> * Copyright 1999-2011 Alibaba Group Holding Ltd.</div><div class="line"> *</div><div class="line"> * Licensed under the Apache License, Version 2.0 (the "License");</div><div class="line"> * you may not use this file except in compliance with the License.</div><div class="line"> * You may obtain a copy of the License at</div><div class="line"> *</div><div class="line"> *      http://www.apache.org/licenses/LICENSE-2.0</div><div class="line"> *</div><div class="line"> * Unless required by applicable law or agreed to in writing, software</div><div class="line"> * distributed under the License is distributed on an "AS IS" BASIS,</div><div class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</div><div class="line"> * See the License for the specific language governing permissions and</div><div class="line"> * limitations under the License.</div><div class="line"> */</div><div class="line"><span class="keyword">package</span> com.alibaba.druid.support.http;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.util.IPAddress;</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.util.IPRange;</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.support.logging.Log;</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.support.logging.LogFactory;</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.util.StringUtils;</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.util.Utils;</div><div class="line"></div><div class="line"><span class="keyword">import</span> javax.servlet.ServletException;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</div><div class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Log   LOG                 = LogFactory.getLog(ResourceServlet.class);</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SESSION_USER_KEY    = <span class="string">"druid-user"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAM_NAME_USERNAME = <span class="string">"loginUsername"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAM_NAME_PASSWORD = <span class="string">"loginPassword"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAM_NAME_ALLOW    = <span class="string">"allow"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAM_NAME_DENY     = <span class="string">"deny"</span>;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PARAM_REMOTE_ADDR   = <span class="string">"remoteAddress"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> String           username            = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">protected</span> String           password            = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> List&lt;IPRange&gt;    allowList           = <span class="keyword">new</span> ArrayList&lt;IPRange&gt;();</div><div class="line">    <span class="keyword">protected</span> List&lt;IPRange&gt;    denyList            = <span class="keyword">new</span> ArrayList&lt;IPRange&gt;();</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String     resourcePath;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> String           remoteAddressHeader = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResourceServlet</span><span class="params">(String resourcePath)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.resourcePath = resourcePath;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> <span class="keyword">throws</span> ServletException </span>&#123;</div><div class="line">        initAuthEnv();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initAuthEnv</span><span class="params">()</span> </span>&#123;</div><div class="line">        String paramUserName = getInitParameter(PARAM_NAME_USERNAME);</div><div class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(paramUserName)) &#123;</div><div class="line">            <span class="keyword">this</span>.username = paramUserName;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String paramPassword = getInitParameter(PARAM_NAME_PASSWORD);</div><div class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(paramPassword)) &#123;</div><div class="line">            <span class="keyword">this</span>.password = paramPassword;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String paramRemoteAddressHeader = getInitParameter(PARAM_REMOTE_ADDR);</div><div class="line">        <span class="keyword">if</span> (!StringUtils.isEmpty(paramRemoteAddressHeader)) &#123;</div><div class="line">            <span class="keyword">this</span>.remoteAddressHeader = paramRemoteAddressHeader;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            String param = getInitParameter(PARAM_NAME_ALLOW);</div><div class="line">            <span class="keyword">if</span> (param != <span class="keyword">null</span> &amp;&amp; param.trim().length() != <span class="number">0</span>) &#123;</div><div class="line">                param = param.trim();</div><div class="line">                String[] items = param.split(<span class="string">","</span>);</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (String item : items) &#123;</div><div class="line">                    <span class="keyword">if</span> (item == <span class="keyword">null</span> || item.length() == <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    IPRange ipRange = <span class="keyword">new</span> IPRange(item);</div><div class="line">                    allowList.add(ipRange);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            String msg = <span class="string">"initParameter config error, allow : "</span> + getInitParameter(PARAM_NAME_ALLOW);</div><div class="line">            LOG.error(msg, e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            String param = getInitParameter(PARAM_NAME_DENY);</div><div class="line">            <span class="keyword">if</span> (param != <span class="keyword">null</span> &amp;&amp; param.trim().length() != <span class="number">0</span>) &#123;</div><div class="line">                param = param.trim();</div><div class="line">                String[] items = param.split(<span class="string">","</span>);</div><div class="line"></div><div class="line">                <span class="keyword">for</span> (String item : items) &#123;</div><div class="line">                    <span class="keyword">if</span> (item == <span class="keyword">null</span> || item.length() == <span class="number">0</span>) &#123;</div><div class="line">                        <span class="keyword">continue</span>;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    IPRange ipRange = <span class="keyword">new</span> IPRange(item);</div><div class="line">                    denyList.add(ipRange);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            String msg = <span class="string">"initParameter config error, deny : "</span> + getInitParameter(PARAM_NAME_DENY);</div><div class="line">            LOG.error(msg, e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPermittedRequest</span><span class="params">(String remoteAddress)</span> </span>&#123;</div><div class="line">        <span class="keyword">boolean</span> ipV6 = remoteAddress != <span class="keyword">null</span> &amp;&amp; remoteAddress.indexOf(<span class="string">':'</span>) != -<span class="number">1</span>;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (ipV6) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="string">"0:0:0:0:0:0:0:1"</span>.equals(remoteAddress) || (denyList.size() == <span class="number">0</span> &amp;&amp; allowList.size() == <span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        IPAddress ipAddress = <span class="keyword">new</span> IPAddress(remoteAddress);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (IPRange range : denyList) &#123;</div><div class="line">            <span class="keyword">if</span> (range.isIPAddressInRange(ipAddress)) &#123;</div><div class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (allowList.size() &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (IPRange range : allowList) &#123;</div><div class="line">                <span class="keyword">if</span> (range.isIPAddressInRange(ipAddress)) &#123;</div><div class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getFilePath</span><span class="params">(String fileName)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> resourcePath + fileName;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">returnResourceFile</span><span class="params">(String fileName, String uri, HttpServletResponse response)</span></span></div><div class="line">                                                                                                <span class="keyword">throws</span> ServletException,</div><div class="line">                                                                                                IOException &#123;</div><div class="line"></div><div class="line">        String filePath = getFilePath(fileName);</div><div class="line">        <span class="keyword">if</span> (fileName.endsWith(<span class="string">".jpg"</span>)) &#123;</div><div class="line">            <span class="keyword">byte</span>[] bytes = Utils.readByteArrayFromResource(filePath);</div><div class="line">            <span class="keyword">if</span> (bytes != <span class="keyword">null</span>) &#123;</div><div class="line">                response.getOutputStream().write(bytes);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        String text = Utils.readFromResource(filePath);</div><div class="line">        <span class="keyword">if</span> (text == <span class="keyword">null</span>) &#123;</div><div class="line">            response.sendRedirect(uri + <span class="string">"/index.html"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (fileName.endsWith(<span class="string">".css"</span>)) &#123;</div><div class="line">            response.setContentType(<span class="string">"text/css;charset=utf-8"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fileName.endsWith(<span class="string">".js"</span>)) &#123;</div><div class="line">            response.setContentType(<span class="string">"text/javascript;charset=utf-8"</span>);</div><div class="line">        &#125;</div><div class="line">        response.getWriter().write(text);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line">        String contextPath = request.getContextPath();</div><div class="line">        String servletPath = request.getServletPath();</div><div class="line">        String requestURI = request.getRequestURI();</div><div class="line"></div><div class="line">        response.setCharacterEncoding(<span class="string">"utf-8"</span>);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (contextPath == <span class="keyword">null</span>) &#123; <span class="comment">// root context</span></div><div class="line">            contextPath = <span class="string">""</span>;</div><div class="line">        &#125;</div><div class="line">        String uri = contextPath + servletPath;</div><div class="line">        String path = requestURI.substring(contextPath.length() + servletPath.length());</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (!isPermittedRequest(request)) &#123;</div><div class="line">            path = <span class="string">"/nopermit.html"</span>;</div><div class="line">            returnResourceFile(path, uri, response);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="string">"/submitLogin"</span>.equals(path)) &#123;</div><div class="line">            String usernameParam = request.getParameter(PARAM_NAME_USERNAME);</div><div class="line">            String passwordParam = request.getParameter(PARAM_NAME_PASSWORD);</div><div class="line">            <span class="keyword">if</span> (username.equals(usernameParam) &amp;&amp; password.equals(passwordParam)) &#123;</div><div class="line">                request.getSession().setAttribute(SESSION_USER_KEY, username);</div><div class="line">                response.getWriter().print(<span class="string">"success"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                response.getWriter().print(<span class="string">"error"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (isRequireAuth() <span class="comment">//</span></div><div class="line">            &amp;&amp; !ContainsUser(request)<span class="comment">//</span></div><div class="line">            &amp;&amp; !(<span class="string">"/login.html"</span>.equals(path) <span class="comment">//</span></div><div class="line">                 || path.startsWith(<span class="string">"/css"</span>)<span class="comment">//</span></div><div class="line">                 || path.startsWith(<span class="string">"/js"</span>) <span class="comment">//</span></div><div class="line">            || path.startsWith(<span class="string">"/img"</span>))) &#123;</div><div class="line">            <span class="keyword">if</span> (contextPath.equals(<span class="string">""</span>) || contextPath.equals(<span class="string">"/"</span>)) &#123;</div><div class="line">                response.sendRedirect(<span class="string">"/druid/login.html"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="string">""</span>.equals(path)) &#123;</div><div class="line">                    response.sendRedirect(<span class="string">"druid/login.html"</span>);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    response.sendRedirect(<span class="string">"login.html"</span>);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="string">""</span>.equals(path)) &#123;</div><div class="line">            <span class="keyword">if</span> (contextPath.equals(<span class="string">""</span>) || contextPath.equals(<span class="string">"/"</span>)) &#123;</div><div class="line">                response.sendRedirect(<span class="string">"/druid/index.html"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                response.sendRedirect(<span class="string">"druid/index.html"</span>);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="string">"/"</span>.equals(path)) &#123;</div><div class="line">            response.sendRedirect(<span class="string">"index.html"</span>);</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (path.contains(<span class="string">".json"</span>)) &#123;</div><div class="line">            String fullUrl = path;</div><div class="line">            <span class="keyword">if</span> (request.getQueryString() != <span class="keyword">null</span> &amp;&amp; request.getQueryString().length() &gt; <span class="number">0</span>) &#123;</div><div class="line">                fullUrl += <span class="string">"?"</span> + request.getQueryString();</div><div class="line">            &#125;</div><div class="line">            response.getWriter().print(process(fullUrl));</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// find file in resources path</span></div><div class="line">        returnResourceFile(path, uri, response);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ContainsUser</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line">        HttpSession session = request.getSession(<span class="keyword">false</span>);</div><div class="line">        <span class="keyword">return</span> session != <span class="keyword">null</span> &amp;&amp; session.getAttribute(SESSION_USER_KEY) != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isRequireAuth</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.username != <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPermittedRequest</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line">        String remoteAddress = getRemoteAddress(request);</div><div class="line">        <span class="keyword">return</span> isPermittedRequest(remoteAddress);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">getRemoteAddress</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</div><div class="line">        String remoteAddress = <span class="keyword">null</span>;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (remoteAddressHeader != <span class="keyword">null</span>) &#123;</div><div class="line">            remoteAddress = request.getHeader(remoteAddressHeader);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (remoteAddress == <span class="keyword">null</span>) &#123;</div><div class="line">            remoteAddress = request.getRemoteAddr();</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> remoteAddress;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">process</span><span class="params">(String url)</span></span>;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>其中，<code>service</code>方法里有URL的判断，方法里有request和response，看上去就是流程的起点，但是一般我们写servlet都是从<code>doGet</code>和<code>doPost</code>入手的，这里面不知道做了什么封装，于是继续往父类去看，发现其父类是<code>javax.servlet.http.HttpServlet</code>，已经是J2EE定义的类了，我用的是tomcat容器，所以这个类由tomcat提供。里面有常见的<code>doPost</code>和<code>doGet</code>方法</p>
<p>可以看到，<code>doGet</code>和<code>doPost</code>方法默认都是不通的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">        <span class="keyword">throws</span> ServletException, IOException</div><div class="line">&#123;</div><div class="line">    String protocol = req.getProtocol();</div><div class="line">    String msg = lStrings.getString(<span class="string">"http.method_get_not_supported"</span>);</div><div class="line">    <span class="keyword">if</span> (protocol.endsWith(<span class="string">"1.1"</span>)) &#123;</div><div class="line">        resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line"></div><div class="line">    String protocol = req.getProtocol();</div><div class="line">    String msg = lStrings.getString(<span class="string">"http.method_post_not_supported"</span>);</div><div class="line">    <span class="keyword">if</span> (protocol.endsWith(<span class="string">"1.1"</span>)) &#123;</div><div class="line">        resp.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, msg);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        resp.sendError(HttpServletResponse.SC_BAD_REQUEST, msg);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>赶紧去看注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Called by the server (via the &lt;code&gt;service&lt;/code&gt; method) to</div><div class="line"> * allow a servlet to handle a GET request.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;Overriding this method to support a GET request also</div><div class="line"> * automatically supports an HTTP HEAD request. A HEAD</div><div class="line"> * request is a GET request that returns no body in the</div><div class="line"> * response, only the request header fields.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;When overriding this method, read the request data,</div><div class="line"> * write the response headers, get the response's writer or...</div><div class="line"> * /</div><div class="line">protected void doGet(HttpServletRequest req, HttpServletResponse resp)</div><div class="line">        throws ServletException, IOException</div><div class="line">&#123;</div><div class="line">    //...</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">/**</div><div class="line"> * Called by the server (via the &lt;code&gt;service&lt;/code&gt; method)</div><div class="line"> * to allow a servlet to handle a POST request.</div><div class="line"> * </div><div class="line"> * ...</div><div class="line"> * </div><div class="line"> * &lt;p&gt;When overriding this method, read the request data,</div><div class="line"> * write the response headers...</div><div class="line"> * </div><div class="line"> */</div><div class="line"> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">        <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">	<span class="comment">//...</span></div><div class="line">&#125;</div><div class="line">     </div></pre></td></tr></table></figure>     
<p>原来这些方法是由<code>service</code>方法调用的，并且需要自己覆盖，很符合我们一贯的经验。再看看<code>service</code>方法是怎么回事：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Receives standard HTTP requests from the public</div><div class="line"> * &lt;code&gt;service&lt;/code&gt; method and dispatches</div><div class="line"> * them to the &lt;code&gt;do&lt;/code&gt;&lt;i&gt;Method&lt;/i&gt; methods defined in</div><div class="line"> * this class. This method is an HTTP-specific version of the</div><div class="line"> * &#123;<span class="doctag">@link</span> javax.servlet.Servlet#service&#125; method. There's no</div><div class="line"> * need to override this method.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> req   the &#123;<span class="doctag">@link</span> HttpServletRequest&#125; object that</div><div class="line"> *                  contains the request the client made of</div><div class="line"> *                  the servlet</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> resp  the &#123;<span class="doctag">@link</span> HttpServletResponse&#125; object that</div><div class="line"> *                  contains the response the servlet returns</div><div class="line"> *                  to the client</div><div class="line"> *</div><div class="line"> * <span class="doctag">@exception</span> IOException   if an input or output error occurs</div><div class="line"> *                              while the servlet is handling the</div><div class="line"> *                              HTTP request</div><div class="line"> *</div><div class="line"> * <span class="doctag">@exception</span> ServletException  if the HTTP request</div><div class="line"> *                                  cannot be handled</div><div class="line"> *</div><div class="line"> * <span class="doctag">@see</span> javax.servlet.Servlet#service</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></div><div class="line">    <span class="keyword">throws</span> ServletException, IOException &#123;</div><div class="line">	<span class="comment">//...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"></div></pre></td></tr></table></figure>
<p>这个方法是请求的统一接收入口，然后将请求分发到<code>doGet</code>、<code>doPost</code>、<code>doHead</code>等对应标准HTTP请求方法的方法去。注释里特地说明了没有必要覆盖这个方法，druid的开发者很直接粗暴，不管你请求方法是什么，全部一刀切，反正这玩意儿要求不高。总之，现在我们知道了，<code>service</code>方法就是请求的入口，这样我们再回去看看<code>com.alibaba.druid.support.http.ResourceServlet</code>的<code>service</code>方法，通过这个方法应该就能理顺整个流程。</p>
<p>将其方法代码加上我自己的注释贴出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 整个方法其实做的还是路由分发的工作，根据请求的地址，分别返回不同的资源，并且进行访问控制。</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line">    String contextPath = request.getContextPath();</div><div class="line">    String servletPath = request.getServletPath();</div><div class="line">    String requestURI = request.getRequestURI();</div><div class="line"></div><div class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (contextPath == <span class="keyword">null</span>) &#123; <span class="comment">// root context</span></div><div class="line">        contextPath = <span class="string">""</span>;</div><div class="line">    &#125;</div><div class="line">    String uri = contextPath + servletPath;</div><div class="line">    String path = requestURI.substring(contextPath.length() + servletPath.length());</div><div class="line"></div><div class="line">    <span class="comment">// 禁止访问的时候返回nopermit.html，returnResourceFile这个方法很关键，下文说说</span></div><div class="line">    <span class="keyword">if</span> (!isPermittedRequest(request)) &#123;</div><div class="line">        path = <span class="string">"/nopermit.html"</span>;</div><div class="line">        returnResourceFile(path, uri, response);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* 从名字看来，这是接收登录请求的</span></div><div class="line">     * 很明显，校验就是匹配username和password是否都与配置的匹配，如果匹配就在session里塞点标识</div><div class="line">     * 很原始的做法，但是对于一个内部使用的线程池监控来说也不用做得太复杂</div><div class="line">     */</div><div class="line">    <span class="keyword">if</span> (<span class="string">"/submitLogin"</span>.equals(path)) &#123;</div><div class="line">        String usernameParam = request.getParameter(PARAM_NAME_USERNAME);</div><div class="line">        String passwordParam = request.getParameter(PARAM_NAME_PASSWORD);</div><div class="line">        <span class="keyword">if</span> (username.equals(usernameParam) &amp;&amp; password.equals(passwordParam)) &#123;</div><div class="line">            request.getSession().setAttribute(SESSION_USER_KEY, username);</div><div class="line">            response.getWriter().print(<span class="string">"success"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            response.getWriter().print(<span class="string">"error"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* 拦截登录 */</span></div><div class="line">    <span class="keyword">if</span> (isRequireAuth() <span class="comment">//</span></div><div class="line">        &amp;&amp; !ContainsUser(request)<span class="comment">//</span></div><div class="line">        &amp;&amp; !(<span class="string">"/login.html"</span>.equals(path) <span class="comment">//</span></div><div class="line">             || path.startsWith(<span class="string">"/css"</span>)<span class="comment">//</span></div><div class="line">             || path.startsWith(<span class="string">"/js"</span>) <span class="comment">//</span></div><div class="line">        || path.startsWith(<span class="string">"/img"</span>))) &#123;</div><div class="line">        <span class="keyword">if</span> (contextPath.equals(<span class="string">""</span>) || contextPath.equals(<span class="string">"/"</span>)) &#123;</div><div class="line">            response.sendRedirect(<span class="string">"/druid/login.html"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="string">""</span>.equals(path)) &#123;</div><div class="line">                response.sendRedirect(<span class="string">"druid/login.html"</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                response.sendRedirect(<span class="string">"login.html"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">	 <span class="comment">// 缺省首页的跳转</span></div><div class="line">    <span class="keyword">if</span> (<span class="string">""</span>.equals(path)) &#123;</div><div class="line">        <span class="keyword">if</span> (contextPath.equals(<span class="string">""</span>) || contextPath.equals(<span class="string">"/"</span>)) &#123;</div><div class="line">            response.sendRedirect(<span class="string">"/druid/index.html"</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            response.sendRedirect(<span class="string">"druid/index.html"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="string">"/"</span>.equals(path)) &#123;</div><div class="line">        response.sendRedirect(<span class="string">"index.html"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 在不改造的时候，正常监控一个druid实例，会发现页面的数据都是异步刷新的，</div><div class="line">     * 通过浏览器的开发者工具能发现取数据的请求都是json后缀的，所以这里就是监控数据流动的节点</div><div class="line">     * process方法是关键，而这个方法是一个抽象方法，由具体的实现类来实现，下文将回到&#123;@link com.alibaba.druid.support.http.StatViewServlet#process(String)&#125;方法里看</div><div class="line">     * /</div><div class="line">    if (path.contains(".json")) &#123;</div><div class="line">        String fullUrl = path;</div><div class="line">        if (request.getQueryString() != null &amp;&amp; request.getQueryString().length() &gt; 0) &#123;</div><div class="line">            fullUrl += "?" + request.getQueryString();</div><div class="line">        &#125;</div><div class="line">        response.getWriter().print(process(fullUrl));</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // 在以上情况都不匹配的时候，返回资源文件</div><div class="line">    // find file in resources path</div><div class="line">    returnResourceFile(path, uri, response);</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>有两个方法需要看：</p>
<ol>
<li>returnResourceFile</li>
<li>process</li>
</ol>
<p><code>returnResourceFile</code>方法在<code>ResourceServlet</code>里面实现了（注释是我加的）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">returnResourceFile</span><span class="params">(String fileName, String uri, HttpServletResponse response)</span>                                                                       <span class="keyword">throws</span> ServletException, IOException </span>&#123;</div><div class="line"></div><div class="line">    String filePath = getFilePath(fileName);</div><div class="line">    <span class="comment">// 如果是jpg，则返回流</span></div><div class="line">    <span class="keyword">if</span> (fileName.endsWith(<span class="string">".jpg"</span>)) &#123;</div><div class="line">        <span class="keyword">byte</span>[] bytes = Utils.readByteArrayFromResource(filePath);</div><div class="line">        <span class="keyword">if</span> (bytes != <span class="keyword">null</span>) &#123;</div><div class="line">            response.getOutputStream().write(bytes);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/* </span></div><div class="line">     * 否则读取文件，返回文件内的文本</div><div class="line">     * 其中，Utils.readFromResource有这么关键的一行</div><div class="line">     * Thread.currentThread().getContextClassLoader().getResourceAsStream(resource);</div><div class="line">     * 这和servlet初始化的时候是有关的</div><div class="line">     * ResourceServlet本身也是一个抽象类，其子类StatViewServlet初始化的时候指定了资源目录的路径：</div><div class="line">     * public StatViewServlet()&#123;</div><div class="line">     *     super("support/http/resources");</div><div class="line">     * &#125;</div><div class="line">     */</div><div class="line">    String text = Utils.readFromResource(filePath);</div><div class="line">    <span class="keyword">if</span> (text == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="comment">// 如果请求的路径映射不到资源文件，则调到默认首页（其实就是将404指向了index.html）</span></div><div class="line">        response.sendRedirect(uri + <span class="string">"/index.html"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 如果是css或者是js文件，则还需要设置相应的响应头部</span></div><div class="line">    <span class="keyword">if</span> (fileName.endsWith(<span class="string">".css"</span>)) &#123;</div><div class="line">        response.setContentType(<span class="string">"text/css;charset=utf-8"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fileName.endsWith(<span class="string">".js"</span>)) &#123;</div><div class="line">        response.setContentType(<span class="string">"text/javascript;charset=utf-8"</span>);</div><div class="line">    &#125;</div><div class="line">    response.getWriter().write(text);</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>接着看process方法（注释是原有的）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 程序首先判断是否存在jmx连接地址，如果不存在，则直接调用本地的duird服务； 如果存在，则调用远程jmx服务。在进行jmx通信，首先判断一下jmx连接是否已经建立成功，如果已经</div><div class="line"> * 建立成功，则直接进行通信，如果之前没有成功建立，则会尝试重新建立一遍。.</div><div class="line"> * </div><div class="line"> * <span class="doctag">@param</span> url 要连接的服务地址</div><div class="line"> * <span class="doctag">@return</span> 调用服务后返回的json字符串</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">process</span><span class="params">(String url)</span> </span>&#123;</div><div class="line">    String resp = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">if</span> (jmxUrl == <span class="keyword">null</span>) &#123;</div><div class="line">        resp = statService.service(url);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;<span class="comment">// 连接在初始化时创建失败</span></div><div class="line">            <span class="keyword">try</span> &#123;<span class="comment">// 尝试重新连接</span></div><div class="line">                initJmxConn();</div><div class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</div><div class="line">                LOG.error(<span class="string">"init jmx connection error"</span>, e);</div><div class="line">                resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR,</div><div class="line">                                                         <span class="string">"init jmx connection error"</span> + e.getMessage());</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;<span class="comment">// 连接成功</span></div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    resp = getJmxResult(conn, url);</div><div class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                    LOG.error(<span class="string">"get jmx data error"</span>, e);</div><div class="line">                    resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR, <span class="string">"get data error:"</span></div><div class="line">                                                                                                 + e.getMessage());</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">// 连接成功</span></div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                resp = getJmxResult(conn, url);</div><div class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">                LOG.error(<span class="string">"get jmx data error"</span>, e);</div><div class="line">                resp = DruidStatService.returnJSONResult(DruidStatService.RESULT_CODE_ERROR,</div><div class="line">                                                         <span class="string">"get data error"</span> + e.getMessage());</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> resp;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>可见它是有重连的，而保证了连接成功之后，获取数据的方法是<code>getJmxResult</code>，这个是在<code>StatViewServlet</code>里面实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getJmxResult</span><span class="params">(MBeanServerConnection connetion, String url)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">    ObjectName name = <span class="keyword">new</span> ObjectName(DruidStatService.MBEAN_NAME);</div><div class="line"></div><div class="line">    String result = (String) conn.invoke(name, <span class="string">"service"</span>, <span class="keyword">new</span> String[] &#123; url &#125;,</div><div class="line">                                         <span class="keyword">new</span> String[] &#123; String.class.getName() &#125;);</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以实际上就是用MBeanServer的连接去直接取数据然后原样返回，所有的监控数据其实是缓存在被监控的目标处的，web的监控只是一个请求转发与展示的作用。</p>
<p>所以现在总结StatViewServlet整个工作的主要过程：</p>
<ol>
<li>记录用户名和密码</li>
<li>根据配置的jmxUrl初始化jmx连接</li>
<li>接收请求，分发请求</li>
<li>如果请求是json数据请求，则通过jmx连接到被监控对象处取数据，然后返回</li>
</ol>
<h1 id="3-改进思路"><a href="#3-改进思路" class="headerlink" title="3. 改进思路"></a>3. 改进思路</h1><h2 id="3-1-思路一：动态创建并注册StatViewServlet"><a href="#3-1-思路一：动态创建并注册StatViewServlet" class="headerlink" title="3.1 思路一：动态创建并注册StatViewServlet"></a>3.1 思路一：动态创建并注册StatViewServlet</h2><p>这是首先想到的思路，因为使用这种办法不需要对druid的web监控细节了解多少。要实现这个目标，需要做到以下两点之一：</p>
<ol>
<li>对于Java Web容器的启动过程很了解，并且深入细节</li>
<li>Google能找到相似的例子</li>
</ol>
<p>第一点我还做不到，短时间内也做不到，所以只能往第二点去努力。找到了一个最贴切的办法是：<br><a href="http://javaevangelist.blogspot.co.id/2012/11/dynamic-servlet-registration-example.html" target="_blank" rel="external">Dynamic Servlet Registration Example</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletContext;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletContextEvent;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletContextListener;</div><div class="line"><span class="keyword">import</span> javax.servlet.ServletRegistration;</div><div class="line"><span class="keyword">import</span> javax.servlet.annotation.WebListener;</div><div class="line"></div><div class="line"><span class="meta">@WebListener</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletContextListenerImpl</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(<span class="keyword">final</span> ServletContextEvent sce)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> ServletContext servletContext = sce.getServletContext();</div><div class="line">        <span class="keyword">final</span> ServletRegistration.Dynamic dynamic = servletContext.addServlet(<span class="string">"Example Servlet"</span>, ExampleServlet.class);</div><div class="line">        dynamic.addMapping(<span class="string">"/"</span>);</div><div class="line"> </div><div class="line">        <span class="keyword">final</span> Map&lt;String, ? extends ServletRegistration&gt; map = servletContext.getServletRegistrations();</div><div class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</div><div class="line">            servletContext.log(<span class="string">"Registered Servlet: "</span> + map.get(key).getName());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(<span class="keyword">final</span> ServletContextEvent sce)</span> </span>&#123;</div><div class="line">        <span class="comment">//NO-OP</span></div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div></pre></td></tr></table></figure>
<p>主要就是实现<code>javax.servlet.ServletContextListener</code>，通过<code>javax.servlet.ServletContextEvent</code>实例获取<code>javax.servlet.ServletContext</code>实例，然后调用它的方法去注册新的servlet。</p>
<p>看上去好像可行的样子，但是在实际运行起来之后，在这一行报错了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> ServletRegistration.Dynamic dynamic = servletContext.addServlet(<span class="string">"Example Servlet"</span>, ExampleServlet.class);</div></pre></td></tr></table></figure>
<p>错误信息没有记录下来，但是意思就是说这个操作是不支持的，反正就是没戏。具体为什么，还需要进一步了解。</p>
<h2 id="3-2-思路二：修改StatViewServlet的机制"><a href="#3-2-思路二：修改StatViewServlet的机制" class="headerlink" title="3.2 思路二：修改StatViewServlet的机制"></a>3.2 思路二：修改StatViewServlet的机制</h2><p>在第一个思路走不通之后，只能从其工作机制上入手。其原理分析已经在上文给出。</p>
<p>因为只要有JMX的连接就可以获取数据了，所以关键在于以下几点：</p>
<ol>
<li>持有多个jmx连接并且与不同的请求关联起来</li>
<li>根据配置去动态创建连接</li>
<li>将原本固定的几个页面与配置的多个监控对象动态地对应起来</li>
<li>配置能根据部署环境的不同而改变，并且发生变更的时候能轻易修改</li>
<li>列出所有被监控对象</li>
</ol>
<p>对于第一点，创建jmx连接只要有jmxUrl就够了，所以很容易做到，至于与请求关联起来，其实就是从请求的url里提取特征，用于表示不同的监控对象，然后将此特征映射到对应的jmx连接即可。</p>
<p>对于第二点，这其实就是普通的读取、解析配置，然后用配置信息去初始化jmx连接（当然还有登录名、密码和黑白名单等）。</p>
<p>第三点，转下弯，原有的逻辑是将url直接映射为资源文件，只要在这中间加一层解析即可。</p>
<p>第四点，简单的方案是配置多个配置文件，根据不同的环境打不同的包。但是这种做法不灵活，最好还是做成注册中心的形式，被监控对象启动的时候网注册中心写入信息，这边从注册中心读，还有下线机制。但是这种做法工作量大，而且要改被监控的一方，容易引入bug。要不就与配置中心集成，这样就只需改动web监控一端即可。这里的配置方案有多种，很适合采用SPI。</p>
<p>第五点，根据配置信息做个汇总，然后给个页面列出来就可以。</p>
<h1 id="4-实现"><a href="#4-实现" class="headerlink" title="4 实现"></a>4 实现</h1><p>上文提及的问题在这里基本上都解决了，思路都讲清楚了，实现就不再重复讲。请移步我github的仓库：<a href="https://github.com/bungder/druid-aggregated-monitor" target="_blank" rel="external">https://github.com/bungder/druid-aggregated-monitor</a></p>
<p>在这里提提失败重连的问题</p>
<h2 id="4-1重连失败的问题"><a href="#4-1重连失败的问题" class="headerlink" title="4.1重连失败的问题"></a>4.1重连失败的问题</h2><p>其重连失败的问题，在debug的时候发现其实并没有重连，它重连的条件是conn为null，但是实际上conn初始化之后就不会为null了，但是当连接失效之后，里面的<code>terminated</code>属性为<code>true</code>，而<code>MBeanServerConnection</code>是一个<code>interface</code>，本身没定义操作这个属性的方法，并且至少有两个类实现了这个接口，运行时的实际类型并不确定是否总是某个实现类型，所以也不好去强转类型进行操作。但是可以利用它本身的逻辑：既然它触发重连的条件是conn为null，我就将它设成null好了。当conn不为null但是获取数据又出错的时候，就可以判断连接有问题，不妨触发重试，即使这种情况下不一定是连接失效了，但是正常情况下不会出现这种现象，就将其当成是连接失效也无妨。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-背景&quot;&gt;&lt;a href=&quot;#1-背景&quot; class=&quot;headerlink&quot; title=&quot;1. 背景&quot;&gt;&lt;/a&gt;1. 背景&lt;/h1&gt;&lt;p&gt;druid本身提供了监控功能，具体在我另一篇博文《&lt;a href=&quot;/2017/08/27/druid-monitor/&quot;&gt;Druid连接池监控&lt;/a&gt;》里有介绍。当时提到有以下缺陷：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无法灵活监控多个目标&lt;/li&gt;
&lt;li&gt;切换环境不方便&lt;/li&gt;
&lt;li&gt;JMX重连不会成功&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此针对这些问题，对其进行改造。改造后的源码已经放在个人的github上：&lt;br&gt;&lt;a href=&quot;https://github.com/bungder/druid-aggregated-monitor&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/bungder/druid-aggregated-monitor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对应本文的版本，已经打了tag：&lt;br&gt;&lt;a href=&quot;https://github.com/bungder/druid-aggregated-monitor/releases/tag/0.0.1&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;https://github.com/bungder/druid-aggregated-monitor/releases/tag/0.0.1&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="druid" scheme="http://bungder.github.io/tags/druid/"/>
    
      <category term="连接池" scheme="http://bungder.github.io/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
      <category term="监控" scheme="http://bungder.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>Druid连接池监控</title>
    <link href="http://bungder.github.io/2017/08/27/druid-monitor/"/>
    <id>http://bungder.github.io/2017/08/27/druid-monitor/</id>
    <published>2017-08-27T09:43:32.000Z</published>
    <updated>2017-09-01T13:49:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-普通的web监控"><a href="#1-普通的web监控" class="headerlink" title="1. 普通的web监控"></a>1. 普通的web监控</h1><p>阿里开源的连接池Druid自带了web监控的功能，具体的操作在其github的wiki上可以找到：<a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatViewServlet%E9%85%8D%E7%BD%AE" target="_blank" rel="external">配置_StatViewServlet配置 · alibaba/driud wiki</a></p>
<p>其实主要就是配置一个Servlet，但是github wiki上的做法只能在druid所在的项目中启用web服务的做法，在如今盛行的微服务架构中，很多时候druid所在的服务里并不提供web服务，这就需要额外的配置。其实druid本身也提供了这种功能，只是wiki里没有说。</p>
<p>druid本身可以通过启用JMX端口来将监控数据传输到远端进行处理，具体做法是：</p>
<ol>
<li>在启动服务的时候加上JVM启动参数（下文说）</li>
<li>在远端启用web服务，配置StatViewServlet，在initParam中指定JMX地址</li>
</ol>
<a id="more"></a>
<h2 id="1-1-JVM启动参数："><a href="#1-1-JVM启动参数：" class="headerlink" title="1.1 JVM启动参数："></a>1.1 JVM启动参数：</h2><blockquote>
<p>-Djava.net.preferIPv4Stack=true<br>-Dcom.sun.management.jmxremote<br>-Djava.rmi.server.hostname=192.168.199.123<br>-Dcom.sun.management.jmxremote.port=9876<br>-Dcom.sun.management.jmxremote.authenticate=false<br>-Dcom.sun.management.jmxremote.ssl=false</p>
</blockquote>
<p>其中，<code>-Djava.rmi.server.hostname</code>一项指定了服务所在的IP地址，<code>-Dcom.sun.management.jmxremote.port</code>一项指定了JMX端口。</p>
<h2 id="1-2-远程web工程Servlet配置"><a href="#1-2-远程web工程Servlet配置" class="headerlink" title="1.2 远程web工程Servlet配置"></a>1.2 远程web工程Servlet配置</h2><p>在web.xml里添加如下配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DruidStatView<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.alibaba.druid.support.http.StatViewServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">  <span class="comment">&lt;!-- 远程访问JavaSE项目使用jmx连接 --&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>jmxUrl<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>service:jmx:rmi:///jndi/rmi://192.168.199.123:9876/jmxrmi<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>loginUsername<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>loginPassword<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>admin<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>DruidStatView<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/druid/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果想快速打包启动，不依赖外部web容器，可以采用SpringBoot，用嵌入式的web容器启动，原理也是一样。具体做法是：</p>
<ol>
<li>创建Servlet：</li>
</ol>
<figure class="highlight java"><figcaption><span>DruidStatViewServlet.java</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.tansc.test.springboot.config.druid;</div><div class="line">	</div><div class="line"><span class="keyword">import</span> com.alibaba.druid.support.http.StatViewServlet;</div><div class="line">	</div><div class="line"><span class="keyword">import</span> javax.servlet.annotation.WebInitParam;</div><div class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</div><div class="line">	</div><div class="line"><span class="comment">/**</span></div><div class="line"> * StatViewServlet</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</div><div class="line"><span class="meta">@WebServlet</span>(urlPatterns = <span class="string">"/druid/*"</span>,</div><div class="line">    initParams=&#123;</div><div class="line">            <span class="meta">@WebInitParam</span>(name=<span class="string">"loginUsername"</span>,value=<span class="string">"admin"</span>),<span class="comment">// 用户名</span></div><div class="line">            <span class="meta">@WebInitParam</span>(name=<span class="string">"loginPassword"</span>,value=<span class="string">"admin"</span>),<span class="comment">// 密码</span></div><div class="line">            <span class="meta">@WebInitParam</span>(name=<span class="string">"jmxUrl"</span>,value=<span class="string">"service:jmx:rmi:///jndi/rmi://192.168.199.123:9876/jmxrmi"</span>),</div><div class="line">            <span class="meta">@WebInitParam</span>(name=<span class="string">"resetEnable"</span>,value=<span class="string">"false"</span>)<span class="comment">// 禁用HTML页面上的“Reset All”功能</span></div><div class="line">    &#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DruidStatViewServlet</span> <span class="keyword">extends</span> <span class="title">StatViewServlet</span> </span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ol>
<li>在启动类上加上注解<code>@ServletComponentScan(&quot;com.tansc.test.springboot&quot;)</code>以扫描Servlet。</li>
</ol>
<h2 id="1-3-查看监控数据"><a href="#1-3-查看监控数据" class="headerlink" title="1.3 查看监控数据"></a>1.3 查看监控数据</h2><p>上面的都配置好之后，启动服务，等服务启动成功之后，启动远端的web服务，然后访问web服务的<code>/druid</code>目录（与上面配置的匹配即可），例如在我本地起的：<code>http://127.0.0.1:8080/druid</code></p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/druid-monitor.png" alt=""></p>
<h2 id="1-4-缺陷"><a href="#1-4-缺陷" class="headerlink" title="1.4 缺陷"></a>1.4 缺陷</h2><ol>
<li>这种做法是一对一的，也就是一个druid连接池实例必须对应一个StatViewServlet，一个StatViewServlet也只能对应一个druid实例。</li>
<li>切换环境不方便</li>
<li>JMX重连不会成功<ul>
<li>虽然远端会有重连机制，但是在服务重启之后，重连总是报Connection refused，只能将远端的web服务重启才能成功连上（后来发现这其实没有重连，报错只是使用一个已经terminated的连接获取数据报错，具体见下一篇博文）</li>
</ul>
</li>
</ol>
<h2 id="1-5-改进"><a href="#1-5-改进" class="headerlink" title="1.5 改进"></a>1.5 改进</h2><p>对于上面提到的两点缺陷，可以用以下两个思路去改进：</p>
<ol>
<li>动态创建servlet，模仿分布式服务的注册中心的形式来改造<ul>
<li>Servlet本身不提供这样的API，但是应该是可以做到的，具体要继续探索。</li>
</ul>
</li>
<li>使用配置文件<ul>
<li>web.xml里面本身不能读取配置文件的值，但是可以通过继承StatViewServlet来实现。</li>
</ul>
</li>
<li>需要分析源码</li>
</ol>
<p>（2017-08-31 目前已经改造了，见我下一篇博文：<a href="/2017/08/31/druid-monitor-remould/">Druid连接池监控的一次改造</a>）</p>
<h2 id="1-6-性能损耗"><a href="#1-6-性能损耗" class="headerlink" title="1.6 性能损耗"></a>1.6 性能损耗</h2><p>当远程的web服务启动并且在浏览器里访问统计页面之后，该服务的内存变化如下：<br><img src="http://otlnkjq1m.bkt.clouddn.com/JProfiler8-RecordedObjects.jpg" alt=""></p>
<h1 id="2-持久化-自定义传输监控记录"><a href="#2-持久化-自定义传输监控记录" class="headerlink" title="2. 持久化/自定义传输监控记录"></a>2. 持久化/自定义传输监控记录</h1><p>可以通过定制StatLogger实现，具体见其github的wiki：<br><a href="https://github.com/alibaba/druid/wiki/%E6%80%8E%E4%B9%88%E4%BF%9D%E5%AD%98Druid%E7%9A%84%E7%9B%91%E6%8E%A7%E8%AE%B0%E5%BD%95" target="_blank" rel="external">怎么保存Druid的监控记录 · alibaba/driud wiki</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>配置StatFilter · alibaba/driud wiki<br><a href="https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatFilter" target="_blank" rel="external">https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatFilter</a></li>
<li>非web项目如何配置Druid监控 - 若鱼的专栏 - CSDN博客<br><a href="http://blog.csdn.net/goldenfish1919/article/details/68941237" target="_blank" rel="external">http://blog.csdn.net/goldenfish1919/article/details/68941237</a></li>
<li>Spring Boot 使用 Druid 和监控配置 - 小单的博客专栏 - CSDN博客<br><a href="http://blog.csdn.net/catoop/article/details/50925337" target="_blank" rel="external">http://blog.csdn.net/catoop/article/details/50925337</a></li>
<li>怎么保存Druid的监控记录 · alibaba/driud wiki<br><a href="https://github.com/alibaba/druid/wiki/%E6%80%8E%E4%B9%88%E4%BF%9D%E5%AD%98Druid%E7%9A%84%E7%9B%91%E6%8E%A7%E8%AE%B0%E5%BD%95" target="_blank" rel="external">https://github.com/alibaba/druid/wiki/%E6%80%8E%E4%B9%88%E4%BF%9D%E5%AD%98Druid%E7%9A%84%E7%9B%91%E6%8E%A7%E8%AE%B0%E5%BD%95</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-普通的web监控&quot;&gt;&lt;a href=&quot;#1-普通的web监控&quot; class=&quot;headerlink&quot; title=&quot;1. 普通的web监控&quot;&gt;&lt;/a&gt;1. 普通的web监控&lt;/h1&gt;&lt;p&gt;阿里开源的连接池Druid自带了web监控的功能，具体的操作在其github的wiki上可以找到：&lt;a href=&quot;https://github.com/alibaba/druid/wiki/%E9%85%8D%E7%BD%AE_StatViewServlet%E9%85%8D%E7%BD%AE&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;配置_StatViewServlet配置 · alibaba/driud wiki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;其实主要就是配置一个Servlet，但是github wiki上的做法只能在druid所在的项目中启用web服务的做法，在如今盛行的微服务架构中，很多时候druid所在的服务里并不提供web服务，这就需要额外的配置。其实druid本身也提供了这种功能，只是wiki里没有说。&lt;/p&gt;
&lt;p&gt;druid本身可以通过启用JMX端口来将监控数据传输到远端进行处理，具体做法是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在启动服务的时候加上JVM启动参数（下文说）&lt;/li&gt;
&lt;li&gt;在远端启用web服务，配置StatViewServlet，在initParam中指定JMX地址&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="druid" scheme="http://bungder.github.io/tags/druid/"/>
    
      <category term="连接池" scheme="http://bungder.github.io/tags/%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
      <category term="监控" scheme="http://bungder.github.io/tags/%E7%9B%91%E6%8E%A7/"/>
    
  </entry>
  
  <entry>
    <title>持续集成简述</title>
    <link href="http://bungder.github.io/2017/07/24/CI/"/>
    <id>http://bungder.github.io/2017/07/24/CI/</id>
    <published>2017-07-24T13:51:48.000Z</published>
    <updated>2017-08-28T12:47:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1    概述"></a>1    概述</h1><p>互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration, CI）。持续集成也被认为是敏捷开发的最重要实践之一。</p>
<p>本文主要介绍持续集成的概念以及一些工具与实践。</p>
<h1 id="2-概念"><a href="#2-概念" class="headerlink" title="2    概念"></a>2    概念</h1><p><img src="http://otlnkjq1m.bkt.clouddn.com/CI-notion-relation.png" alt="图2.1 持续集成概念示意图之一"><br>图2.1 持续集成概念示意图之一</p>
<p>上图来源于<a href="http://blog.flow.ci/cicd_difference/" target="_blank" rel="external">谈谈持续集成，持续交付，持续部署之间的区别</a>，这图很直观地描述了持续集成相关的概念之间的关系，与持续集成密切相关的概念还有持续交付、持续部署，因此在下文将会就这三个概念进行阐述。</p>
<a id="more"></a>
<h2 id="2-1-持续集成"><a href="#2-1-持续集成" class="headerlink" title="2.1    持续集成"></a>2.1    持续集成</h2><p>维基百科的定义（<a href="https://en.wikipedia.org/wiki/Continuous_integration" target="_blank" rel="external">Continuous integration - Wikipedia</a>）：</p>
<blockquote>
<p>在软件工程里，持续集成（Continuous Integration, CI）是指这样的一种实践：在一天里多次将所有开发人员的代码合并到一个共享的主干里，每次合并都会触发持续集成服务器进行自动构建，这个过程包括了编译、单元测试、集成测试、质量分析等步骤，结果只有两个：成功或者失败。如果得到失败的结果，说明有人提交了不合格的代码，这就能及时发现问题。</p>
</blockquote>
<p>在瀑布模型中，软件的开发过程被分为以下几个阶段：</p>
<ul>
<li>需求分析</li>
<li>系统设计</li>
<li>编码实现</li>
<li>测试</li>
<li>集成</li>
<li>部署</li>
<li>维护</li>
</ul>
<p>而一般在实际的开发中，基本也就遵循这些步骤进行开发，大部分情况下，不会完全按照瀑布流的方式执行，但是这些步骤都是有的，无非就是在文档的落实、步骤的次序与侧重有所变化。其中，所谓的集成，在平时的开发过程中很少直接提到这个名词，其含义是（见：<a href="https://en.wikipedia.org/wiki/System_integration" target="_blank" rel="external">System integration - Wikipedia</a>）：</p>
<blockquote>
<p>将子系统的组件整合到一个系统中并且确保子系统的功能可以组合为一个系统的过程。</p>
</blockquote>
<p>所以，所谓的『集成』就是在存在多个系统协作的情况下，将子系统集成为一个大系统的过程，这个概念与『集成测试』中的『集成』是同一个概念。但是有些文章在解释『持续集成』这个概念的时候，将其解释为『将代码集成到主干分支』，目前也没见到有人说这是错的。</p>
<p>如果只有一个系统，那么就不存在『系统集成』这一个步骤，但是『持续集成』这个做法还是可以应用其中的，因为『持续集成』的精髓不在于『集成』，而在于『持续』，而我所理解的『持续』，就是将一些重复的操作自动化，然后频繁地触发这个自动化过程。</p>
<p>所以，结合上面提到的瀑布模型的几个阶段，以及『持续集成』这个名字，图2.1应该改为这样：</p>
<p><img src="http://otlnkjq1m.bkt.clouddn.com/CI-notion-relation-2.png" alt="图2.2 持续集成概念示意图之二"><br>图2.2 持续集成概念示意图之二</p>
<p>从上图中看来，持续集成应该至少包括以下几部分:</p>
<ul>
<li>自动化构建</li>
<li>自动化测试</li>
<li>自动发布</li>
</ul>
<p><img src="http://7xsn88.com1.z0.glb.clouddn.com/image/f/82/6ce32afc227588c4b60b143501dcd.png" alt="图2.3 持续集成阶段示意图"><br>图2.3 持续集成阶段示意图</p>
<p>每一次的构建与测试，都应该得到一个结果：通过或者不通过，开发人员应该都能看到每一次构建与测试的结果，得到不通过的结果时应该能马上修复相关的缺陷，这就需要有一种合适的反馈渠道。</p>
<h3 id="2-1-1-自动化构建"><a href="#2-1-1-自动化构建" class="headerlink" title="2.1.1 自动化构建"></a>2.1.1 自动化构建</h3><p>自动化构建包括以下过程：</p>
<ul>
<li>将源码编译成为二进制码</li>
<li>打包二进制码</li>
<li>运行自动化测试</li>
<li>生成文档</li>
<li>生成分发媒体（例如：Debian DEB、Red Hat RPM或者Windows MSI文件）</li>
</ul>
<p>自动化构建可以通过两类工具实现：</p>
<ol>
<li>构建自动化软件（Build automation utility）<ul>
<li>例如Make、Ant、Maven、Gradle，目的是通过编译等活动来生成构建产物（build artifact）。</li>
</ul>
</li>
<li>构建自动化服务器（Build automation servers）<ul>
<li>一般是基于web的工具，通过计划任务或者是事件触发的方式调用构建自动化软件。一个CI服务器就是一类构建自动化服务器。</li>
</ul>
</li>
</ol>
<h3 id="2-1-2-自动化测试"><a href="#2-1-2-自动化测试" class="headerlink" title="2.1.2    自动化测试"></a>2.1.2    自动化测试</h3><p>自动化测试是持续集成必不可少的一部分，基本上，没有自动化测试的持续集成，都很难称之为真正的持续集成。我们希望持续集成能够尽早的暴露问题，但这远非配置一个 Hudson/Jenkins服务器那么简单，只有真正用心编写了较为完整的测试用例，并一直维护它们，持续集成才能孜孜不倦地运行测试并第一时间报告问题。</p>
<p>测试自动化是使用特定的软件（独立于被测试的软件）来控制测试的执行以及比较实际输出与预期输出。测试自动化可以将某些重复但必要的任务自动化，或者执行某些难以手动执行的额外测试。</p>
<p>自动化测试还包括单元测试、集成测试、系统测试、验收测试、性能测试等，在不同的场景下，它们都能为软件开发带来极大的价值。</p>
<h4 id="2-1-2-1-单元测试"><a href="#2-1-2-1-单元测试" class="headerlink" title="2.1.2.1    单元测试"></a>2.1.2.1    单元测试</h4><p>单元测试（Unit Testing）又称为模块测试, 是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</p>
<p>通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到预期的工作目标，没有程序错误。</p>
<h4 id="2-1-2-2-集成测试"><a href="#2-1-2-2-集成测试" class="headerlink" title="2.1.2.2    集成测试"></a>2.1.2.2    集成测试</h4><p>集成测试（Integration Testing，有时也叫Integration and Testing, I&amp;T）即对独立的软件模块组装起来看成是一个整体进行测试。集成测试一般在单元测试之后、系统测试之前进行。实践表明，有时模块虽然可以单独工作，但是并不能保证组装起来也可以同时工作。</p>
<p>集成与单元测试最大的区别是它需要尽可能的测试整个功能及相关环境，对于测试Web应用而言，通常有这么几步：</p>
<ol>
<li>启动Web容器</li>
<li>部署待测试Web应用</li>
<li>以Web客户端的角色运行测试用例</li>
<li>停止Web容器</li>
</ol>
<p>通常有三种手段实现集成测试：</p>
<ol>
<li><p>大爆炸（Big Bang）<br>将所有单元组合到一起一次性测试一遍。</p>
</li>
<li><p>自上而下（Top Down）<br>先测试高层次的单元，然后逐渐测试低层次的单元。</p>
</li>
<li><p>自下而上（Bottom Up）<br>先测试低层次的单元，然后逐渐测试高层次的单元。</p>
</li>
</ol>
<h2 id="2-2-持续交付"><a href="#2-2-持续交付" class="headerlink" title="2.2    持续交付"></a>2.2    持续交付</h2><p><img src="http://7xsn88.com1.z0.glb.clouddn.com/image/e/bd/d757dd642e93e33fede310325b155.png" alt=""><br>图2.4 持续交付示意图</p>
<p>持续交付（Continuous Delivery, CD）是一种软件工程的手段，让软件在短周期内产出，确保软件随时可以被可靠地发布。其目的在于更快、更频繁地构建、测试以及发布软件。通过加强对生产环境的应用进行渐进式更新，这种手段可以降低交付变更的成本与风险。一个简单直观的与可重复的部署过程对于持续交付来说是很重要的。</p>
<h3 id="2-2-1-与DevOps的关系"><a href="#2-2-1-与DevOps的关系" class="headerlink" title="2.2.1 与DevOps的关系"></a>2.2.1 与DevOps的关系</h3><p>持续交付与DevOps的含义很相似，所以经常被混淆。但是它们是不同的两个概念。DevOps的范围更广，它以文化变迁为中心，特别是软件交付过程所涉及的多个团队之间的合作（开发、运维、QA、管理部门等），并且将软件交付的过程自动化。另一方面，持续交付是一种自动化交付的手段，关注点在于将不同的过程集中起来，并且更快、更频繁地执行这些过程。因此，DevOps可以是持续交付的一个产物，持续交付直接汇入DevOps。</p>
<h3 id="2-2-2-与持续部署的关系"><a href="#2-2-2-与持续部署的关系" class="headerlink" title="2.2.2 与持续部署的关系"></a>2.2.2 与持续部署的关系</h3><p>有时候，持续交付也与持续部署混淆。持续部署意味着所有的变更都会被自动部署到生产环境中。持续交付意味着所有的变更都可以被部署到生产环境中，但是出于业务考虑，可以选择不部署。如果要实施持续部署，必须先实施持续交付。</p>
<h3 id="2-2-3-原则"><a href="#2-2-3-原则" class="headerlink" title="2.2.3 原则"></a>2.2.3 原则</h3><p><img src="https://upload.wikimedia.org/wikipedia/commons/c/c3/Continuous_Delivery_process_diagram.svg" alt=""><br>图2.5 持续交付流水线示意图</p>
<p>持续交付将部署流水线（<strong>deployment pipeline</strong>）这个老生常谈的概念看作一种简单的防错方法：一系列的确认。通过这些确认，一款软件必须遵循特定的路径来发布。每当有变更被提交到源码控制仓库中时，代码要首先进行编译（有必要的话），然后由构建服务器进行打包，接着由一些不同的技术来进行测试，最后才可以将代码标记为可发布的（releasable）。</p>
<p>在一个持续交付环境中工作时，习惯了漫长开发周期的开发人员或许需要改变他们心态。任何代码提交在任何时间点都可能会向客户发布，明白这一点是很重要的。对于在早期提交尚未准备好让用户使用的代码，类似功能开关这样的模式是很有用的。使用NoSQL可以消除持续交付工作流中的数据迁移和模式变更的步骤、手工操作步骤以及异常情况。对于代码隔离的其他有用的技术——例如代码分支——在持续交付工作流中并未过时，但是必须加以修改以适应持续交付的原则。例如，运行多个长生命周期的代码分支是不实际的，因为一个可发布的产物如果要经历流水线的所有阶段，它必须从一个单独的分支中构建而来。</p>
<h2 id="2-3-持续部署"><a href="#2-3-持续部署" class="headerlink" title="2.3    持续部署"></a>2.3    持续部署</h2><p><img src="http://7xsn88.com1.z0.glb.clouddn.com/image/0/3a/6b241b45b65eb7d77927619015d84.png" alt=""><br>图2.6 持续部署示意图</p>
<p>如图所示，持续部署与持续交付之间的差异就是前者将部署自动化了。</p>
<p>在持续交付的实践中，交付的目标是QA，但是实际上，软件最终是要交付到客户手上的。在SaaS领域里，持续部署采用得比较广泛，因为服务比较容易做到静默升级。</p>
<p>采用持续部署的前提是自动化测试的覆盖率足够高。</p>
<p>采用持续部署的好处是能减少运维的工作量，缩短新特性从开发到实际交付的周期。</p>
<h1 id="3-代价与好处"><a href="#3-代价与好处" class="headerlink" title="3    代价与好处"></a>3    代价与好处</h1><h2 id="3-1-代价"><a href="#3-1-代价" class="headerlink" title="3.1    代价"></a>3.1    代价</h2><ol>
<li>构造自动测试用例会耗费大量的工作，而且要去覆盖不断增加的新功能点，也要随着代码的改动去修改测试用例。<ul>
<li>测试被视为软件开发的一种最佳实践。无论是否采用持续集成，在一些方法论里——例如测试驱动开发——自动化测试都是必不可少的一部分。</li>
<li>采用持续集成的时候也可以不使用任何测试用例，但是在发布一个产品之前的质量保证（Quality Assurance）成本就会变得很高，因为一切都要频繁地采用人手操作。</li>
</ul>
</li>
<li>要花费精力去部署一个构建系统，这有时候会比较复杂，难以灵活地修改<ul>
<li>然而，有大量的开源的持续集成软件项目，选择很多</li>
</ul>
</li>
<li>如果项目比较小，或者包含了未经测试的遗留代码，持续集成的价值就并不是那么大</li>
<li>持续集成所增加的价值依赖于测试的质量以及代码实际上的可测试程度。</li>
<li>团队规模大就意味着代码会非常频繁地提交到集成队列里，跟踪提交就会比较困难，并且排队进行构建会减慢每个人的工作，如果构建失败，整个开发团队必须停下手里的工作，立刻修复他们的错误。<ul>
<li>但是持续集成是可以灵活变通的，不一定要在一天里多次构建，可以配置每天下班前半小时自动构建，有错误的话开发人员可以在下班前进行处理；或者每天凌晨自动构建，第二天早上开发人员一上班就能看到构建的结果报告，然后进行处理。</li>
</ul>
</li>
<li>一天里有多个提交和合并，一个新功能的部分代码能轻易地推送上去，在新功能完成之前，集成测试都是不通过的。</li>
</ol>
<h2 id="3-2-好处"><a href="#3-2-好处" class="headerlink" title="3.2    好处"></a>3.2    好处</h2><ol>
<li>能快速发现错误和定位错误</li>
<li>避免在发布日期大家都在检查自己有冲突的版本，造成混乱</li>
<li>当单元测试不通过或者出现bug的时候，如果开发人员需要回滚代码，只会造成少量的改动丢失，因为集成是频繁的。</li>
<li>防止分支大幅偏离主干。如果不是经常集成，主干又在不断更新，会导致以后集成的难度变大，甚至难以集成。</li>
<li>无论对于测试、demo还是发布的目的或需求，总是有一份当前的构建可用。</li>
<li>频繁的代码检查驱使开发人员编写模块化的、低复杂度的代码。</li>
</ol>
<h1 id="4-具体实践"><a href="#4-具体实践" class="headerlink" title="4    具体实践"></a>4    具体实践</h1><h2 id="4-1-工具"><a href="#4-1-工具" class="headerlink" title="4.1    工具"></a>4.1    工具</h2><table>
<thead>
<tr>
<th>名称</th>
<th>授权</th>
<th>价格</th>
<th>Git支持</th>
<th>Docker支持</th>
<th>自动测试</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Jenkins</td>
<td>MIT</td>
<td>免费</td>
<td>不支持</td>
<td>不支持</td>
<td>需插件支持</td>
<td></td>
</tr>
<tr>
<td>GitLab CI</td>
<td>MIT</td>
<td>免费</td>
<td>支持</td>
<td>支持</td>
<td>需自配测试服务</td>
<td></td>
</tr>
<tr>
<td>Phabricator</td>
<td>Apache 2.0</td>
<td>免费</td>
<td>支持</td>
<td></td>
<td></td>
<td>Facebook出品</td>
</tr>
<tr>
<td>Travis CI</td>
<td></td>
<td>免费</td>
<td>支持</td>
<td>支持</td>
<td></td>
<td>不支持私有部署</td>
</tr>
<tr>
<td>Bamboo</td>
<td></td>
<td>收费</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
<td></td>
</tr>
<tr>
<td>Codeship</td>
<td></td>
<td>免费/收费</td>
<td>关联Github, GitLab</td>
<td>支持</td>
<td></td>
<td>不支持私有部署</td>
</tr>
<tr>
<td>CircleCI</td>
<td></td>
<td>免费/收费</td>
<td>关联Github</td>
<td>支持</td>
<td>支持大部分测试框架</td>
<td>不支持私有部署</td>
</tr>
<tr>
<td>Hudson</td>
<td>Eclipse Public License 1.0</td>
<td>免费</td>
<td>需插件</td>
<td>需插件</td>
<td></td>
</tr>
</tbody>
</table>
<p>其实这里的支持，意思应该是直接的支持，例如Jenkins，其实和git结合也很简单，通过脚本就可以实现。</p>
<h1 id="5-参考资料"><a href="#5-参考资料" class="headerlink" title="5    参考资料"></a>5    参考资料</h1><ol>
<li>Maven实战（五）——自动化Web应用集成测试<br><a href="http://www.infoq.com/cn/news/2011/03/xxb-maven-5-integration-test" target="_blank" rel="external">http://www.infoq.com/cn/news/2011/03/xxb-maven-5-integration-test</a></li>
<li>单元测试 - 维基百科<br><a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95" target="_blank" rel="external">https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95</a></li>
<li>Integration testing – Wikipedia<br><a href="https://en.wikipedia.org/wiki/Integration_testing" target="_blank" rel="external">https://en.wikipedia.org/wiki/Integration_testing</a></li>
<li>Continuous integration – Wikipedia<br><a href="https://en.wikipedia.org/wiki/Continuous_integration" target="_blank" rel="external">https://en.wikipedia.org/wiki/Continuous_integration</a></li>
<li>Continuous integration | ThoughtWorks<br><a href="https://www.thoughtworks.com/continuous-integration" target="_blank" rel="external">https://www.thoughtworks.com/continuous-integration</a></li>
<li>另一种声音：持续集成已死<br><a href="http://www.infoq.com/cn/news/2014/10/continuous-integration" target="_blank" rel="external">http://www.infoq.com/cn/news/2014/10/continuous-integration</a></li>
<li>持续集成是什么？<br><a href="http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html</a></li>
<li>25 best continuous integration tools as of 2017 - Slant<br><a href="https://www.slant.co/topics/799/~best-continuous-integration-tools" target="_blank" rel="external">https://www.slant.co/topics/799/~best-continuous-integration-tools</a></li>
<li>Bamboo vs Jenkins Comparison | Atlassian<br><a href="https://www.atlassian.com/software/bamboo/comparison/bamboo-vs-jenkins" target="_blank" rel="external">https://www.atlassian.com/software/bamboo/comparison/bamboo-vs-jenkins</a></li>
<li>通过Docker容器运行持续集成/持续部署<br><a href="http://dockone.io/article/468" target="_blank" rel="external">http://dockone.io/article/468</a></li>
<li>Continuous Integration, Deployment &amp; Delivery with Codeship<br><a href="https://codeship.com" target="_blank" rel="external">https://codeship.com</a></li>
<li>谈谈持续集成，持续交付，持续部署之间的区别<br><a href="http://blog.flow.ci/cicd_difference/" target="_blank" rel="external">http://blog.flow.ci/cicd_difference/</a></li>
<li>Continuous delivery – Wikipedia<br><a href="https://en.wikipedia.org/wiki/Continuous_delivery" target="_blank" rel="external">https://en.wikipedia.org/wiki/Continuous_delivery</a></li>
<li>Build automation – Wikipedia<br><a href="https://en.wikipedia.org/wiki/Build_automation" target="_blank" rel="external">https://en.wikipedia.org/wiki/Build_automation</a></li>
<li>List of build automation software – Wikipedia<br><a href="https://en.wikipedia.org/wiki/List_of_build_automation_software" target="_blank" rel="external">https://en.wikipedia.org/wiki/List_of_build_automation_software</a></li>
<li>Software development process - Wikipedia<br><a href="https://en.wikipedia.org/wiki/Software_development_process" target="_blank" rel="external">https://en.wikipedia.org/wiki/Software_development_process</a></li>
<li>System integration - Wikipedia<br><a href="https://en.wikipedia.org/wiki/System_integration" target="_blank" rel="external">https://en.wikipedia.org/wiki/System_integration</a></li>
<li>Continuous Integration - Martin Fowler<br><a href="https://martinfowler.com/articles/continuousIntegration.html#PracticesOfContinuousIntegration" target="_blank" rel="external">https://martinfowler.com/articles/continuousIntegration.html#PracticesOfContinuousIntegration</a></li>
<li>Integration Testing - Software Testing Fundamentals<br><a href="http://softwaretestingfundamentals.com/integration-testing/" target="_blank" rel="external">http://softwaretestingfundamentals.com/integration-testing/</a></li>
<li>Practical continuous deployment: a guide to automated software delivery<br><a href="https://www.atlassian.com/blog/continuous-delivery/practical-continuous-deployment" target="_blank" rel="external">https://www.atlassian.com/blog/continuous-delivery/practical-continuous-deployment</a></li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1    概述&quot;&gt;&lt;/a&gt;1    概述&lt;/h1&gt;&lt;p&gt;互联网软件的开发和发布，已经形成了一套标准流程，最重要的组成部分就是持续集成（Continuous integration, CI）。持续集成也被认为是敏捷开发的最重要实践之一。&lt;/p&gt;
&lt;p&gt;本文主要介绍持续集成的概念以及一些工具与实践。&lt;/p&gt;
&lt;h1 id=&quot;2-概念&quot;&gt;&lt;a href=&quot;#2-概念&quot; class=&quot;headerlink&quot; title=&quot;2    概念&quot;&gt;&lt;/a&gt;2    概念&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://otlnkjq1m.bkt.clouddn.com/CI-notion-relation.png&quot; alt=&quot;图2.1 持续集成概念示意图之一&quot;&gt;&lt;br&gt;图2.1 持续集成概念示意图之一&lt;/p&gt;
&lt;p&gt;上图来源于&lt;a href=&quot;http://blog.flow.ci/cicd_difference/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;谈谈持续集成，持续交付，持续部署之间的区别&lt;/a&gt;，这图很直观地描述了持续集成相关的概念之间的关系，与持续集成密切相关的概念还有持续交付、持续部署，因此在下文将会就这三个概念进行阐述。&lt;/p&gt;
    
    </summary>
    
    
      <category term="软件工程" scheme="http://bungder.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
      <category term="持续集成" scheme="http://bungder.github.io/tags/%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/"/>
    
  </entry>
  
  <entry>
    <title>一种RESTful接口的约定</title>
    <link href="http://bungder.github.io/2017/07/24/REST/"/>
    <id>http://bungder.github.io/2017/07/24/REST/</id>
    <published>2017-07-24T13:05:13.000Z</published>
    <updated>2017-08-20T14:08:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h2 id="1-1-撰写目的"><a href="#1-1-撰写目的" class="headerlink" title="1.1 撰写目的"></a>1.1 撰写目的</h2><p>本文用于定义一种统一的RESTful接口设计方案，希望具有参考价值。本文所描述的方案比较学院派（死板），在上一家公司提出没有被采纳，在所了解到的有限的若干家声称采用了RESTful风格的公司里，发现他们也偏离甚远，而在书本以及网上大部分介绍RESTful的资料里，却都是这样的方案（URL命名风格、请求与响应的设计）。当然，他们这么做是有理由的，我也理解，这只是取舍问题。这篇文章其实是旧文了，2016年年底就已经写好，但是一直躺在电脑的硬盘里，不想白费了当时的功夫，因此在此公开。</p>
<h2 id="1-2-为什么采用REST"><a href="#1-2-为什么采用REST" class="headerlink" title="1.2    为什么采用REST"></a>1.2    为什么采用REST</h2><p>目的是为了服务端与客户端的解耦。SOA仅仅是从结构上将前后端分离，但是实际上数据逻辑还是没有实现解耦，服务端接口升级往往会影响客户端，两者的行为需要严格约定。而REST采用HTTP协议进行约定，客户端仅仅需要按照HTTP协议来理解服务端返回的数据，虽然与业务相关的数据结构还是需要约定，但是这确实进一步解耦了服务端与客户端。</p>
<p>另外，由于严格遵照HTTP协议进行数据返回，对于安全的接口，可以在返回的Header里设置缓存策略（接口安全性的概念在下文会解释）。</p>
<a id="more"></a>
<h2 id="1-3-文档结构"><a href="#1-3-文档结构" class="headerlink" title="1.3 文档结构"></a>1.3 文档结构</h2><p>第二部分将阐述关于RESTful的若干个关键的概念，明确第二部分阐述的几个概念有利于设计、实现优雅规范的接口。</p>
<p>第三部分就URL命名的问题进行约定。</p>
<p>第四部分对消息实体进行约定。</p>
<p>第五部分对『向RESTful接口发起请求』进行阐述，约定要实现的方法，约定请求的头部和body的格式。</p>
<p>第六部分对接口的响应格式进行约定，包括响应消息的头部、状态码、JSON实体。</p>
<p>第七部分对版本控制的问题进行约定。</p>
<p>第八部分对RESTful接口的实现提出了实现工具的建议。</p>
<h1 id="2-关键概念"><a href="#2-关键概念" class="headerlink" title="2    关键概念"></a>2    关键概念</h1><p>明确一些关键的概念是很重要的，虽然RESTful风格的API设计方案并没有统一的标准，但是还是需要符合一定的原则进行设计，否则就不能称为RESTful风格的API。因为许多人并没有对REST进行充分的了解就宣称自己的API是RESTful风格的API，以至于RESTful的提出者Fielding博士本人无法忍受，在2008年为此专门写了一篇博客『<strong>REST APIs must be hypertext-driven</strong>』，hypertext-driven与HATEOAS是同一个概念的不同表述，在下文会进行阐述。</p>
<h2 id="2-1-RESTful"><a href="#2-1-RESTful" class="headerlink" title="2.1     RESTful"></a>2.1     RESTful</h2><p><strong>REST</strong>不是一种协议，也不是一种文件格式，更不是一种开发框架。它是一系列的设计约束的集合：无状态性、将超媒体作为应用状态的引擎等。REST是<strong>Representation State Transfer</strong>的缩写，中文是『表述性状态转移』，这里就涉及到资源的表述与状态两个概念。</p>
<p>简单地说，资源可以看作是服务器上存储的所有数据，资源的表述则是服务器对外提供的指向这些资源的方式，使用JSON、XML等均可，一个资源可以有多种表述；资源的状态则是服务器的数据存储状态，例如在t时刻，服务器中存储了m条数据，这时候客户端向服务端提交了一个创建数据的请求，服务器处理了此请求并创建了一条数据，那么在t+1时刻，服务器中就存储了m+1条数据，这两个时刻的资源状态就是不一样的，t时刻发生的请求导致了资源状态的改变。</p>
<h2 id="2-2-HATEOAS"><a href="#2-2-HATEOAS" class="headerlink" title="2.2    HATEOAS"></a>2.2    HATEOAS</h2><p><strong>Hypermedia As The Engine Of Application State</strong>，超媒体作为应用程序状态的引擎。这是REST区别于其他SOA风格的主要特点。客户端与服务端进行互动的时候，完全是通过服务端动态提供的超媒体进行的。除了对超媒体的一般理解，客户端不需要知道其他额外的知识。相反，在一些SOA接口的设计中，客户端与服务端的通信是要事先进行约定的，例如通过文档或者接口描述语言（Interface Description Language, IDL）。而基于HTTP协议的REST设计里，一般采用的就是请求与响应的Header来体现HATEOAS原则（具体请参考：<a href="https://en.wikipedia.org/wiki/HATEOAS" target="_blank" rel="external">https://en.wikipedia.org/wiki/HATEOAS</a>）。这里也隐含这样一层含义：REST应尽可能地利用HTTP标准中现有的东西，例如Header、标准方法与状态码。</p>
<p>从标准的角度看，HTTP标准是一项RFC标准，世界认可；而其他自定义的SOA标准则可能是一项个人标准或者公司标准，最多是一项互联网草案（这对大部分公司来说都不可能），而一项标准越是被广为认可接受，其实现的通用性就越强。个人标准和公司标准都五花八门，这样对每一个标准都要参照其相关文档实现相应的行为逻辑是很麻烦的。</p>
<h2 id="2-3-安全性"><a href="#2-3-安全性" class="headerlink" title="2.3    安全性"></a>2.3    安全性</h2><p>一个方法被调用1次与被调用0次是一样的，此方法就是安全的，否则就是不安全的。例如，一个方法A仅仅是读取数据，并不创建或者修改数据，不论A方法被调用多少次，都不对数据记录产生任何影响，A方法是安全的。而假如有另一个方法B对数据进行删除，B方法被调用1次后，数据会被删除（或者标识位被修改），系统里的数据发生了变化，那么B方法是不安全的。</p>
<h2 id="2-4-幂等性"><a href="#2-4-幂等性" class="headerlink" title="2.4    幂等性"></a>2.4    幂等性</h2><p>一个方法被同样地调用1次与被调用多次是一样的，即同样的输入会得到同样的输出，此方法就是幂等的，否则就不是幂等的。</p>
<p>2.3节中A方法与B方法都是幂等的，一个安全的方法一定是幂等的，一个幂等的方法不一定是安全的。</p>
<p>假设一个方法C对某个全局计数器执行自增操作并写入数据库，每次调用C方法都会对系统数据产生影响，那么C方法就不是幂等的。</p>
<h1 id="3-URL命名"><a href="#3-URL命名" class="headerlink" title="3 URL命名"></a>3 URL命名</h1><p>URL用于标识资源，因此URL应该以名词进行命名，例如<code>/users</code>, <code>/users/children</code>等。</p>
<p>一般URL会内嵌参数，例如要获取id为313的user的信息，那么URL应该为<code>/users/313</code>，前面的user采用复数，如果要列出其所有后代，则URL应为<code>/users/313/children</code>，children为复数形式，如果要获取其id为499的后代，则URL应为<code>/users/313/children/499</code></p>
<h1 id="4-消息实体"><a href="#4-消息实体" class="headerlink" title="4    消息实体"></a>4    消息实体</h1><p>消息实体，就是请求和响应消息中的<code>entity-body</code>（也称为body），消息实体采用JSON字符串格式。</p>
<h1 id="5-请求"><a href="#5-请求" class="headerlink" title="5 请求"></a>5 请求</h1><h2 id="5-1-方法"><a href="#5-1-方法" class="headerlink" title="5.1    方法"></a>5.1    方法</h2><p>使用HTTP标准定义的请求方法。</p>
<h3 id="5-1-1-get"><a href="#5-1-1-get" class="headerlink" title="5.1.1    get"></a>5.1.1    get</h3><p>获取资源，单个参数一般写在URL上，多个参数则作为query parameter附在URL后面，例如：</p>
<ul>
<li>单个参数：/user/123, 表示id为123的user</li>
<li>多个参数：/user?name=tom&amp;phone=13787890987&amp;gender=male</li>
</ul>
<p>get方法应为幂等的，并且不对数据记录产生影响。对于汉字与特殊字符，应该进行urlencode。</p>
<h3 id="5-1-2-post"><a href="#5-1-2-post" class="headerlink" title="5.1.2    post"></a>5.1.2    post</h3><p>创建资源，请求的headers里设置<code>Content-type</code>为<code>application/json</code>，参数为json类型。</p>
<p>根据约定，在创建成功之后，返回的状态码应该是201（Created），并且在response的Header里设置Location为新创建的资源的URL，例如，创建了一个新的user，该user创建后id为888，那么Header里应该设置<code>Location</code>为<code>/users/888</code>，当然，这应该是一个完整的URL，这里只是给出了一个相对路径的URI以作为说明。返回了这些数据后，客户端可以自定义后续行为，或者查看创建后的user，或者刷新当前的user列表，这些行为服务端并不关心。</p>
<p>如果重复提交了相同的数据，第一次应该返回201，以后则应返回409（Conflict），并且在response的Header里设置Location指向已经存在的资源，说明冲突的来源。</p>
<h3 id="5-1-3-put"><a href="#5-1-3-put" class="headerlink" title="5.1.3    put"></a>5.1.3    put</h3><p>更新资源，对现有资源进行修改，请求的headers与post一样，参数也是。此方法应该是幂等的。</p>
<h3 id="5-1-4-delete"><a href="#5-1-4-delete" class="headerlink" title="5.1.4    delete"></a>5.1.4    delete</h3><p>删除资源。此方法应是幂等的。</p>
<h2 id="5-2-Header"><a href="#5-2-Header" class="headerlink" title="5.2    Header"></a>5.2    Header</h2><p>Content-type应设为application/json。</p>
<p>另外应设置一个version，指明所使用的接口版本。这不属于HTTP协议中的一部分，是自定义的，出于版本控制的考量，具体见第七章。</p>
<h2 id="5-3-body"><a href="#5-3-body" class="headerlink" title="5.3    body"></a>5.3    body</h2><p>采用JSON字符串，具体的结构有待商定，这不属于HTTP协议的一部分，是自定义的。</p>
<p>这里主要放置业务相关的数据。</p>
<p>借用<a href="http://www.infoq.com/cn/articles/rest-introduction" target="_blank" rel="external">一篇10年前的文章</a>的一张图：<br><img src="http://otlnkjq1m.bkt.clouddn.com/REST_resources.jpg" alt=""></p>
<h1 id="6-响应"><a href="#6-响应" class="headerlink" title="6    响应"></a>6    响应</h1><h2 id="6-1-Header"><a href="#6-1-Header" class="headerlink" title="6.1    Header"></a>6.1    Header</h2><p>根据响应的状态码不同，相应地设置头部，具体见下一节。</p>
<p>但是在我所了解的公司里，做法都是统一返回200，然后在返回的JSON字符串里设置消息码。我是不能理解的。据一位前端同学说，前端代码接收到了请求以后，不方便获取Http状态码。其实我也写过前端，不深入，但是一些基本的知识还是有的，我觉得这并不难做到，估计是他的代码封装的时候没有考虑到这一点，现在要改比较麻烦，所以不想大动干戈、伤筋动骨。</p>
<h2 id="6-2-状态码"><a href="#6-2-状态码" class="headerlink" title="6.2    状态码"></a>6.2    状态码</h2><table>
<thead>
<tr>
<th>状态码</th>
<th>语义</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>OK</td>
<td>正常返回消息，什么问题也没有</td>
</tr>
<tr>
<td>201</td>
<td>Created</td>
<td>创建资源成功，Header里应设置Location指向新创建的资源</td>
</tr>
<tr>
<td>202</td>
<td>Accepted</td>
<td>请求已被接收，但是处理过程较长，不能马上返回结果</td>
</tr>
<tr>
<td>304</td>
<td>Not Modified</td>
<td>没有任何修改发生</td>
</tr>
<tr>
<td>401</td>
<td>Unauthorized</td>
<td>缺乏权限，指已经登录但是缺乏请求这个资源的权限</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>拒绝访问，可用于未登录时拦截返回的状态码，此时Header里应设置Location为登录页面的URL</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>不存在所请求的资源</td>
</tr>
<tr>
<td>406</td>
<td>Not Acceptable</td>
<td>请求没有被接收，参数约束校验不通过，或者其他业务类型的错误都可以返回这个状态码，response的body里应有表示错误信息的JSON实体。</td>
</tr>
<tr>
<td>409</td>
<td>Conflict</td>
<td>请求的资源有冲突，例如多次提交一样的创建请求，response的Header里应设置Location为产生冲突的资源的URL</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器的非业务类错误，response的body里应有表示错误信息的JSON实体</td>
</tr>
</tbody>
</table>
<h2 id="6-3-body采用JSON字符串。"><a href="#6-3-body采用JSON字符串。" class="headerlink" title="6.3    body采用JSON字符串。"></a>6.3    body采用JSON字符串。</h2><p>JSON的结构分为两种：成功、失败。</p>
<p>一般而言，只有返回200的时候才需要读取成功的JSON，只有返回406和500的时候才需要读取失败的JSON，对于其他的状态码，客户端不需要服务器提供额外的消息。</p>
<p>对于成功的JSON，里面应该只包含一个result对象，而失败的JSON应该使用这样的结构：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    error: &#123;</div><div class="line">        code: xxx,</div><div class="line">        message: <span class="string">"xxx"</span>,</div><div class="line">        data: <span class="meta">&#123;...&#125;</span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>失败的JSON只有一个error对象，包含错误码、消息及相关数据，message应该是直接可读的消息，客户端毋需理解发生了什么错误，客户端只需将消息展示出来即可。在收到406的时候，客户端只需知道发生的错误是由客户端造成的即可，具体是什么类型并不需要知道，将消息直接展示出来，让使用的人知道是什么即可，所以message应该是人类可以理解的文本。同理，收到500的时候，只需知道这个错误是服务端的问题即可，客户端也毋需知道具体的错误类型，最多就将错误码和消息展示出来，让使用者有反馈的依据即可。</p>
<h1 id="7-版本控制"><a href="#7-版本控制" class="headerlink" title="7 版本控制"></a>7 版本控制</h1><p>考虑到接口有可能升级，升级的类型有几种：</p>
<ol>
<li>新增功能接口</li>
<li>原有接口返回数据增加字段</li>
<li>现有接口返回数据变更现有字段格式或删除现有字段</li>
<li>现有接口变更业务逻辑</li>
<li>删除接口</li>
</ol>
<p>其中，前两种升级并不会影响客户端，因此毋需处理。而后面三种会导致使用旧接口的客户端不能正常工作。</p>
<p>一般服务端升级与客户端升级都不是同步的，客户端升级往往会滞后，因此在服务端升级后应该保留旧版本的接口继续运行一段时间，让未升级的客户端可以继续工作一段时间，同时可以上线新版本的客户端。过一段时间后再将旧版本的接口下线。</p>
<p>而版本控制应该是向下兼容的，即假设当前版本是1.2，如果客户端请求1.3版本的服务，应当用当前版本提供服务。如果没有注明请求的版本号，应当提供当前版本的服务。</p>
<p>一般情况下，客户端请求需要带版本号，但是服务端并不需要对此进行处理，除非是同时运行新旧版本的同一个接口，才需要做差异处理。</p>
<h1 id="8-实现工具"><a href="#8-实现工具" class="headerlink" title="8 实现工具"></a>8 实现工具</h1><h2 id="8-1-Spring-HATEOAS"><a href="#8-1-Spring-HATEOAS" class="headerlink" title="8.1    Spring HATEOAS"></a>8.1    Spring HATEOAS</h2><p>Spring HATEOAS可以很方便地与Spring MVC结合来开发RESTful接口。具体参照其文档：<br><a href="http://docs.spring.io/spring-hateoas/docs/0.20.0.RELEASE/reference/html/#fundamentals.jaxb-json" target="_blank" rel="external">http://docs.spring.io/spring-hateoas/docs/0.20.0.RELEASE/reference/html/#fundamentals.jaxb-json</a></p>
<h1 id="9-缺陷"><a href="#9-缺陷" class="headerlink" title="9 缺陷"></a>9 缺陷</h1><p>其实这个方案基本就是网上一些被大部分人认可的做法的汇总，但是缺乏细节，例如分页，但是其实这些可以灵活变通，例如在查询字符串里加上分页参数。《<a href="https://ruby-china.org/topics/31822" target="_blank" rel="external">一次无后端的供应链系统开发实践 (上篇)： 前后端分离的 Restful 接口设计</a>》这篇文章的设计就比较全面，但是两者考量的问题范畴不同，他这个是serverless的设计，将业务逻辑都压在前端，后端仅仅作为前端与数据源之间的代理（数据源、客户端都在自己控制范围内的话其实没必要这样搞），这样的话，接口要表达的逻辑就比较复杂，而本文还是从传统的抽象思想去考虑，逻辑都在后端封装，因此接口并不需要表达多么复杂的逻辑。</p>
<h1 id="10-参考文献"><a href="#10-参考文献" class="headerlink" title="10 参考文献"></a>10 参考文献</h1><p>当时写的时候没记下来，所以就不列出来了，在此不保证来源的权威性，请读者自行鉴别。^_^</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1 概述&quot;&gt;&lt;/a&gt;1 概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-撰写目的&quot;&gt;&lt;a href=&quot;#1-1-撰写目的&quot; class=&quot;headerlink&quot; title=&quot;1.1 撰写目的&quot;&gt;&lt;/a&gt;1.1 撰写目的&lt;/h2&gt;&lt;p&gt;本文用于定义一种统一的RESTful接口设计方案，希望具有参考价值。本文所描述的方案比较学院派（死板），在上一家公司提出没有被采纳，在所了解到的有限的若干家声称采用了RESTful风格的公司里，发现他们也偏离甚远，而在书本以及网上大部分介绍RESTful的资料里，却都是这样的方案（URL命名风格、请求与响应的设计）。当然，他们这么做是有理由的，我也理解，这只是取舍问题。这篇文章其实是旧文了，2016年年底就已经写好，但是一直躺在电脑的硬盘里，不想白费了当时的功夫，因此在此公开。&lt;/p&gt;
&lt;h2 id=&quot;1-2-为什么采用REST&quot;&gt;&lt;a href=&quot;#1-2-为什么采用REST&quot; class=&quot;headerlink&quot; title=&quot;1.2    为什么采用REST&quot;&gt;&lt;/a&gt;1.2    为什么采用REST&lt;/h2&gt;&lt;p&gt;目的是为了服务端与客户端的解耦。SOA仅仅是从结构上将前后端分离，但是实际上数据逻辑还是没有实现解耦，服务端接口升级往往会影响客户端，两者的行为需要严格约定。而REST采用HTTP协议进行约定，客户端仅仅需要按照HTTP协议来理解服务端返回的数据，虽然与业务相关的数据结构还是需要约定，但是这确实进一步解耦了服务端与客户端。&lt;/p&gt;
&lt;p&gt;另外，由于严格遵照HTTP协议进行数据返回，对于安全的接口，可以在返回的Header里设置缓存策略（接口安全性的概念在下文会解释）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="REST" scheme="http://bungder.github.io/tags/REST/"/>
    
  </entry>
  
</feed>
